<?php
/* Dashboard Builder.
   Copyright (C) 2018 DISIT Lab https://www.disit.org - University of Florence

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as
   published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Affero General Public License for more details.
   You should have received a copy of the GNU Affero General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */
include ('../config.php');
header("Cache-Control: private, max-age=$cacheControlMaxAge");
if (!isset($_SESSION)) {
    session_start();
    session_write_close();
}
?>

<style type="text/css">
        .p5Canvas{
            z-index: 400;
            pointer-events: none;
    }

    .left {
        float: left;
    }

    .right {
        float: right;
    }

    .switch {
        position: relative;
        display: inline-block;
        width: 80px;
        height: 15px;
        float: right
    }

    .switch input {
        display: none;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: -4px;
        background-color: #DBDBDB;
        -webkit-transition: .4s;
        transition: .4s;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 14px;
        width: 14px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        -webkit-transition: .4s;
        transition: .4s;
    }

    input:checked+.slider {
        background-color: #86C5F9;
    }

    input:focus+.slider {
        box-shadow: 0 0 1px #2196F3;
    }

    input:checked+.slider:before {
        -webkit-transform: translateX(62px);
        -ms-transform: translateX(62px);
        transform: translateX(62px);
    }

    /*------ ADDED CSS ---------*/
    .animationOn {
        display: none;
    }

    .animationOn,
    .animationOff {
        color: white;
        position: absolute;
        transform: translate(-50%, -50%);
        top: 50%;
        left: 50%;
        font-size: 11px;
        font-family: Verdana, sans-serif;
    }

    input:checked+.slider .on {
        display: block;
    }

    input:checked+.slider .off {
        display: none;
    }

    /*--------- END --------*/

    /* Rounded sliders */
    .slider.round {
        border-radius: 28px;
    }

    .slider.round:before {
        border-radius: 50%;
    }

    .leaflet-center {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    #headerDraggable {
        background-color: #A1BBD8;
        width: 100%;
        heigth: 8%;
        padding: 1%;
        cursor: pointer;
        font-weight: bold
    }
</style>

<style>
/*-- POPUP STYLE -**/
    .leaflet-popup-content {
        margin: 0;
        line-height: 1.5;
        width: auto !important;
    }

    .leaflet-popup-tip-container {
        display: none;
    }

    .leaflet-popup-content-wrapper {
        width: auto;
    }

    .leaflet-popup{
        max-width: 500px; /* Larghezza massima per i popup */
        min-width: 350px; /* Larghezza minima per i popup */
        
    }

</style>

<!-- Bring in the leaflet KML plugin -->
<script src="../widgets/layers/KML.js"></script>

<!-- Cristiano: Dynamic Routing -->
<link rel="stylesheet" href="../css/dynamic_routing/dynamic_routing.css" />
<!-- end Cristiano -->

<script type="text/javascript" src="../js/heatmap/heatmap.js"></script>
<script type="text/javascript" src="../js/heatmap/leaflet-heatmap.js"></script>
<script src="../leaflet-bubble/dist/leaflet-bubble.js"></script>

<script src="../trafficRTDetails/js/leaflet.awesome-markers.min.js"></script>
<script src="../trafficRTDetails/js/jquery.dialogextend.js"></script>
<script src="../trafficRTDetails/js/leaflet-gps.js"></script>
<script src="../trafficRTDetails/js/wicket.js"></script>
<script src="../trafficRTDetails/js/wicket-leaflet.js"></script>
<script src="../trafficRTDetails/js/date.format.js"></script>
<script src="../trafficRTDetails/js/zoomHandler.js"></script>
<script src="../trafficRTDetails/js/OpenLayers-2.13.1/OpenLayers.js"></script>

<script type="text/javascript" src="../js/date_fns.min.js"></script>
<script type="text/javascript" src="../js/moment-timezone-with-data.js"></script>
<script type="text/javascript" src="../js/moment-with-locales.min.js"></script>

<script src="../js/jsonpath-0.8.0.js"></script>

<script type="text/javascript" src="../js/dynamic_routing/leaflet-routing-machine.js"></script>

<script src="../js/jquery.datetimepicker.min.js"></script>
<link rel="stylesheet" href="../css/jquery.datetimepicker.min.css" />
<!-- dBologna VectorFlow -->
<script src="../js/p5.js"></script>

<!-- SCENARY EDITOR ADREANI -->
<!-- FINE ADREANI -->

<!-- LEAFLET ANIMATOR PLUGIN -->
<!-- <script type="text/javascript" src="../js/leaflet-wms-animator.js"></script> -->

<!--ARROW -->
<script type="text/javascript" src="../js/leaflet.polylineDecorator.js"></script>
<!-- EDITABLE POLYLINE -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-editable/dist/leaflet.editable.css" />
<script src="https://unpkg.com/leaflet-editable/dist/Leaflet.Editable.js"></script>
<!-- -->
<script type="text/javascript" src="../js/leaflet-editable-polyline.js"></script>
<!--<script type="text/javascript" src="../js/scenaryEditor.js"></script>-->

<!-- PROJ4 -->

<script type="text/javascript" src="../js/proj4.js"></script>
<!--
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.10.0/proj4.js" integrity="sha512-e3rsOu6v8lmVnZylXpOq3DO/UxrCgoEMqosQxGygrgHlves9HTwQzVQ/dLO+nwSbOSAecjRD7Y/c4onmiBVo6w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
 -->

<script type='text/javascript'>
const popupResizeObserver = new ResizeObserver(function(mutations) {
    mutations[0].target._draggable.disable()
});
    ////////////ADREANI Nuova Classe
    class KBRoadEditor {
        sensors;
        sensorsList;
        map;
        segments;
        nodes;
        filterTypes;
        restrictions;
        creatingNode = false;
        historicActions = [];
        redoActions = [];
        segmentUpdated;
        segmentCallback;
        mode = 'drag';
        showAll = true;
        arrowMinZoom = 16;
        nodeMinZoom = 17;
        typeMinZoom = 17;
        typeMinZoomFilter = [
            "steps",
            "pedestrian",
            "path",
            "footway"
        ];
        typeColors = {
            cycleway: {
                color: 'cyan',
                hover: 'green'
            },
            steps: {
                color: 'yellow',
                hover: 'green'
            },
            pedestrian: {
                color: 'yellow',
                hover: 'green'
            },
            path: {
                color: 'yellow',
                hover: 'green'
            },
            footway: {
                color: 'yellow',
                hover: 'green'
            },
            default: {
                color: 'blue',
                hover: 'green',
                bidirectional: {
                    color: 'red',
                }
            },
            tram: {
                color: 'green',
                hover: 'green'
            },
            restrictionTo: {
                color: '#BD438D'
            },
            restrictionFrom: {
                color: 'green'
            },
            errorColor: {
                color: '#900C3F'
            }
        };
        tableMetersZoomNode = {
            "0": 10,
            "1": 10,
            "2": 10,
            "3": 10,
            "4": 10,
            "5": 10,
            "6": 10,
            "7": 10,
            "8": 10,
            "9": 10,
            "10": 10,
            "11": 10,
            "12": 10,
            "13": 10,
            "14": 10,
            "15": 10,
            "16": 2.5, //5,
            "17": 2.5, //5,
            "18": 1.5, //3,
            "19": 1, //2,
            "20": 0.5, //1,
            "21": 0.4, //0.8,
            "22": 0.3, //0.6,
            "23": 0.2, //0.4,
        }
        tableMetersZoomArrow = {
            "17": 13,
            "18": 15,
            "19": 15,
            "20": 18,
            "21": 19,
            "22": 20,
            "23": 21,
        }

        constructor(map, graph, sensorsList, restrictions, segmentCallback = (segment) => { }) {
            this.map = map;
            this.segments = {};
            this.nodes = {};
            this.segmentCallback = segmentCallback;
            this.sensorsList = sensorsList;
            this.selectedSensorById;

            this.restrictions = restrictions;

            this.mode = 'drag';

            this.loadGraph(graph);
            this.filterTypes = [];
            this.filterTypes = ["primary",
                "tertiary",
                "footway",
                "residential",
                "trunk_link",
                "motorway",
                "track",
                "secondary_link",
                "service",
                "tertiary_link",
                "path",
                "via_ferrata",
                "cycleway",
                "living_street",
                "primary_link",
                "emergency_bay",
                "steps",
                "motorway_link",
                "services",
                "disused",
                "road",
                "construction",
                "raceway",
                "emergency_access_point",
                "bridleway",
                "abandoned",
                "platform",
                "elevator",
                "bus_stop",
                "rest_area",
                "yes",
                "no",
                "corridor",
                "island",
                "crossing",
                "razed",
                "private",
                "pedestrian",
                "traffic_island",
                "bus_guideway",
                "ohm:military:Trench",
                "unclassified",
                "secondary",
                "tram"];


            this.map.on('mousedown', (e) => {
                if (this.mode !== 'create')
                    return;
                if (this.creatingNode)
                    return;

                console.log('map down');
                this.map.dragging.disable();
                const { lat, lng } = e.latlng;
                const newNode = this.createBlankNode(lat, lng);
                this.drawNode(newNode);
                newNode.circle.fire('mousedown');
                let nodeHandled = true
                this.map.on('mouseup', (e) => {
                    if (this.mode !== 'create')
                        return;
                    if (nodeHandled) {
                        newNode.circle.fire('mouseup');
                        nodeHandled = false;
                    }
                });
            });

            this.map.on('moveend', (e) => {
                this.draw();
            })
            this.map.on('zoomend', () => {
                //this.clearSegments();
                //this.clearNodes();
                this.draw();
            });
            this.draw();
            this.updateHistoricAction();
        }

        isSegmentVisualized(segment) {
            let visualized = false;
            for (let filterType of this.filterTypes) {
                if (segment.type === filterType) {
                    visualized = true;
                    break;
                }
            }
            return visualized;
        }

        getSegmentsForSaving() {
            const currentSegments = this.deepCopySegments();
            const segmentToSave = [];
            for (let key in currentSegments) {
                const cs = currentSegments[key];
                let needToSave = this.isSegmentVisualized(cs);
                if (needToSave)
                    segmentToSave.push(cs);
            }
            return segmentToSave;
        }

        reset() {
            this.clearSegments();
            this.clearNodes();
            this.segments = {};
            this.nodes = {};
            this.historicActions = [];
            this.redoActions = [];
            this.creatingNode = false;
            this.segmentUpdated = undefined;
        }


        loadSensors(sensorsList) {
            ///this.reset();
            this.sensorsList = sensorsList;  
            /*sensorsList.forEach((element) => {
                        //console.log(element.sensorUri);
                        let sUri = element.sensorUri;
                        if(this.segments[sUri]){
                            this.segments[sUri].sensor = JSON.stringify(element);
                           //this.sensors.push(element);
                        }
                    });*/
        }

        updateSensors(sensor) {
            ///this.reset();
            this.sensors = sensor;
            console.log(this.sensorsList);
        }

        loadGraph(graph) {
            this.reset();
            graph = JSON.parse(JSON.stringify(graph));

            for (let segment of graph) {

                const segmentId = segment.segment;
                const nodeAId = segment.nodeA;
                const nodeBId = segment.nodeB;
                
                

                // nodo a
                if (!this.nodes.hasOwnProperty(nodeAId))
                    this.nodes[nodeAId] = {
                        lat: segment.nALat,
                        long: segment.nALong,
                        id: nodeAId,
                        segments: {}
                    };
                this.nodes[nodeAId].segments[segmentId] = 'A';

                // nodo b
                if (!this.nodes.hasOwnProperty(nodeBId))
                    this.nodes[nodeBId] = {
                        lat: segment.nBLat,
                        long: segment.nBLong,
                        id: nodeBId,
                        segments: {}
                    };
                this.nodes[nodeBId].segments[segmentId] = 'B';

                // segmento
                this.segments[segmentId] = segment;
                //console.log(segment);
                //db_NEW
               /* try {
                    const segmentSensor = this.selectSensor(segmentId);
                    //this.sensors = segmentSensor;
                    console.log("trovato",segmentSensor);
                } catch (error) {
                    console.log('error',error);
                }*/
            }
        }

        haversine(lat1, lon1, lat2, lon2) {
            // Convert latitude and longitude from degrees to radians
            const toRadians = (angle) => (angle * Math.PI) / 180;
            lat1 = toRadians(lat1);
            lon1 = toRadians(lon1);
            lat2 = toRadians(lat2);
            lon2 = toRadians(lon2);

            // Haversine formula
            const dlat = lat2 - lat1;
            const dlon = lon2 - lon1;
            const a = Math.sin(dlat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) ** 2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            // Radius of Earth in meters (mean value)
            const radiusEarth = 6371000; // meters

            // Calculate the distance
            const distance = radiusEarth * c;

            return distance;
        }

        addEventListeners() {
            // setthis.mode event
            // $('#line_view').click(() => this.mode = 'view');
            // $('#line_create').click(() => this.mode = 'create');
            // $('#line_drag').click(() => this.mode = 'drag');
            // $('#line_delete').click(() => this.mode = 'delete');
            // $('#line_split').click(() => this.mode = 'split');

            // undo and redo functionality
            $('#line_undo').click(() => {
                console.log('undo');
                this.undo();
            });
            $('#line_redo').click(() => {
                console.log('redo');
                this.redo();             
            });
        }

        deepCopySegments() {
            const segmentsToCopy = {};
            for (let segmentID in this.segments) {
                const segmentToCopy = Object.assign({}, this.segments[segmentID]);
                delete segmentToCopy.line;
                delete segmentToCopy.arrow;
                segmentsToCopy[segmentID] = segmentToCopy;
            }
            return JSON.parse(JSON.stringify(segmentsToCopy));
        }

        deepCopyNodes() {
            const nodesToCopy = {};
            for (let nodeID in this.nodes) {
                const nodeToCopy = Object.assign({}, this.nodes[nodeID]);
                delete nodeToCopy.circle;
                nodesToCopy[nodeID] = nodeToCopy;
            }
            return JSON.parse(JSON.stringify(nodesToCopy));
        }

        updateHistoricAction(segmentUpdated) {
            const historicAction = {
                segments: this.deepCopySegments(),
                nodes: this.deepCopyNodes(),
                segmentUpdated
            }
            this.segmentUpdated = segmentUpdated;
            this.historicActions.push(historicAction);
            this.redoActions = [];
        }

        undo() {
            if (this.historicActions.length < 2)
                return

            this.clearSegments();
            this.clearNodes();

            const redoAction = {
                segments: this.deepCopySegments(),
                nodes: this.deepCopyNodes(),
                segmentUpdated: this.segmentUpdated,
            }
            this.redoActions.push(redoAction);
            this.historicActions.pop();

            const actualAction = this.historicActions[this.historicActions.length - 1];
            this.segments = actualAction.segments;
            this.segments = this.deepCopySegments();
            this.nodes = actualAction.nodes;
            this.nodes = this.deepCopyNodes();
            this.segmentUpdated = actualAction.segmentUpdated;

            this.draw();

            if (redoAction.segmentUpdated)
                this.segmentClicked(this.segments[redoAction.segmentUpdated]);
        }

        redo() {
            if (this.redoActions.length < 1)
                return;

            this.clearSegments();
            this.clearNodes();

            const actualAction = this.redoActions.pop();
            this.segments = actualAction.segments;
            this.segments = this.deepCopySegments();
            this.nodes = actualAction.nodes;
            this.nodes = this.deepCopyNodes();
            this.segmentUpdated = actualAction.segmentUpdated;

            const historicAction = {
                segments: this.deepCopySegments(),
                nodes: this.deepCopyNodes(),
                segmentUpdated: this.segmentUpdated,
            }
            this.historicActions.push(historicAction);

            this.draw();

            if (this.segmentUpdated)
                this.segmentClicked(this.segments[this.segmentUpdated]);
        }

        //Restrctions
        restrictionCallback;
        selectedRestriction = {};
        selectedRestrictionSegment;
        lastMode;
        enableRestrictionSelection(segment, callback) {
            console.log('Executing <enableRestrictionSelection>');
            this.restrictionCallback = callback;
            this.lastMode = this.mode;
            this.mode = 'restriction';
            this.selectedRestrictionSegment = segment;
            this.selectedRestriction = {
                from: segment.segment,
            }
            this.draw();
        }

        selectRestriction(restriction) {
            this.selectedRestriction = {
                via: "http://www.disit.org/km4city/resource/" + restriction.node.value || restriction.node,
                to: "http://www.disit.org/km4city/resource/" + restriction.to.value || restriction.to,
                from: "http://www.disit.org/km4city/resource/" + restriction.from.value || restriction.from,
            };
            this.draw();
        }

        segmentColored;

                // selectRestrictionColor(restriction) {
        //     /* this.selectedRestriction = {
        //          via: restriction.node,
        //          to: restriction.to,
        //          from: restriction.from,
        //      };*/
        //     //this.mode = 'drag';
        //     const tmpSegment = this.segmentColored;
        //     this.segmentColored = this.segments[restriction.to];
        //     this.selectedRestriction = null;
        //     //this.segments[restriction.to].line.color='black';
        //     //this.drawSegment();

        //     if (this.segmentColored) {
        //         this.drawSegment(this.segmentColored, { color: '#BD438D' });
        //         //old color: 6f00c4
        //     }
        //     if (tmpSegment) {
        //         this.drawSegment(tmpSegment);
        //     }
        //     this.drawAllNodes();
        // }

        selectRestrictionColor(restriction) {
            var REto = null;
            var REfrom = null;
            if(Reflect.ownKeys(restriction).length === 0){
                REto = this.segments[this.selectedRestriction.to];
                REfrom = this.segments[this.selectedRestriction.from];
                this.selectedRestriction = null;
            }else{
                this.selectedRestriction = {
                    via: restriction.node,
                    to: restriction.to,
                    from: restriction.from,
                };
                //this.mode = 'drag';
                REto = this.segments[this.selectedRestriction.to];
                REfrom = this.segments[this.selectedRestriction.from];
            }
            if(REto != null){
                this.drawSegment(REto);
            }
            if(REfrom != null){
                this.drawSegment(REfrom);
            }
            this.drawAllNodes();
        }

        checkConnection(segmentA, segmentB) {
            let attachedNode;
            if (segmentA.nodeA === segmentB.nodeA)
                attachedNode = segmentA.nodeA;
            else if (segmentA.nodeA === segmentB.nodeB)
                attachedNode = segmentA.nodeA;
            else if (segmentA.nodeB === segmentB.nodeA)
                attachedNode = segmentA.nodeB;
            else if (segmentA.nodeB === segmentB.nodeB)
                attachedNode = segmentA.nodeB;
            return attachedNode
        }

        checkConnectionByID(idA, idB) {
            const segmentA = this.segments[idA];
            const segmentB = this.segments[idB];
            if (!segmentA || !segmentB) {
                return;
            }
            return this.checkConnection(segmentA, segmentB);
        }

        segmentClicked(segment) {
            if (this.mode === 'restriction') {
                //console.log(segment);
                if (segment.segment === this.selectedRestrictionSegment.segment)
                    return;
                let attachedNode;
                if (segment.nodeA === this.selectedRestrictionSegment.nodeA)
                    attachedNode = segment.nodeA;
                else if (segment.nodeA === this.selectedRestrictionSegment.nodeB)
                    attachedNode = segment.nodeA;
                else if (segment.nodeB === this.selectedRestrictionSegment.nodeA)
                    attachedNode = segment.nodeB;
                else if (segment.nodeB === this.selectedRestrictionSegment.nodeB)
                    attachedNode = segment.nodeB;
                this.restrictionCallback(segment, attachedNode);
                if (attachedNode) {
                    this.selectedRestriction.to = segment.segment;
                    this.selectedRestriction.via = attachedNode;
                }
                this.mode = this.lastMode;
                this.draw();
            } else {
                this.segmentCallback(segment);
            }
        }
        //Restritions
        /*
        segmentClicked(segment) {
            this.segmentCallback(segment);
        }*/

        updateSegmentData(segment) {
            const segmentUpdated = segment.segment;
            this.segments[segment.segment] = segment;
            this.updateHistoricAction(segmentUpdated);
        }

        getTimestamp() {
            const now = new Date();
            return now.getTime();
        }

        createBlankNode(lat, long) {
            const newNode = {
                id: `http://www.disit.org/km4city/resource/${this.getTimestamp()}${Math.floor(Math.random() * 100)}`,
                lat,
                long,
                segments: {}
            }
            this.nodes[newNode.id] = newNode;
            return newNode;
        }

        createLinkNodes(nodeA, nodeB) {
            const timestamp = this.getTimestamp();
            for (let id in this.segments){
                const tmp = timestamp.toString().slice(0,-3);
                if(this.segments[id].segment.includes(tmp)){
                    return;
                }
            }
            const newSegment = {
                road: `http://www.disit.org/km4city/resource/${timestamp}`,
                segment: `http://www.disit.org/km4city/resource/${timestamp}/0`,
                type: "unclassified",
                dir: "tratto stradale aperto nella direzione positiva (da giunzione NOD_INI a giunzione NOD_FIN)",
                length: 1,
                lanes: "1",
                roadElmSpeedLimit: 50,
                elemType: "",
                operatingstatus: ""
            }
            this.setNodeToSegment(newSegment, nodeA, "A");
            this.setNodeToSegment(newSegment, nodeB, "B");
            this.segments[newSegment.segment] = newSegment;
            console.log('New segment added to scenario. ID: ' + this.segments[newSegment.segment].segment);
            return newSegment;
        }

        clearSegment(segment) {
            if (segment.line) {
                this.map.removeLayer(segment.line);
                delete segment.line;
            }
            if (segment.arrow) {
                this.map.removeLayer(segment.arrow);
                delete segment.arrow;
            }
        }

        clearSegments() {
            for (let segmentID in this.segments) {
                this.clearSegment(this.segments[segmentID]);
            }
        }

        clearNode(node) {
            if (node.circle) {
                this.map.removeLayer(node.circle);
                delete node.circle;
            }
        }

        clearNodes() {
            for (let nodeID in this.nodes) {
                this.clearNode(this.nodes[nodeID]);
            }
        }

        removeSegment(segment) {
            this.map.removeLayer(segment.line);
            this.map.removeLayer(segment.arrow);
            delete this.nodes[segment.nodeA].segments[segment.segment];
            delete this.nodes[segment.nodeB].segments[segment.segment];
            delete this.segments[segment.segment];

            this.drawNode(this.nodes[segment.nodeA]);
            this.drawNode(this.nodes[segment.nodeB]);
        }

        //db_NEW
        selectedSensor(sensor){
            console.log(sensor);
            let sensoreTrovato = this.sensorsList.find(sensore => sensore.idSensor === sensor);
                if (sensoreTrovato) {
                    this.selectedSensorById = sensoreTrovato;
                    //console.log('Sensor founded by Id:', sensoreTrovato.sensorUri);
                    //console.log('Sensor segment:',this.segment);
                    //sensoreTrovato.sensorUri = this.segment.segment;
                }
        }


        //TEST NEW DRAW
        drawSegment(segment, props) {
            if (segment.line)
                this.map.removeLayer(segment.line);
            if (segment.arrow)
                this.map.removeLayer(segment.arrow);

            const isVisualized = this.isSegmentVisualized(segment);
            const opacity = (isVisualized && this.showAll) ? 1 : 0;
            // var opacity = 1;
            // if(isVisualized && this.showAll){
            //     opacity = 1;
            // } else {
            //     opacity = 0;
            // }
            //const opacity = isVisualized ? 1 : 0;

            let type;
            let colorScheme = this.typeColors.hasOwnProperty(segment.type) ? this.typeColors[segment.type] : this.typeColors.default;
            let color = colorScheme.color;
            if (segment.dir.includes('tratto stradale aperto nella direzione positiva')) {
                type = 'positive';
            } else if (segment.dir.includes('tratto stradale chiuso in entrambe le direzioni')) {
                type = 'closed';
                color = 'gray';
            } else if (segment.dir.includes('tratto stradale aperto nella direzione negativa')) {
                type = 'negative';
            }else if (segment.dir.includes('none')) {
                type = 'positive';
            } else if (segment.dir.includes('tratto stradale aperto in entrambe le direzioni (default)')){
                type = 'bidirectional';
                if (colorScheme.bidirectional) {
                    color = colorScheme.bidirectional.color;
                }
            }

            if (segment.hasError && segment.hasError == true) {
                color = this.typeColors['errorColor'].color;
            }

            // imposto il colore viola se è stato impostato nell'accorpato come non ottimizzabile
            if (segment.notOptimizable==true){
                color = 'purple';
            }

            if (this.selectedRestriction) {
                if (this.selectedRestriction.from === segment.segment) {
                    color = 'green';
                } else if (this.selectedRestriction.to === segment.segment) {
                    color = '#BD438D';
                }
            }
            if (this.segmentColored && this.segmentColored.segment === segment.segment) {
                color = '#BD438D';
            }
            segment.line = L.polyline([
                new L.LatLng(segment.nALat, segment.nALong),
                new L.LatLng(segment.nBLat, segment.nBLong)
            ], {
                color,
                weight: 5,
                opacity,
                ...props
            }).addTo(this.map);

            // arrow
            const patterns = [];

            if (type !== 'negative' && this.map.getZoom() > this.arrowMinZoom) {
                patterns.push({
                    offset: '80%',
                    repeat: 0,
                    symbol: L.Symbol.arrowHead({
                        // pixelSize: 10,
                        pixelSize: this.tableMetersZoomArrow[this.zoomTableSize()],
                        polygon: true,
                        pathOptions: {
                            stroke: true,
                            fillColor: color,
                            fillOpacity: opacity,
                            opacity,
                            fill: true,
                            color,
                            ...props
                        }
                    })
                });
            }
            if ((type === 'negative' || type === 'bidirectional') && this.map.getZoom() > this.arrowMinZoom)
                patterns.push(
                    {
                        offset: '20%',
                        repeat: 0,
                        symbol: L.Symbol.arrowHead({
                            pixelSize: this.tableMetersZoomArrow[this.zoomTableSize()],
                            // pixelSize: 10,
                            polygon: true,
                            headAngle: 420,
                            pathOptions: {
                                stroke: true,
                                fillColor: color,
                                fillOpacity: opacity,
                                opacity,
                                fill: true,
                                color,
                                ...props
                            }
                        })
                    }
                )
            var arrow = L.polylineDecorator(segment.line, { patterns }).addTo(this.map);

            // mouseover / mouseout event probably no more in use ///////////////////////
            arrow.on({
                click: () => {
                    segment.line.fire('click');
                },
                mouseover: () => {
                    if (this.mode !== 'delete' && this.mode !== 'split' && this.mode !== 'restriction' && this.mode !== 'assignSensor')
                        return;
                    segment.line.setStyle({ color: 'green' });
                    segment.arrow.setStyle({
                        fillColor: colorScheme.hover,
                        color: colorScheme.hover
                    });
                    segment.arrow.bringToFront();
                },
                mouseout: () => {
                    if(segment.hasError && segment.hasError == true){
                        color = this.typeColors['errorColor'].color;
                    } else if(
                        !this.selectedRestriction.hasOwnProperty('to') ||
                        (
                            this.selectedRestriction.to != segment.segment &&
                            this.selectedRestriction.from != segment.segment
                        )
                    ){
                        colorScheme = this.typeColors.hasOwnProperty(segment.type) ? this.typeColors[segment.type] : this.typeColors.default;
                        if(colorScheme == this.typeColors.default && segment.dir == "tratto stradale aperto in entrambe le direzioni (default)"){
                            colorScheme = this.typeColors.default.bidirectional;
                        }
                        color = colorScheme.color;
                    } else if (this.selectedRestriction.to == segment.segment) {
                        color = this.typeColors['restrictionTo'].color;
                    } else if (this.selectedRestriction.from == segment.segment) {
                        color = this.typeColors['restrictionFrom'].color;
                    }
                    // collini anche qui per far rimanere vioe e non farlo tornare blu per gli non ottimizzabili
                    if (segment.notOptimizable == true){
                        color = "purple"                        
                    }
                    segment.line.setStyle({ color, ...props });                                       
                    segment.arrow.setStyle({
                        fillColor: color,
                        color,
                        ...props
                    });
                }
            })
            segment.arrow = arrow;

            // Probably no more in use! //
            // hover effect 
            segment.line.on('mouseover', () => {
                if (this.mode !== 'delete' && this.mode !== 'split' && this.mode !== 'restriction' && this.mode !== 'assignSensor')
                    return;
                segment.line.setStyle({ color: 'green' });
                segment.arrow.setStyle({
                    fillColor: colorScheme.hover,
                    color: colorScheme.hover
                });
            });

            // Change border color back to red on mouseout
            segment.line.on('mouseout', () => {
                if(segment.hasError && segment.hasError == true){
                        color = this.typeColors['errorColor'].color;
                } else if(
                    !this.selectedRestriction.hasOwnProperty('to') ||
                    (
                        this.selectedRestriction.to != segment.segment &&
                        this.selectedRestriction.from != segment.segment
                    )
                ){
                    colorScheme = this.typeColors.hasOwnProperty(segment.type) ? this.typeColors[segment.type] : this.typeColors.default;
                    if(colorScheme == this.typeColors.default && segment.dir == "tratto stradale aperto in entrambe le direzioni (default)"){
                        colorScheme = this.typeColors.default.bidirectional;
                    }
                    color = colorScheme.color;
                    //collini-> cerco di risolvere l'hover che mi torna blu...
                    if (segment.notOptimizable) {
                        color = 'purple'; 
                    }
                } else if (this.selectedRestriction.to == segment.segment) {
                    color = this.typeColors['restrictionTo'].color;
                } else if (this.selectedRestriction.from == segment.segment) {
                    color = this.typeColors['restrictionFrom'].color;
                }
                segment.line.setStyle({ color, ...props });
                segment.arrow.setStyle({
                    fillColor: color,
                    color,
                    ...props
                });
            });

            segment.line.on({
                click: () => {
                    if (this.mode === 'delete') {
                        var restrictionIdxs = [];
                        for(let i=0; i < this.restrictions.length; i++){
                            const resFrom = 'http://www.disit.org/km4city/resource/' + this.restrictions[i].from.value;
                            const resTo = 'http://www.disit.org/km4city/resource/' + this.restrictions[i].to.value;
                            if(resFrom == segment.segment || resTo == segment.segment){
                                restrictionIdxs.push(i);
                            }
                        }

                        for(let i=0; i < restrictionIdxs.length; i++){
                            this.restrictions.splice(restrictionIdxs[i], 1);
                        }

                        this.removeSegment(segment);
                        this.updateHistoricAction();
                    } else if (this.mode === 'split') {

                        var restrictionIdxs = [];
                        for(let i=0; i < this.restrictions.length; i++){
                            const resFrom = 'http://www.disit.org/km4city/resource/' + this.restrictions[i].from.value;
                            const resTo = 'http://www.disit.org/km4city/resource/' + this.restrictions[i].to.value;
                            if(resFrom == segment.segment){
                                restrictionIdxs.push({
                                    idx: i,
                                    kind: 'from'
                                });
                            }
                            if(resTo == segment.segment){
                                restrictionIdxs.push({
                                    idx: i,
                                    kind: 'to'
                                });
                            }
                        }

                        const lineLatLng = segment.line.getLatLngs();
                        const nodeLat = (lineLatLng[0].lat + lineLatLng[1].lat) / 2;
                        const nodeLng = (lineLatLng[0].lng + lineLatLng[1].lng) / 2;
                        const newNode = this.createBlankNode(nodeLat, nodeLng);

                        const segmentA = Object.assign({}, segment);
                        segmentA.segment += '_A';
                        const segmentB = Object.assign({}, segment);
                        segmentB.segment += '_B';

                        this.setNodeToSegment(segmentA, this.nodes[segment.nodeA], "A");
                        this.setNodeToSegment(segmentA, newNode, "B");
                        this.setNodeToSegment(segmentB, newNode, "A");
                        this.setNodeToSegment(segmentB, this.nodes[segment.nodeB], "B");

                        this.segments[segmentA.segment] = segmentA;
                        this.segments[segmentB.segment] = segmentB;

                        function removeURI(data){
                            var spitid = data.split('/');
                            return spitid[spitid.length - 2] + '/' + spitid[spitid.length - 1];
                        }

                        for(let i=0; i < restrictionIdxs.length; i++){
                            var res = this.restrictions[restrictionIdxs[i].idx];
                            var kind = restrictionIdxs[i].kind;
                            var resNode = 'http://www.disit.org/km4city/resource/' + res.node.value;
                            if(resNode == segment.nodeA){
                                if(kind == 'from'){
                                    this.restrictions[restrictionIdxs[i].idx].from.value = removeURI(segmentA.segment);
                                } else if(kind == 'to'){
                                    this.restrictions[restrictionIdxs[i].idx].to.value = removeURI(segmentA.segment);
                                }
                            } else if (resNode == segment.nodeB){
                                if(kind == 'from'){
                                    this.restrictions[restrictionIdxs[i].idx].from.value = removeURI(segmentB.segment);
                                } else if(kind == 'to'){
                                    this.restrictions[restrictionIdxs[i].idx].to.value = removeURI(segmentB.segment);
                                }
                            }
                        }

                        this.removeSegment(segment);

                        this.draw();
                        this.updateHistoricAction();
                    } else if(this.mode === 'assignSensor'){
                            console.log('here change assigned');
                            console.log(this.selectedSensorById);
                            if(this.selectedSensorById.sensorUri == this.selectedSensorById.assignedRoadElement){
                                this.selectedSensorById.sensorUri = segment.segment;
                            }
                            this.selectedSensorById.assignedRoadElement = segment.segment;
                            this.selectedSensorById.moveSensor(segment.line.getLatLngs());
                           // this.selectedSensorById.sensorUri = segment.segment;
                            console.log(this.selectedSensorById);
                            this.mode = 'drag';
                            //1) Coordinate 

                            /*let sensoreTrovato = this.sensorsList.find(sensore => sensore.sensorUri === segment.segment);
                                    if (sensoreTrovato) {
                                        console.log('Sensore trovato:', sensoreTrovato);
                                    } */               
                                  /*             sensoreTrovato.moveSensor(segment.line.getLatLngs());
                                    }*/
                                    //
                            //2)cercare nella lista dei sensori
                    } else {
                        this.segmentClicked(segment);
                    }
                }
            });
        }
        /*
        drawSegment(segment) {
                if (segment.line)
                    this.map.removeLayer(segment.line);
                if (segment.arrow)
                    this.map.removeLayer(segment.arrow);
        
                const isVisualized = this.isSegmentVisualized(segment);
                const opacity = isVisualized ? 1 : 0;
        
                let color;
                let type;
                if (segment.dir.includes('tratto stradale aperto nella direzione positiva')) {
                    type = 'positive';
                    color = 'blue';
                } else if (segment.dir.includes('tratto stradale chiuso in entrambe le direzioni')) {
                    type = 'closed';
                    color = 'grey';
                } else if (segment.dir.includes('tratto stradale aperto nella direzione negativa')) {
                    type = 'negative';
                    color = 'blue';
                } else {
                    type = 'bidirectional';
                    color = 'red';
                }
        
                segment.line = L.polyline([
                    new L.LatLng(segment.nALat, segment.nALong),
                    new L.LatLng(segment.nBLat, segment.nBLong)
                ], {
                    color,
                    weight: 5,
                    opacity
                }).addTo(this.map);
        
                // arrow
                const patterns = [];
        
                if (type !== 'negative' && this.map.getZoom() > this.arrowMinZoom) {
                    patterns.push({
                        offset: '80%',
                        repeat: 0,
                        symbol: L.Symbol.arrowHead({
                            // pixelSize: 10,
                            pixelSize: this.tableMetersZoomArrow[this.zoomTableSize()],
                            polygon: true,
                            pathOptions: {
                                stroke: true,
                                fillColor: color,
                                fillOpacity: opacity,
                                opacity,
                                fill: true,
                                color
                            }
                        })
                    });
                }
                if ((type === 'negative' || type === 'bidirectional') && this.map.getZoom() > this.arrowMinZoom)
                    patterns.push(
                        {
                            offset: '20%',
                            repeat: 0,
                            symbol: L.Symbol.arrowHead({
                                pixelSize: this.tableMetersZoomArrow[this.zoomTableSize()],
                                // pixelSize: 10,
                                polygon: true,
                                headAngle: 420,
                                pathOptions: {
                                    stroke: true,
                                    fillColor: color,
                                    fillOpacity: opacity,
                                    opacity,
                                    fill: true,
                                    color
                                }
                            })
                        }
                    )
                var arrow = L.polylineDecorator(segment.line, { patterns }).addTo(this.map);
                arrow.on({
                    click: () => {
                        segment.line.fire('click');
                    },
                    mouseover: () => {
                        if (this.mode !== 'delete' && this.mode !== 'split')
                            return;
                        segment.line.setStyle({ color: 'green' });
                        segment.arrow.setStyle({
                            fillColor: 'green',
                            color: 'green'
                        });
                        segment.arrow.bringToFront();
                    },
                    mouseout: () => {
                        segment.line.setStyle({ color });
                        segment.arrow.setStyle({
                            fillColor: color,
                            color
                        });
                    }
                })
                segment.arrow = arrow;
        
                // hover effect 
                segment.line.on('mouseover', () => {
                    if (this.mode !== 'delete' && this.mode !== 'split')
                        return;
                    segment.line.setStyle({ color: 'green' });
                    segment.arrow.setStyle({
                        fillColor: 'green',
                        color: 'green'
                    });
                });
        
                // Change border color back to red on mouseout
                segment.line.on('mouseout', () => {
                    segment.line.setStyle({ color });
                    segment.arrow.setStyle({
                        fillColor: color,
                        color
                    });
                });
        
                segment.line.on({
                    click: () => {
                        if (this.mode === 'delete') {
                            this.removeSegment(segment);
                            this.updateHistoricAction();
                        } else if (this.mode === 'split') {
                            const lineLatLng = segment.line.getLatLngs();
                            const nodeLat = (lineLatLng[0].lat + lineLatLng[1].lat) / 2;
                            const nodeLng = (lineLatLng[0].lng + lineLatLng[1].lng) / 2;
                            const newNode = this.createBlankNode(nodeLat, nodeLng);
        
                            const segmentA = Object.assign({}, segment);
                            segmentA.segment += '_A';
                            const segmentB = Object.assign({}, segment);
                            segmentB.segment += '_B';
        
                            this.setNodeToSegment(segmentA, this.nodes[segment.nodeA], "A");
                            this.setNodeToSegment(segmentA, newNode, "B");
                            this.setNodeToSegment(segmentB, newNode, "A");
                            this.setNodeToSegment(segmentB, this.nodes[segment.nodeB], "B");
        
                            this.segments[segmentA.segment] = segmentA;
                            this.segments[segmentB.segment] = segmentB;
        
                            this.removeSegment(segment);
        
                            this.draw();
                            this.updateHistoricAction();
                        } else {
                            this.segmentClicked(segment);
                        }
                    }
                });
            }*/
        //END NEW SEGMENT


        setNodeToSegment(segment, node, position) {
            if (position === 'A') {
                segment.nALat = node.lat;
                segment.nALong = node.long;
                segment.nodeA = node.id;
                node.segments[segment.segment] = 'A';
            } else {
                segment.nBLat = node.lat;
                segment.nBLong = node.long;
                segment.nodeB = node.id;
                node.segments[segment.segment] = 'B';
            }
        }

        removeNode(node) {
            this.map.removeLayer(node.circle);
            delete this.nodes[node.id];
        }

        zoomTableSize() {
            if (parseInt(this.map.getZoom()) > 23)
                return 23;
            else if (parseInt(this.map.getZoom()) < 16)
                return 16;
            else
                return parseInt(this.map.getZoom());
        }

        drawNode(node) {
            if (node.circle)
                this.map.removeLayer(node.circle);

            var pixelBounds = this.map.getPixelBounds();
            var centerLat = this.map.getBounds().getCenter().lat;
            var meterX = this.haversine(centerLat, this.map.getBounds().getEast(), centerLat, this.map.getBounds().getWest());
            var metersPerPixelX = (pixelBounds.max.x - pixelBounds.min.x) / meterX;
            var pixelRadius = 7.5;
            var metersRadius = pixelRadius / metersPerPixelX;


            var segmentsList = this.segments;
            var currentType = false;
            var oacity = 0;
            var weight = 0;
            var filterTypes_array = [];
            filterTypes_array = this.filterTypes;
            //
            for (var element in node.segments) {
                if (element in segmentsList) {
                    var typeSegment = segmentsList[element].type;
                    var pos = filterTypes_array.indexOf(typeSegment);
                    if (pos > -1) {
                        currentType = true;
                    }
                }
            }
            //

            if (currentType == true && this.showAll) {
                oacity = 1;
                weight = 2;
            } else {
                oacity = 0;
                weight = 0;
            }
            node.circle = L.circle([node.lat, node.long], {
                color: 'red',
                weight: weight,
                fillColor: 'white',
                fillOpacity: oacity,
                radius: this.tableMetersZoomNode[this.zoomTableSize()],
                // radius: metersRadius,
            }).addTo(this.map);



            // hover effect 
            node.circle.on('mouseover', () => {
                if (this.mode !== 'create' && this.mode !== 'drag' && this.mode !== 'delete')
                    return;
                node.circle.setStyle({ color: 'green' });
            });

            // Change border color back to red on mouseout
            node.circle.on('mouseout', () => {
                node.circle.setStyle({ color: 'red' });
            });

            // dragging option
            let dragNode;
            node.circle.on({
                mouseup: () => {
                    if (this.mode !== 'drag' && this.mode !== 'create')
                        return;

                    this.creatingNode = false;
                    const bounds = node.circle.getBounds();
                    let nodeToAttach;
                    for (let secondNodeID in this.nodes) {
                        if (secondNodeID === node.id)
                            continue;
                        const secondNode = this.nodes[secondNodeID];
                        if (bounds.contains(new L.LatLng(secondNode.lat, secondNode.long))) {
                            nodeToAttach = secondNode;
                            break;
                        }
                    }
                    if (nodeToAttach) {
                        for (let segmentID in node.segments) {
                            if (nodeToAttach.segments[segmentID]) {
                                this.map.removeLayer(this.segments[segmentID].line);
                                this.map.removeLayer(this.segments[segmentID].arrow);
                                delete nodeToAttach.segments[segmentID];
                                delete this.segments[segmentID];
                                continue;
                            }
                            const segment = this.segments[segmentID];
                            this.setNodeToSegment(segment, nodeToAttach, node.segments[segmentID]);
                            this.drawSegment(segment);
                        }
                        this.map.removeLayer(node.circle);
                        delete this.nodes[node.id];
                        this.drawAllNodes();
                    }

                    this.updateHistoricAction();
                },
                click: () => {
                    if (this.mode !== 'delete')
                        return;
                    let segmentsID = Object.keys(node.segments);
                    if (segmentsID.length > 2) {
                        alert('cannot remove a node that it\'s linked than 3 or more segments');
                        return;
                    }
                    else if (segmentsID.length == 2) {
                        // A   B   C
                        // o---o---o
                        //   0   1
                        const segment0 = this.segments[segmentsID[0]];
                        const segment1 = this.segments[segmentsID[1]];
                        const nodePosition0 = node.segments[segmentsID[0]];
                        const nodePosition1 = node.segments[segmentsID[1]];
                        const nodeToAttachID = nodePosition1 === 'A' ? segment1.nodeB : segment1.nodeA;
                        const nodeToAttach = this.nodes[nodeToAttachID];

                        this.setNodeToSegment(segment0, nodeToAttach, nodePosition0);
                        this.removeSegment(segment1);
                        this.removeNode(node);
                        this.draw();
                    } else {
                        if (segmentsID.length == 1)
                            this.removeSegment(this.segments[segmentsID[0]]);
                        this.removeNode(node);
                    }
                    this.updateHistoricAction();
                },
                mousedown: () => {
                    console.log("mousedown - mode = " + this.mode);
                    if (this.mode !== 'drag' && this.mode !== 'create')
                        return;

                    console.log('node down');
                    
                    this.creatingNode = true;
                    this.map.dragging.disable();
                    let itsNewNode = false;
                    if (this.mode === 'create') {
                        itsNewNode = true;
                        const newNode = this.createBlankNode(node.lat, node.long);
                        this.createLinkNodes(node, newNode);
                        this.draw();
                        node = newNode;
                        this.updateHistoricAction();
                    }
                    this.map.on('mousemove', dragNode = (e) => {
                        // updating node
                        const { lat, lng } = e.latlng;
                        node.circle.setLatLng(e.latlng);
                        node.lat = lat;
                        node.long = lng;

                        // updating attached segments
                        for (let segmentID in node.segments) {
                            const segment = this.segments[segmentID];
                            if (node.segments[segmentID] === 'A') {
                                segment.nALat = lat;
                                segment.nALong = lng;
                            } else {
                                segment.nBLat = lat;
                                segment.nBLong = lng;
                            }
                            segment.line.setLatLngs([
                                new L.LatLng(segment.nALat, segment.nALong),
                                new L.LatLng(segment.nBLat, segment.nBLong)
                            ]);
                            segment.length = this.haversine(segment.nALat, segment.nALong, segment.nBLat, segment.nBLong);
                            segment.arrow.setPaths(segment.line.getLatLngs());
                            //
                            let sensoreTrovato = this.sensorsList.find(sensore => sensore.sensorUri === segmentID);
                                    if (sensoreTrovato) {
                                                    //console.log('Sensore trovato:', sensoreTrovato);
                                                        sensoreTrovato.moveSensor(segment.line.getLatLngs());
                                    }
                                    //
                            //
                        }
                        node.circle.bringToFront();

                        // checking if its over another node
                        const bounds = node.circle.getBounds();
                        let nodeFound = false;
                        for (let secondNodeID in this.nodes) {
                            if (secondNodeID === node.id)
                                continue;
                            const secondNode = this.nodes[secondNodeID];
                            if (bounds.contains(new L.LatLng(secondNode.lat, secondNode.long))) {
                                node.circle.setStyle({ color: 'purple', fillColor: '#66FF66'});
                                secondNode.circle.setStyle({ color: 'purple', fillColor: '#66FF66'});
                                node.lastNodeFound = secondNode;
                                nodeFound = true;
                                break;
                            }
                        }
                        if (!nodeFound && node.lastNodeFound) {
                            node.circle.setStyle({ color: 'green', fillColor: 'white' });
                            node.lastNodeFound.circle.setStyle({ color: 'red', fillColor: 'white' });
                            delete node.lastNodeFound;
                        }
                    });                  
                }
            });
            this.map.on('mouseup', (e) => {
                if (!dragNode)
                    return
                this.map.dragging.enable();
                this.map.removeEventListener('mousemove', dragNode);
                dragNode = undefined;
            });
        }

        drawAllNodes() {
            for (let nodeID in this.nodes) {
                this.drawNode(this.nodes[nodeID]);
            }
        }

        draw() {
            this.clearSegments();
            this.clearNodes();
            var visibleNodeIdxs = [];
            var mapZoom = this.map.getZoom();
            for (let segmentID in this.segments) {
                if (this.isSegmentInsideMap(this.segments[segmentID])){
                    if( 
                        mapZoom >= this.typeMinZoom || 
                        !(this.typeMinZoomFilter.includes(this.segments[segmentID].type))
                    ){
                        const segment = this.segments[segmentID];
                        visibleNodeIdxs.push(this.segments[segmentID].nodeA);
                        visibleNodeIdxs.push(this.segments[segmentID].nodeB);
                        this.drawSegment(segment);
                    }
                }
            }
            visibleNodeIdxs = [...new Set(visibleNodeIdxs)];
            if( mapZoom >= this.nodeMinZoom){
                for (let nodeIDX in visibleNodeIdxs){ //this.nodes) {
                    const node = this.nodes[visibleNodeIdxs[nodeIDX]];
                    this.drawNode(node);
                }
            }
        }

        isSegmentInsideMap(segment) {
            const pointA = {
                lat: segment.nALat,
                lng: segment.nALong
            };
            const pointB = {
                lat: segment.nBLat,
                lng: segment.nBLong
            }
            // Get the current bounds of the map
            var bounds = this.map.getBounds();
            
            // Check if either of the points is inside the map bounds
            var isPointAInside = bounds.contains(L.latLng(pointA.lat, pointA.lng));
            var isPointBInside = bounds.contains(L.latLng(pointB.lat, pointB.lng));
            
            // Return true if at least one point is inside
            return isPointAInside || isPointBInside;
        }

    }

    //////////////FINE Adrean Nuova Classe
    //Ogni "main" lato client di un widget è semple incluso nel risponditore ad evento ready del documento, così siamo sicuri di operare sulla pagina già caricata
    $(document).ready(function <?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>(firstLoad, metricNameFromDriver, widgetTitleFromDriver, widgetHeaderColorFromDriver, widgetHeaderFontColorFromDriver, fromGisExternalContent, fromGisExternalContentServiceUri, fromGisExternalContentField, fromGisExternalContentRange, /*randomSingleGeoJsonIndex,*/ fromGisMarker, fromGisMapRef, fromGisFakeId) {

        if (localStorage.getItem("widgets") == null) {
            var widgets = [];
            widgets.push(widgetName);
            localStorage.setItem("widgets", JSON.stringify(widgets));
        }
        else {
            var widgets = JSON.parse(localStorage.getItem("widgets"));
            if (!widgets.includes(widgetName)) {
                widgets.push(widgetName);
                localStorage.setItem("widgets", JSON.stringify(widgets));
            }
        }
        $(document).on('resetContent_' + widgetName, function () {
            $.ajax({
                url: "../controllers/getWidgetParams.php",
                type: "GET",
                data: {
                    widgetName: "<?= $_REQUEST['name_w'] ?>"
                },
                async: true,
                dataType: 'json',
                success: function (widgetData) {
                    rowParameters = JSON.parse(widgetData.params.rowParameters);
                    populateWidget();
                },
                error: function (errorData) {
                    console.log("Error in widget params retrieval");
                    console.log(JSON.stringify(errorData));
                    showWidgetContent(widgetName);
                    $("#<?= $_REQUEST['name_w'] ?>_chartContainer").hide();
                    $("#<?= $_REQUEST['name_w'] ?>_table").hide();
                    $('#<?= $_REQUEST['name_w'] ?>_noDataAlert').show();
                }
            });
        });
        <?php
        $titlePatterns = array();
        $titlePatterns[0] = '/_/';
        $titlePatterns[1] = '/\'/';
        $replacements = array();
        $replacements[0] = ' ';
        $replacements[1] = '&apos;';
        $title = $_REQUEST['title_w'];
        $link = mysqli_connect($host, $username, $password);
        if ($_REQUEST['name_w'] !== 'preview') {
            if (checkWidgetNameInDashboard($link, $_REQUEST['name_w'], $_REQUEST['id_dashboard']) === false) {
                eventLog("Returned the following ERROR in widgetMap.php for the widget " . escapeForHTML($_REQUEST['name_w']) . " is not instantiated or allowed in this dashboard.");
                exit();
            }
        }


        $genFileContent = parse_ini_file("../conf/environment.ini");
        $wsServerContent = parse_ini_file("../conf/webSocketServer.ini");
        $env = $genFileContent['environment']['value'];
        $wsServerAddress = $wsServerContent["wsServerAddressWidgets"][$env];
        $wsServerPort = $wsServerContent["wsServerPort"][$env];
        $wsPath = $wsServerContent["wsServerPath"][$env];
        $wsProtocol = $wsServerContent["wsServerProtocol"][$env];
        $wsRetryActive = $wsServerContent["wsServerRetryActive"][$env];
        $wsRetryTime = $wsServerContent["wsServerRetryTime"][$env];
        $useActuatorWS = $wsServerContent["wsServerActuator"][$env];
        ?>

        var headerHeight = 25;
        var hostFile = "<?= escapeForJS($_REQUEST['hostFile']) ?>";
        var widgetName = "<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>";
        var mapOptionsDivName = widgetName + "_mapOptions";
        var widgetContentColor = "<?= escapeForJS($_REQUEST['color_w']) ?>";
        var fontSize = "<?= escapeForJS($_REQUEST['fontSize']) ?>";
        var fontColor = "<?= escapeForJS($_REQUEST['fontColor']) ?>";
        var embedWidget = <?= $_REQUEST['embedWidget'] == 'true' ? 'true' : 'false' ?>;
        var embedWidgetPolicy = '<?= escapeForJS($_REQUEST['embedWidgetPolicy']) ?>';
        var showTitle = "<?= escapeForJS($_REQUEST['showTitle']) ?>";
        var showHeader = null;
        var hasTimer = "<?= escapeForJS($_REQUEST['hasTimer']) ?>";
        var styleParameters, metricName, udm, udmPos, appId, flowId, nodeId, nrMetricType,
            sm_field, sizeRowsWidget, sm_based, rowParameters, fontSize, countdownRef, widgetTitle, widgetHeaderColor,
            widgetHeaderFontColor, showHeader, widgetParameters, chartColor, dataLabelsFontSize, dataLabelsFontColor,
            chartLabelsFontSize, chartLabelsFontColor, titleWidth, enableFullscreenModal,
            enableFullscreenTab, shownPolyGroup, geoServerUrl, heatmapUrl, odOnMap, sourcePolygon, geojson_layer, geojson_layer_all = null;
        var eventsOnMap = [];
        var addMode = null;
        heatmapMetricName = "";
        heatmapRange = [];
        prevZoom = null;

        //Variabili per il selector
        var gisLayersOnMap = {};
        var gisGeometryLayersOnMap = {};
        var stopGeometryAjax = {};
        var gisGeometryTankForFullscreen = {};
        var checkTankInterval = null;
        var markersCache = {};
        var myPOIId, myPOIlat, myPOIlng = "";                   // MyPOI Mod

        //Variabili multi-mappa
        var map = {};
        var baseQuery = null;
        /*   current_radius = null;
           current_opacity = null;
           changeRadiusOnZoom = false;
           estimatedRadius = null;
           estimateRadiusFlag = false;
           fullscreenHeatmap = null;
           fullscreenHeatmapFirstInstantiation = false;
           fullscreenHeatmapFirstInst = true;
           heatmapLegendColorsFullscreen = null;
           legendHeatmapFullscreen = null;
           mapName = null;
           mapDate = null;
           resetPageFlag = null;
           wmsDatasetName = null;
           passedParams = null;    */
        

        var current_radius = null;
        var current_opacity, current_opacity_od, current_opacity_PS = null;
        var current_traffic_opacity = null;
        var changeRadiusOnZoom = false;
        var estimatedRadius = null;
        var estimateRadiusFlag = false;
        var fullscreenHeatmap = null;
        var fullscreenHeatmapFirstInstantiation = false;
        var fullscreenHeatmapFirstInst = true;
        var heatmapLegendColorsFullscreen = null;
        var legendHeatmapFullscreen = null;
        var mapName = null;
        var trafficMapName = null;
        var mapDate = null;
        var trafficMapDate = null;
        var resetPageFlag = null;
        var wmsDatasetName = null;
        var passedParams = null;
        var animationFlag = false;
        var showAllPolygonFlag = false;
        var animationFlagTraffic = false;
        var trafficData = null;

        var dataForApi = "";

        var daysArray = [];
        var userTimeOffset = new Date().getTimezoneOffset();
        var snap4CityServerTime = new Date().toLocaleString("it-IT", { timeZone: "Europe/Rome" });
        var usaTime = new Date(usaTime);
        var snap4CityServerTimeOffset = "";
        var countSvgCnt = 0;
        var totalSvgCnt = 0;
        var currentCustomSvgLayer = null;
        var svgContainerArray = [];
        var oms = {}    // OverlappingMarkerSpiderfier for Leaflet

        //Definizioni di funzione

        console.log("entrato in widgetMap. WidgetName = " + widgetName);

        /*  current_page = 0;
          records_per_page = 1;
          wmsLayer = null;
          wmsLayerFullscreen = null;*/

        var current_page = 0;
        var current_page_traffic = 0;
        var records_per_page = 1;
        var wmsLayer = null;
        var trafficWmsLayer = null;
        var newTfrLayer = null;
        var wmsLayerFullscreen = null;
        var iconsFileBuffer = [];
        var bubbleSelectedMetric = [];
        var bubbles = [];
        var defaultOrthomapMenuItem = null;
        if (Window.webSockets == undefined)
            Window.webSockets = {};
        var nodeRedInputName, nrInputId, currentValue, lastValueOk = null;
        var heatmapClick = null;
        var odmapClick = null;
        var nodeRedClick = null;
        var getCoordsClick = null;
        var newOdTargetData = null;
        var newOdSourceData = null;
        var showAllPolyOdMapZoomend = null;
        var showAllPolyOdMapMoveend = null;

        var newOdDateTimeFunc = null;

        var iconTextMod = "null";
        var keycloak, socket = null;
        var subscribeFlag, tryingAuth, srvFailure = false;
        var payload = [];
        var subscribedWsDevices = [];
        var wsConnect = null;
        var heatmapData = null;
        var agencyIcons = {};
        var spiderMarkers = {};
        var altViewMode = null;
        var orgParams = null;
        var serviceUrl = null;
        var code, connections = null;
        var selectedData = {};
        var getSmartCityAPIData = null;
        var getShapeSmartCityAPIData = null;
        var geoJsonLayerShape, bimShapeOnMap, descBim = null;

        var spinIcon = (window.location.href.includes("view/index.php") || window.location.href.includes("management/dashboard_configdash.php")) ? 'fa fa-circle-o-notch fa-spin' : 'fa-solid fa-circle-notch fa-spin';

        var selectedMetrics = null;
        var tooltipOnHover = false;
        var popupOnClick = true;
        var leafletMaxZoom = 23;
        var leafletNativeMaxZoom = 19;
        var widgetParams = null;
        
        function removeBimShapeColorLegend(index, resetPageFlag) {
            map.defaultMapRef.removeControl(map.eventsOnMap[index].legendColors);
            map.defaultMapRef.removeLayer(geoJsonLayerShape);
        }

        function checkFloorNumber(floorNumber, identifierName) {
            if (identifierName == "M1" && floorNumber == -1) {
                return true;
            } else if (identifierName == "PT" && floorNumber == 0) {
                return true;
            } else if (identifierName == "P1" && floorNumber == 1) {
                return true;
            } else if (identifierName == "P2" && floorNumber == 2) {
                return true;
            } else if (identifierName == "P3" && floorNumber == 3) {
                return true;
            } else {
                return false;
            }
        }

        function getColorForDensity(density, lanes) {

            if(lanes == null) {
                lanes = 1;
            }
            
            var thresholds = {
                2: { green: 0.6, yellow: 1.2, orange: 1.8 },
                3: { green: 0.9, yellow: 1.5, orange: 2 },
                4: { green: 1.2, yellow: 1.6, orange: 2 },
                5: { green: 1.6, yellow: 2, orange: 2.4 },
                6: { green: 2, yellow: 2.4, orange: 2.8 }
            };

            var defaultThresholds = { green: 0.3, yellow: 0.6, orange: 0.9 };
            var FIPILIThresholds = { green: 0.25, yellow: 0.5, orange: 0.75 };

            var green, yellow, orange;

            var seg = typeof seg !== 'undefined' ? seg : {};

            if (seg != null && seg.FIPILI == 1) {
                ({ green, yellow, orange } = FIPILIThresholds);
            } else if (thresholds[lanes]) {
                ({ green, yellow, orange } = thresholds[lanes]);
            } else {
                ({ green, yellow, orange } = defaultThresholds);
            }

            if (density <= green) {
                return "#00FF00";
            } else if (density <= yellow) {
                return "#FFFF00";
            } else if (density <= orange) {
                return "#FF8C00";
            } else {
                return "#FF0000";
            }
        }

        function getDensityDataByRoadElement(data, roadElement) {

            function isoToUnixTimestamp(dateStr) {
                let date = new Date(dateStr);
                return date.getTime();
            }

            let result = [];

            data.forEach(item => {
                if (item.roadElements === roadElement) {
                    result.push([isoToUnixTimestamp(item.dateObserved), item.density]);
                }
            });

            result.sort((a, b) => b[0] - a[0]);

            return result;
        }
        
        function populateTfrPopup(jsonData, road, event) {

            var densityData = getDensityDataByRoadElement(jsonData, road.roadElements);
            var serviceProperties = {};
            serviceProperties.scenario = jsonData[0].scenario;
            serviceProperties.roadElements = jsonData[0].roadElements;
            serviceProperties.kind = jsonData[0].kind;
            // serviceProperties.name = jsonData[0].roadElements;
            serviceProperties.name = jsonData[0].roadElements.replace(/\//g, '-');
            // serviceProperties.name = jsonData[0].roadElements.replace(/\//g, '\\/');

            if (widgetParameters.mode && widgetParameters.mode == "ckeditor" && code) {
                let i = 1;
                if (localStorage.getItem("events") == null) {

                    var events = [];
                    events.push("MapMarkerClick1");
                    localStorage.setItem("events", JSON.stringify(events));
                }
                else {
                    var events = JSON.parse(localStorage.getItem("events"));
                    for (var e in events) {
                        if (events[e].slice(0, 9) == "MapMarker")
                            i = i + 1;
                    }
                    events.push("MapMarkerClick" + i);
                    localStorage.setItem("events", JSON.stringify(events));
                }
                let newId = "MapMarkerClick" + i;
                $('#BIMenuCnt').append('<div id="' + newId + '" class="row" data-selected="false"></div>');
                $('#' + newId).append('<div class="col-md-12 orgMenuSubItemCnt">' + newId + '</div>');
                $('#' + newId).on("click", function () {
                    var widgets = JSON.parse(localStorage.getItem("widgets"));
                    var index = JSON.parse(localStorage.getItem("events")).indexOf(newId);
                    for (var w in widgets) {
                        if (widgets[w] != null) {
                            $('body').trigger({
                                type: "reloadPreviousContent_" + widgets[w],
                                index: index
                            });
                        }
                    }
                });
                $('#' + newId).mouseover(function () {
                    $('#' + newId).css('cursor', 'pointer');
                });

                var selectedData = {};
                selectedData.event = "click";
                selectedData.layers = [];
                selectedData.layers[0] = serviceProperties;
                if (connections != null) {
                    selectedData.connections = connections;
                }
                var selectedDataJson = JSON.stringify(selectedData);

                try {
                    execute_<?= $_REQUEST['name_w'] ?>(selectedDataJson);
                } catch (e) {
                    console.log("Error in JS function from marker click on " + widgetName);
                }
            }

            event.target.unbindPopup();
            var newpopup = null;
            var popupText, realTimeData, measuredTime, rtDataAgeSec, targetWidgets, color1, color2 = null;
            var urlToCall, fake, fakeId = null;

            targetWidgets = passedParams.targets;
            color1 = passedParams.color1;
            color2 = passedParams.color2;

            //Popup nuovo stile uguali a quelli degli eventi ricreativi
            popupText = '<h3 class="recreativeEventMapTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + serviceProperties.name + '</h3>';

            let actionUrlFlag = false;
            let actionUrlText = "";

            popupText += '<div class="recreativeEventMapBtnContainer"><button data-id="' + serviceProperties.name + '" class="recreativeEventMapDetailsBtn recreativeEventMapBtn recreativeEventMapBtnActive" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Details</button><button data-id="' + serviceProperties.name + '" class="recreativeEventMapDescriptionBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Description</button><button data-id="' + serviceProperties.name + '" class="recreativeEventMapContactsBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">RT data</button>' + actionUrlText + '</div>';
            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDetailsContainer">';

            popupText += '<table id="' + serviceProperties.name + '" class="gisPopupGeneralDataTable">';
            //Intestazione
            popupText += '<thead>';
            popupText += '<th style="background: ' + color2 + '">Description</th>';
            popupText += '<th style="background: ' + color2 + '">Value</th>';
            popupText += '</thead>';

            //Corpo
            popupText += '<tbody>';

            for (var featureKey in serviceProperties) {
                if (serviceProperties.hasOwnProperty(featureKey)) {
                    if (featureKey != 'name') {
                        if (serviceProperties[featureKey] != null && serviceProperties[featureKey] !== '' && serviceProperties[featureKey] !== ' ' && featureKey !== 'targetWidgets' && featureKey !== 'color1' && featureKey !== 'color2' && featureKey !== 'realtimeAttributes') {
                            if (!Array.isArray(serviceProperties[featureKey]) || (Array.isArray(serviceProperties[featureKey] && serviceProperties[featureKey].length > 0))) {
                                popupText += '<tr><td>' + featureKey + '</td><td>' + serviceProperties[featureKey] + '</td></tr>';
                            }
                        }
                    }
                }
            }
            if (nodeId != null && serviceProperties["serviceUri"] != null && serviceProperties["serviceUri"] != '') {
                let eventJson = new Object();
                eventJson.latitude = feature.geometry.coordinates[1];
                eventJson.longitude = feature.geometry.coordinates[0];
                eventJson.serviceUri = serviceProperties["serviceUri"];
                currentValue = JSON.stringify(eventJson);
                triggerEventOnIotApp(map.defaultMapRef, currentValue);
            }

            popupText += '</tbody>';
            popupText += '</table>';

            popupText += '</div>';

            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDescContainer">';

            if ((serviceProperties.roadElements !== '') && (serviceProperties.roadElements !== undefined) && (serviceProperties.roadElements !== 'undefined') && (serviceProperties.roadElements !== null) && (serviceProperties.roadElements !== 'null')) {
                popupText += "Road Element Id: " + serviceProperties.roadElements + "<br>";
            }

            if ((serviceProperties.scenario !== '') && (serviceProperties.scenario !== undefined) && (serviceProperties.scenario !== 'undefined') && (serviceProperties.scenario !== null) && (serviceProperties.scenario !== 'null')) {
                popupText += "Scenario: " + serviceProperties.scenario + "<br>";
            }

            popupText += '</div>';

            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapContactsContainer">';

            var hasRealTime = false;

            realTimeData = densityData;
            popupText += '<div class="popupLastUpdateContainer centerWithFlex"><b>Last update:&nbsp;</b><span class="popupLastUpdate" data-id="' + serviceProperties.roadElements + '"></span></div>';

            //Tabella nuovo stile
            popupText += '<table id="' + serviceProperties.name + '" class="gisPopupTable">';

            //Intestazione
            popupText += '<thead>';
            popupText += '<th style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Description</th>';
            popupText += '<th style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Value</th>';
            popupText += '<th colspan="9" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Buttons</th>';
            popupText += '</thead>';

            //Corpo
            popupText += '<tbody>';
            var dataDesc, dataVal, dataLastBtn, data4HBtn, dataDayBtn, data7DayBtn,
                data30DayBtn, data6MonthsBtn, data1YearBtn, data2YearBtn, data10YearBtn,
                value_unit = null;
            if (realTimeData != null) {
                //for (var i = 0; i < realTimeData.length; i++) {
                    //if (realTimeData[0] !== null) {
                        dataDesc = "Density";
                        // dataVal = realTimeData[realTimeData.length - 1][1];
                        dataVal = realTimeData[0][1];
                        dataVal = parseFloat(dataVal.toFixed(2));
                        dataLastBtn = '<td><button style="width: 30px" data-id="' + serviceProperties.name + '" type="button" class="lastValueBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-field="density" data-lastDataClicked="false" data-targetWidgets="' + targetWidgets + '" data-lastValue="' + realTimeData[0][1] + '" data-color1="' + color1 + '" data-color2="' + color2 + '" data-value_unit="' + value_unit + '">Last</button></td>';
                        data4HBtn = '<td><button style="width: 30px" data-id="' + serviceProperties.name + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-field="density" data-timeTrendClicked="false" data-range-shown="4 Hours" data-range="4/HOUR" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">4h</button></td>';
                        dataDayBtn = '<td><button style="width: 30px" data-id="' + serviceProperties.name + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="density"' + '" data-timeTrendClicked="false" data-range-shown="Day" data-range="1/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">24h</button></td>';
                        data7DayBtn = '<td><button style="width: 30px" data-id="' + serviceProperties.name + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="density"' + '" data-timeTrendClicked="false" data-range-shown="7 days" data-range="7/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">7d</button></td>';
                        data30DayBtn = '<td><button style="width: 30px" data-id="' + serviceProperties.name + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="density"' + '" data-timeTrendClicked="false" data-range-shown="30 days" data-range="30/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">30d</button></td>';
                        data6MonthsBtn = '<td><button style="width: 30px" data-id="' + serviceProperties.name + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="density"' + '" data-timeTrendClicked="false" data-range-shown="6 months" data-range="180/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">6m</button></td>';
                        data1YearBtn = '<td><button style="width: 30px" data-id="' + serviceProperties.name + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="density"' + '" data-timeTrendClicked="false" data-range-shown="1 year" data-range="365/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">1y</button></td>';
                        data2YearBtn = '<td><button style="width: 30px" data-id="' + serviceProperties.name + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="density"' + '" data-timeTrendClicked="false" data-range-shown="2 year" data-range="730/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">2y</button></td>';
                        data10YearBtn = '<td><button style="width: 30px" data-id="' + serviceProperties.name + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="density"' + '" data-timeTrendClicked="false" data-range-shown="10 year" data-range="3650/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">10y</button></td>';
                        popupText += '<tr><td>' + dataDesc + '</td><td>' + dataVal + '</td>' + dataLastBtn + data4HBtn + dataDayBtn + data7DayBtn + data30DayBtn + data6MonthsBtn + data1YearBtn + data2YearBtn + data10YearBtn + '</tr>';
                        measuredTime = road.dateObserved.replace("T", " ");
                        var now = new Date();
                        var measuredTimeDate = new Date(measuredTime);
                        rtDataAgeSec = Math.abs(now - measuredTimeDate) / 1000;
                    //}
                //}
            }
            popupText += '</tbody>';
            popupText += '</table>';
            popupText += '<p><b>Keep data on target widget(s) after popup close: </b><input data-id="' + serviceProperties.name + '" type="checkbox" class="gisPopupKeepDataCheck" data-keepData="false"/></p>';


            hasRealTime = true;


            popupText += '</div>';

            newpopup = L.popup({
                closeOnClick: false,//Non lo levare, sennò autoclose:false non funziona
                autoClose: false,
                offset: [15, 0],
                //minWidth: 435,
                minWidth: 400,
                maxWidth: 1200,
                //	className: geoJsonServiceData.hasOwnProperty("BusStop")?"draggableAndResizablePopup":"nonDraggableAndResizablePopup"
                className: "draggableAndResizablePopup"
            }).setContent(popupText);

            event.target.bindPopup(newpopup).openPopup();
            event.target.unbindPopup();

            // draggable
            var makeDraggable = function (popup, excluding) {
                popupResizeObserver.observe(popup._wrapper)
                var pos = map.defaultMapRef.latLngToLayerPoint(popup.getLatLng());
                L.DomUtil.setPosition(popup._wrapper.parentNode, pos);
                console.log("POPUP", popup._wrapper, $(popup._wrapper).children(".leaflet-popup-content"))
                var draggable = new L.Draggable(popup._container, popup._wrapper);
                var popup_content = $(popup._wrapper).children(".leaflet-popup-content")[0]
                popup._wrapper._draggable = draggable
                $(popup_content).css("width", "")
                draggable.enable();
                $(".draggableAndResizablePopup").css("cursor", "move");
                draggable.on('dragend', function () {
                    var pos = map.defaultMapRef.layerPointToLatLng(this._newPos);
                    popup.setLatLng(pos);
                    $(popup._wrapper).siblings(".leaflet-popup-tip-container").hide();
                });
                excluding.forEach((excluded) => {
                    $(excluded).css("cursor", "auto").on("mouseover", function (e) {
                        draggable.disable();
                    }).on("mouseout", function (e) {
                        draggable.enable();
                    });
                });
            };
            //	if(newpopup.options.className == "draggableAndResizablePopup") makeDraggable(newpopup, [".draggableAndResizablePopup table.gisPopupGeneralDataTable"]);
            if (newpopup.options.className == "draggableAndResizablePopup") makeDraggable(newpopup, [".draggableAndResizablePopup .recreativeEventMapDataContainer"]);


            //

            // resizable
            $(".draggableAndResizablePopup .leaflet-popup-content-wrapper").css({
                "resize": "both",
                "overflow": "auto",
                "min-width": "400px",
                "max-width": "1200px",
                "min-height": "100px",
                "max-height": "400px"
            });
            //

            // responsive
            $(".draggableAndResizablePopup .recreativeEventMapDataContainer").css({
                "width": "100%",
                "height": "100%"
            });
            //

            if (hasRealTime) {
                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + serviceProperties.name + '"]').show();
                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + serviceProperties.name + '"]').trigger("click");
                $('#<?= $_REQUEST['name_w'] ?>_map span.popupLastUpdate[data-id="' + serviceProperties.name + '"]').html(measuredTime);
            } else {
                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + serviceProperties.name + '"]').hide();
            }

            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDetailsBtn[data-id="' + serviceProperties.name + '"]').off('click');
            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDetailsBtn[data-id="' + serviceProperties.name + '"]').click(function () {
                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                $(this).parent().siblings('div.recreativeEventMapDetailsContainer').show();
                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                $(this).addClass('recreativeEventMapBtnActive');
            });

            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDescriptionBtn[data-id="' + serviceProperties.name + '"]').off('click');
            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDescriptionBtn[data-id="' + serviceProperties.name + '"]').click(function () {
                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                $(this).parent().siblings('div.recreativeEventMapDescContainer').show();
                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                $(this).addClass('recreativeEventMapBtnActive');
            });

            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + serviceProperties.name + '"]').off('click');
            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + serviceProperties.name + '"]').click(function () {
                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                $(this).parent().siblings('div.recreativeEventMapContactsContainer').show();
                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                $(this).addClass('recreativeEventMapBtnActive');
            });

            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + serviceProperties.name + '"]').off('click');
            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + serviceProperties.name + '"]').click(function () {
                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                $(this).parent().siblings('div.recreativeEventMapTplContainer').show();
                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                $(this).addClass('recreativeEventMapBtnActive');
                if ($("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToTrips button").is(":visible")) {
                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToTrips button").click();
                }
                if ($("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToRoutes button").is(":visible")) {
                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToRoutes button").click();
                }
            });

            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplTmtblBtn[data-id="' + serviceProperties.name + '"]').off('click');
            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplTmtblBtn[data-id="' + serviceProperties.name + '"]').click(function () {
                //console.log("clicked "+'#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplTmtblBtn[data-id="' + serviceProperties.name + '"]');
                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                $(this).parent().siblings('div.recreativeEventMapTplTmtblContainer').show();
                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                $(this).addClass('recreativeEventMapBtnActive');
                var tmtblBtn = $(this);
                var tmtblMarkup = "";
                $.getJSON('<?= $whatifmdtendpt ?>?stop=' + encodeURIComponent(serviceProperties['serviceUri']) + "&list=graphs", function (graphs) {
                    var pAgency = graphs.join();
                    $.getJSON('<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&stop=' + encodeURIComponent(serviceProperties['serviceUri']) + "&list=timetable", function (timetable) {
                        //console.log(timetable);
                        timetable.forEach(function (entry, rownum) {
                            //console.log(entry);
                            tmtblMarkup += "<p class=\"tplpoi_tmtblrow\"><button data-r=\"" + entry["route"].replace(/[^a-zA-Z0-9]/g, "") + "\" data-t=\"" + entry["trip"] + "\" data-n=\"" + rownum + "\" style=\"width:100%; background-color:#" + entry["bgcolor"] + "; color:#" + entry["fgcolor"] + "\"><p style=\"font-size:larger; font-weight:bold; margin:0px; padding:0px; text-align:left;\">" + (entry["departure"] ? entry["departure"] : entry["arrival"]).substring(0, 5) + "&nbsp;<span style=\"font-size:larger; border:thin solid #" + entry["fgcolor"] + ";\">" + entry["number"] + "</span>&nbsp;" + entry["headsign"] + "</p><p class=\"nextstops\" style=\"margin:0px; padding:0px; font-weight:normal; text-align:left;\"></p></button></p>";
                        });
                        if (timetable.length == 0) {
                            tmtblMarkup += "<p class=\"tplpoi_tmtblrow\">The timetable is currently not available for this stop.</p>";
                        }
                        tmtblBtn.parent().siblings('div.recreativeEventMapTplTmtblContainer').empty();
                        tmtblBtn.parent().siblings('div.recreativeEventMapTplTmtblContainer').append($(tmtblMarkup));
                        timetable.forEach(function (entry, rownum) {
                            var theTripUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&trip=' + encodeURIComponent(entry["trip_uri"]) + "&list=stops";
                            var n = rownum;
                            $.getJSON(theTripUrl, function (alltripstops) {
                                //console.log(alltripstops);
                                var span = $("p.tplpoi_tmtblrow button[data-t=\"" + entry["trip"] + "\"][data-n=\"" + n + "\"] p.nextstops");
                                var spanMarkup = "";
                                var isNext = false;
                                alltripstops.forEach(function (stop) {
                                    if (isNext) {
                                        if (-1 == spanMarkup.indexOf(stop["arrival"].substring(0, 5) + "&nbsp;" + stop["name"].replaceAll(" ", "&nbsp;") + "&nbsp;&bull; ")) {
                                            spanMarkup += stop["arrival"].substring(0, 5) + "&nbsp;" + stop["name"].replaceAll(" ", "&nbsp;") + "&nbsp;&bull; ";
                                        }
                                    }
                                    if (stop["stop_uri"] == serviceProperties['serviceUri']) {
                                        isNext = true;
                                    }
                                });
                                if (!spanMarkup) {
                                    spanMarkup += "This is the terminus stop, the trip does not continue further.&nbsp;&bull; ";
                                }
                                // console.log("Appending "+spanMarkup.substring(0,spanMarkup.length-13));
                                span.append(spanMarkup.substring(0, spanMarkup.length - 13));
                            });
                        });
                        $(".tplpoi_tmtblrow button").click(function () {
                            //console.log($(this).data("r")); console.log($(this).data("t"));
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + serviceProperties.name + '"]').click();
                            var t = $(this).data("t");
                            var observer = new MutationObserver(function (mutations, observer) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + serviceProperties.name + '"]').parent().siblings('div.recreativeEventMapTplContainer').find('.tplpoi_tripsDivInRoute .tplpoi_wifstptrp button[data-tripkey="' + t + '"]').click();
                                observer.disconnect();
                            });
                            observer.observe($('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + serviceProperties.name + '"]').parent().siblings('div.recreativeEventMapTplContainer')[0], {childList: true});
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + serviceProperties.name + '"]').parent().siblings('div.recreativeEventMapTplContainer').find("button.polyin_" + $(this).data("r")).click();
                        });
                    });
                });
            });

            if (hasRealTime) {
                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + serviceProperties.name + '"]').trigger("click");
            }

            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + serviceProperties.name + '"] button.btn-sm').css("background", color2);
            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + serviceProperties.name + '"] button.btn-sm').css("border", "none");
            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + serviceProperties.name + '"] button.btn-sm').css("color", "black");

            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + serviceProperties.name + '"] button.btn-sm').focus(function () {
                $(this).css("outline", "0");
            });

            $('#<?= $_REQUEST['name_w'] ?>_map input.gisPopupKeepDataCheck[data-id="' + serviceProperties.name + '"]').off('click');
            $('#<?= $_REQUEST['name_w'] ?>_map input.gisPopupKeepDataCheck[data-id="' + serviceProperties.name + '"]').click(function () {
                if ($(this).attr("data-keepData") === "false") {
                    $(this).attr("data-keepData", "true");
                } else {
                    $(this).attr("data-keepData", "false");
                }
            });

            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').off('mouseenter');
            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').off('mouseleave');
            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-id="' + serviceProperties.name + '"]').hover(function () {
                    if ($(this).attr("data-lastDataClicked") === "false") {
                        $(this).css("background", color1);
                        $(this).css("background", "-webkit-linear-gradient(left, " + color1 + ", " + color2 + ")");
                        $(this).css("background", "background: -o-linear-gradient(left, " + color1 + ", " + color2 + ")");
                        $(this).css("background", "background: -moz-linear-gradient(left, " + color1 + ", " + color2 + ")");
                        $(this).css("background", "background: linear-gradient(to left, " + color1 + ", " + color2 + ")");
                        $(this).css("font-weight", "bold");
                    }

                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                    var colIndex = $(this).parent().index();
                    //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html();
                    var title = $(this).parents("tr").find("td").eq(0).html();

                    for (var i = 0; i < widgetTargetList.length; i++) {
                        $.event.trigger({
                            type: "mouseOverLastDataFromExternalContentGis_" + widgetTargetList[i],
                            eventGenerator: $(this),
                            targetWidget: widgetTargetList[i],
                            value: $(this).attr("data-lastValue"),
                            color1: $(this).attr("data-color1"),
                            color2: $(this).attr("data-color2"),
                            widgetTitle: title
                        });
                    }
                },
                function () {
                    if ($(this).attr("data-lastDataClicked") === "false") {
                        $(this).css("background", color2);
                        $(this).css("font-weight", "normal");
                    }
                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');

                    for (var i = 0; i < widgetTargetList.length; i++) {
                        $.event.trigger({
                            type: "mouseOutLastDataFromExternalContentGis_" + widgetTargetList[i],
                            eventGenerator: $(this),
                            targetWidget: widgetTargetList[i],
                            value: $(this).attr("data-lastValue"),
                            color1: $(this).attr("data-color1"),
                            color2: $(this).attr("data-color2")
                        });
                    }
                });

            //Disabilitiamo i 4Hours se last update più vecchio di 4 ore
            if (rtDataAgeSec > 14400) {
                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="4/HOUR"]').attr("data-disabled", "true");
                //Disabilitiamo i 24Hours se last update più vecchio di 24 ore
                if (rtDataAgeSec > 86400) {
                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="1/DAY"]').attr("data-disabled", "true");
                    //Disabilitiamo i 7 days se last update più vecchio di 7 days
                    if (rtDataAgeSec > 604800) {
                        $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="7/DAY"]').attr("data-disabled", "true");
                        //Disabilitiamo i 30 days se last update più vecchio di 30 days
                        //if(rtDataAgeSec > 18144000)
                        if (rtDataAgeSec > 2592000) {
                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="30/DAY"]').attr("data-disabled", "true");
                            //Disabilitiamo i 6 months se last update più vecchio di 180 days
                            if (rtDataAgeSec > 15552000) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="180/DAY"]').attr("data-disabled", "true");
                                //Disabilitiamo i 1 year se last update più vecchio di 365 days
                                if (rtDataAgeSec > 31536000) {
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="365/DAY"]').attr("data-disabled", "true");
                                    //Disabilitiamo i 2 year se last update più vecchio di 730 days
                                    if (rtDataAgeSec > 31536000 * 2) {
                                        $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="730/DAY"]').attr("data-disabled", "true");
                                        //Disabilitiamo i 10 year se last update più vecchio di 730 days
                                        if (rtDataAgeSec > 315360000) {
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="3650/DAY"]').attr("data-disabled", "true");

                                        } else {
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="3650/DAY"]').attr("data-disabled", "false");
                                        }

                                    } else {
                                        $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="730/DAY"]').attr("data-disabled", "false");
                                    }
                                } else {
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="365/DAY"]').attr("data-disabled", "false");
                                }
                            } else {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="180/DAY"]').attr("data-disabled", "false");
                            }
                        } else {
                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="30/DAY"]').attr("data-disabled", "false");
                        }
                    } else {
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="7/DAY"]').attr("data-disabled", "false");
                    }
                } else {
                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="1/DAY"]').attr("data-disabled", "false");
                }
            } else {
                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="4/HOUR"]').attr("data-disabled", "false");
                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="1/DAY"]').attr("data-disabled", "false");
                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="7/DAY"]').attr("data-disabled", "false");
                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="30/DAY"]').attr("data-disabled", "false");
                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="180/DAY"]').attr("data-disabled", "false");
                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"][data-range="365/DAY"]').attr("data-disabled", "false");
            }

            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').off('mouseenter');
            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').off('mouseleave');
            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"]').hover(function () {
                    if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                        $(this).css("background-color", "#e6e6e6");
                        $(this).off("hover");
                        $(this).off("click");
                    } else {
                        if ($(this).attr("data-timeTrendClicked") === "false") {
                            $(this).css("background", color1);
                            $(this).css("background", "-webkit-linear-gradient(left, " + color1 + ", " + color2 + ")");
                            $(this).css("background", "background: -o-linear-gradient(left, " + color1 + ", " + color2 + ")");
                            $(this).css("background", "background: -moz-linear-gradient(left, " + color1 + ", " + color2 + ")");
                            $(this).css("background", "background: linear-gradient(to left, " + color1 + ", " + color2 + ")");
                            $(this).css("font-weight", "bold");
                        }

                        var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                        //var colIndex = $(this).parent().index();
                        //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html() + " - " + $(this).attr("data-range-shown");
                        var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");

                        for (var i = 0; i < widgetTargetList.length; i++) {
                            $.event.trigger({
                                type: "mouseOverTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                eventGenerator: $(this),
                                targetWidget: widgetTargetList[i],
                                value: $(this).attr("data-lastValue"),
                                color1: $(this).attr("data-color1"),
                                color2: $(this).attr("data-color2"),
                                widgetTitle: title
                            });
                        }
                    }
                },
                function () {
                    if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                        $(this).css("background-color", "#e6e6e6");
                        $(this).off("hover");
                        $(this).off("click");
                    } else {
                        if ($(this).attr("data-timeTrendClicked") === "false") {
                            $(this).css("background", color2);
                            $(this).css("font-weight", "normal");
                        }

                        var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                        for (var i = 0; i < widgetTargetList.length; i++) {
                            $.event.trigger({
                                type: "mouseOutTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                eventGenerator: $(this),
                                targetWidget: widgetTargetList[i],
                                value: $(this).attr("data-lastValue"),
                                color1: $(this).attr("data-color1"),
                                color2: $(this).attr("data-color2")
                            });
                        }
                    }
                });

            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-id=' + serviceProperties.name + ']').off('click');
            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-id=' + serviceProperties.name + ']').click(function (event) {
                let d = densityData;
                $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').each(function (i) {
                    $(this).css("background", $(this).attr("data-color2"));
                });
                $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').css("font-weight", "normal");
                $(this).css("background", $(this).attr("data-color1"));
                $(this).css("font-weight", "bold");
                $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').attr("data-lastDataClicked", "false");
                $(this).attr("data-lastDataClicked", "true");
                var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                var colIndex = $(this).parent().index();
                var title = $(this).parents("tr").find("td").eq(0).html();

                for (var i = 0; i < widgetTargetList.length; i++) {
                    $.event.trigger({
                        type: "showSingleContentFromExternalContent_" + widgetTargetList[i],
                        eventGenerator: $(this),
                        targetWidget: widgetTargetList[i],
                        value: $(this).attr("data-lastValue"),
                        color1: $(this).attr("data-color1"),
                        color2: $(this).attr("data-color2"),
                        widgetTitle: title,
                        passedData: { "dataOperation": d[0][1] }
                    });
                }

                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"]').each(function (i) {
                    if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                        $(this).css("background-color", "#e6e6e6");
                        $(this).off("hover");
                        $(this).off("click");
                    }
                });

            });

            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').off('click');
            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').click(function (event) {
                let d = densityData;
                if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                    $(this).css("background-color", "#e6e6e6");
                    $(this).off("hover");
                    $(this).off("click");
                } else {
                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').css("background", $(this).attr("data-color2"));
                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').css("font-weight", "normal");
                    $(this).css("background", $(this).attr("data-color1"));
                    $(this).css("font-weight", "bold");
                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').attr("data-timeTrendClicked", "false");
                    $(this).attr("data-timeTrendClicked", "true");
                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                    var colIndex = $(this).parent().index();
                    var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");
                    var lastUpdateTime = $(this).parents('div.recreativeEventMapContactsContainer').find('span.popupLastUpdate').html();

                    var now = new Date();
                    var lastUpdateDate = new Date(lastUpdateTime);
                    var diff = parseFloat(Math.abs(now - lastUpdateDate) / 1000);
                    var range = $(this).attr("data-range");

                    const rangeToMilliseconds = {
                        "4/HOUR": 4 * 60 * 60 * 1000,
                        "1/DAY": 24 * 60 * 60 * 1000,
                        "7/DAY": 7 * 24 * 60 * 60 * 1000,
                        "30/DAY": 30 * 24 * 60 * 60 * 1000,
                        "180/DAY": 180 * 24 * 60 * 60 * 1000,
                        "365/DAY": 365 * 24 * 60 * 60 * 1000,
                        "730/DAY": 730 * 24 * 60 * 60 * 1000,
                        "3650/DAY": 3650 * 24 * 60 * 60 * 1000
                    };

                    now = Date.now();
                    const rangeMilliseconds = rangeToMilliseconds[range] || 0;
                    const filteredDensityData = d.filter(item => item[0] >= (now - rangeMilliseconds));

                    console.log(filteredDensityData);

                    var jsonParams = {
                        "metricId": "",
                        "metricHighLevelType": "Dynamic",
                        "metricName": "Traffic Density",
                        "smField": "Density",
                        "metricValueUnit": "Vehicle per 20 m",
                        "values": filteredDensityData
                    };
                    var params = [];
                    params.push(jsonParams);

                    for (var i = 0; i < widgetTargetList.length; i++) {
                        $.event.trigger({
                            type: "showCurvedLinesFromExternalContent_" + widgetTargetList[i],
                            targetWidget: widgetTargetList[i],
                            color1: $(this).attr("data-color1"),
                            color2: $(this).attr("data-color2"),
                            widgetTitle: title,
                            field: $(this).attr("data-field"),
                            passedData: params,
                            mapRef: map.defaultMapRef,
                        });
                    }

                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"]').each(function (i) {
                        if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                            $(this).css("background-color", "#e6e6e6");
                            $(this).off("hover");
                            $(this).off("click");
                        }
                    });
                }
            });

            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + serviceProperties.name + '"]').each(function (i) {
                if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                    $(this).css("background-color", "#e6e6e6");
                    $(this).off("hover");
                    $(this).off("click");
                }
            });

            map.defaultMapRef.off('popupclose');
            map.defaultMapRef.on('popupclose', function (closeEvt) {
                var popupContent = $('<div></div>');
                popupContent.html(closeEvt.popup._content);

                if (popupContent.find("button.lastValueBtn").length > 0) {
                    var widgetTargetList = popupContent.find("button.lastValueBtn").eq(0).attr("data-targetWidgets").split(',');

                    if (($('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-lastDataClicked=true]').length > 0) && ($('input.gisPopupKeepDataCheck').attr('data-keepData') === "false")) {
                        for (var i = 0; i < widgetTargetList.length; i++) {
                            $.event.trigger({
                                type: "restoreOriginalLastDataFromExternalContentGis_" + widgetTargetList[i],
                                eventGenerator: $(this),
                                targetWidget: widgetTargetList[i],
                                value: $(this).attr("data-lastValue"),
                                color1: $(this).attr("data-color1"),
                                color2: $(this).attr("data-color2")
                            });
                        }
                    }

                    if (($('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-timeTrendClicked=true]').length > 0) && ($('input.gisPopupKeepDataCheck').attr('data-keepData') === "false")) {
                        for (var i = 0; i < widgetTargetList.length; i++) {
                            $.event.trigger({
                                type: "restoreOriginalTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                eventGenerator: $(this),
                                targetWidget: widgetTargetList[i]
                            });
                        }
                    }
                }
            });

            $('#<?= $_REQUEST['name_w'] ?>_map div.leaflet-popup').off('click');

        }

        function tfrPopup(e, road, L) {
            var popupContent = road.roadElements;
            L.popup().setLatLng(e.latlng);
            // L.popup().setLatLng(e.latlng).setContent(popupContent).openOn(map.defaultMapRef);

            var apiUrl = "<?= $kbUrlSuperServiceMap; ?>" + "trafficflow/?scenario=" + road.scenario + "&roadElement=" + road.roadElements;

            var getRoadElementTrend = fetchAjax(apiUrl, null, "GET", 'json', true, 0);

            getRoadElementTrend.done(function (jsonData) {
                if (jsonData.status === "ok") {
                    populateTfrPopup(jsonData.result, road, e);
                }
            });

            try {
                execute_<?= $_REQUEST['name_w'] ?>(road);
            } catch (e) {
                console.log("Error in JS function from marker click on " + widgetName);
            }
        }
        

        function createTfrLayer(roads) {
            var tfrLayer = new L.LayerGroup();
            let viewMode = "";
            // viewMode = "line";
            viewMode = "coord";

            roads.result.forEach(function (road) {
                var coords = [];

                if (viewMode == "coord" && road.start != null) {
                    coords = [{ start: [road.start.location.lon, road.start.location.lat], end: [road.end.location.lon, road.end.location.lat] }];
                } else if (road.line && road.line.coordinates && road.line.coordinates.length > 0) {
                    road.line.coordinates.forEach(function(coord, index) {
                        if (index < road.line.coordinates.length - 1) {
                            coords.push({ start: coord, end: road.line.coordinates[index + 1] });
                        }
                    });
                }

                coords.forEach(function (coordPair) {
                    // var color = getColorForDensity(road.density, 1);
                    var color = getColorForDensity(road.density/50, road.lane_numbers);
                    var wktLine = "LINESTRING(" + coordPair.start[0] + " " + coordPair.start[1] + "," + coordPair.end[0] + " " + coordPair.end[1] + ")";
                    var wkt = new Wkt.Wkt();
                    wkt.read(wktLine, "newMap");
                    var obj = wkt.toObject(L.polyline);
                    obj.setStyle({ color: color });

                    obj.on('click', function(event) {
                        tfrPopup(event, road, L);
                    });

                    obj.addTo(tfrLayer);
                });
            });

            return tfrLayer;
        }


        function onMapEntityClick(feature, marker) {

            marker.on('mouseover', function (event) {
                if (feature.properties.deviceName != null) {
                    let tooltipString = "";
                    if (feature.properties.deviceName.includes("building") || feature.properties.deviceName.includes("floor")) {
                        if (feature.properties.deviceName.split("_").length > 2) {
                            tooltipString = "Floor " + feature.properties.deviceName.split("_")[1] + "_" + feature.properties.deviceName.split("_")[2];
                        } else {
                            tooltipString = "Building " + feature.properties.deviceName.split("_")[1];
                        }
                    } else {
                        tooltipString = feature.properties.deviceName;
                    }
                    this.bindTooltip(tooltipString);
                    event.target.openTooltip();
                } else if (feature.properties.name != null) {
                    let tooltipString = feature.properties.name;
                    this.bindTooltip(tooltipString);
                    event.target.openTooltip();
                }
                //$(".leaflet-popup-close-button").css("display", "none");
            });

            marker.on('click', function (event) {
                //    map.defaultMapRef.off('moveend');
                if (feature.properties.deviceName != null) {
                    this.unbindTooltip(feature.properties.deviceName);
                } else if (feature.properties.name != null) {
                    this.unbindTooltip(feature.properties.name);
                }
                if (widgetParameters.mode && widgetParameters.mode == "ckeditor" && code) {
                    let i = 1;
                    if (localStorage.getItem("events") == null) {

                        var events = [];
                        events.push("MapMarkerClick1");
                        localStorage.setItem("events", JSON.stringify(events));
                    }
                    else {
                        var events = JSON.parse(localStorage.getItem("events"));
                        for (var e in events) {
                            if (events[e].slice(0, 9) == "MapMarker")
                                i = i + 1;
                        }
                        events.push("MapMarkerClick" + i);
                        localStorage.setItem("events", JSON.stringify(events));
                    }
                    let newId = "MapMarkerClick" + i;
                    $('#BIMenuCnt').append('<div id="' + newId + '" class="row" data-selected="false"></div>');
                    $('#' + newId).append('<div class="col-md-12 orgMenuSubItemCnt">' + newId + '</div>');
                    $('#' + newId).on("click", function () {
                        var widgets = JSON.parse(localStorage.getItem("widgets"));
                        var index = JSON.parse(localStorage.getItem("events")).indexOf(newId);
                        for (var w in widgets) {
                            if (widgets[w] != null) {
                                $('body').trigger({
                                    type: "reloadPreviousContent_" + widgets[w],
                                    index: index
                                });
                            }
                        }
                    });
                    $('#' + newId).mouseover(function () {
                        $('#' + newId).css('cursor', 'pointer');
                    });

                    var selectedData = {};
                    selectedData.event = "click";
                    selectedData.layers = [];
                    selectedData.layers[0] = marker.feature.properties;
                    if (connections != null) {
                        selectedData.connections = connections;
                    }
                    selectedDataJson = JSON.stringify(selectedData);

                    try {
                        execute_<?= $_REQUEST['name_w'] ?>(selectedDataJson);
                    } catch (e) {
                        console.log("Error in JS function from marker click on " + widgetName);
                    }
                }

                if (altViewMode == "BimShapePopup") {
                    event.target.unbindPopup();
                    newpopup = null;
                    var popupText, realTimeData, measuredTime, rtDataAgeSec, targetWidgets, color1, color2 = null;
                    var urlToCall, fake, fakeId = null;

                    //alert("CLICK!");


                    if (feature.properties.fake === 'true') {
                        urlToCall = "../serviceMapFake.php?getSingleGeoJson=true&singleGeoJsonId=" + feature.id;
                        fake = true;
                        fakeId = feature.id;
                    } else {
                        urlToCall = "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + encodeServiceUri(feature.properties.serviceUri) + "&format=json&fullCount=false";
                        fake = false;
                    }

                    if (event.target._latlng) {
                        var latLngId = event.target.getLatLng().lat + "" + event.target.getLatLng().lng;
                    } else {
                        var latLngId = (event.target.feature.geometry.coordinates[0][0][0])[0] + "" + (event.target.feature.geometry.coordinates[0][0][0])[1]
                    }
                    latLngId = latLngId.replace(".", "");
                    latLngId = latLngId.replace(".", "");//Incomprensibile il motivo ma con l'espressione regolare /./g non funziona

                    // TBD if(this.feature.properties.kpidata != null) { // MAKE MyKPI / MyPOI API CALL AND VISUALIZATION }

                    $.ajax({
                        url: urlToCall,
                        type: "GET",
                        data: {},
                        async: true,
                        dataType: 'json',
                        success: function (geoJsonServiceData) {
                            var fatherNode = null;
                            if (geoJsonServiceData.hasOwnProperty("BusStop")) {
                                fatherNode = geoJsonServiceData.BusStop;
                            } else {
                                if (geoJsonServiceData.hasOwnProperty("Sensor")) {
                                    fatherNode = geoJsonServiceData.Sensor;
                                } else {
                                    //Prevedi anche la gestione del caso in cui non c'è nessuna di queste tre, sennò il widget rimane appeso.
                                    fatherNode = geoJsonServiceData.Service;
                                }
                            }

                            var serviceProperties = fatherNode.features[0].properties;
                            var underscoreIndex = serviceProperties.serviceType.indexOf("_");
                            var serviceClass = serviceProperties.serviceType.substr(0, underscoreIndex);
                            var serviceSubclass = serviceProperties.serviceType.substr(underscoreIndex);
                            serviceSubclass = serviceSubclass.replace(/_/g, " ");

                            fatherNode.features[0].properties.targetWidgets = feature.properties.targetWidgets;
                            fatherNode.features[0].properties.color1 = feature.properties.color1;
                            fatherNode.features[0].properties.color2 = feature.properties.color2;
                            targetWidgets = feature.properties.targetWidgets;
                            color1 = feature.properties.color1;
                            color2 = feature.properties.color2;

                            //Popup nuovo stile uguali a quelli degli eventi ricreativi
                            popupText = '<h3 class="recreativeEventMapTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + serviceProperties.name + '</h3>';
                            /*    if ((serviceProperties.serviceUri !== '') && (serviceProperties.serviceUri !== undefined) && (serviceProperties.serviceUri !== 'undefined') && (serviceProperties.serviceUri !== null) && (serviceProperties.serviceUri !== 'null')) {
                                    popupText += '<div class="recreativeEventMapSubTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + '</div>';
                                    //  popupText += '<div class="recreativeEventMapSubTitle">' + "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + '</div>';
                                }   */
                            let actionUrlFlag = false;
                            let actionUrlText = "";
                            /*for (prop in geoJsonServiceData.Service.features[0].properties.realtimeAttributes) {
                                if (geoJsonServiceData.Service.features[0].properties.realtimeAttributes[prop].value_type == "ActionUrl" && geoJsonServiceData.realtime.results.bindings[0][prop] != null && prop != "image") {
                                    actionUrlFlag = true;
                                    let actionObj = {};
                                    let action = "";
                                    let href = "";
                                    if (geoJsonServiceData.realtime.results.bindings[0][prop].value != null && IsJsonString(geoJsonServiceData.realtime.results.bindings[0][prop].value)) {
                                        actionObj = JSON.parse(geoJsonServiceData.realtime.results.bindings[0][prop].value);
                                        if (actionObj.action == "[Open on Tab]") {
                                            action = '_blank';
                                        }
                                        href = actionObj.baseulr + actionObj.url;
                                    }
                                    actionUrlText = actionUrlText + '<button data-id="' + latLngId + '" class="recreativeEventActionBtn recreativeEventMapBtn" type="button" onclick="window.open(\'' + href + '\', \'' + action + '\')"' + action + ' style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + prop + '</button>';
                                }
                            }*/
                            popupText += '<div class="recreativeEventMapBtnContainer"><button data-id="' + latLngId + '" class="recreativeEventMapDetailsBtn recreativeEventMapBtn recreativeEventMapBtnActive" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Details</button><button data-id="' + latLngId + '" class="recreativeEventMapDescriptionBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Description</button><button data-id="' + latLngId + '" class="recreativeEventMapContactsBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">RT data</button>' + actionUrlText + (geoJsonServiceData.hasOwnProperty("BusStop") ? '<button data-id="' + latLngId + '" class="recreativeEventMapTplTmtblBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">TIMETABLE</button><button data-id="' + latLngId + '" class="recreativeEventMapTplBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">BROWSE</button>' : '') + '</div>';

                            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDetailsContainer">';

                            popupText += '<table id="' + latLngId + '" class="gisPopupGeneralDataTable">';
                            //Intestazione
                            popupText += '<thead>';
                            popupText += '<th style="background: ' + color2 + '">Description</th>';
                            popupText += '<th style="background: ' + color2 + '">Value</th>';
                            popupText += '</thead>';

                            //Corpo
                            popupText += '<tbody>';

                            for (var featureKey in serviceProperties) {
                                if (serviceProperties.hasOwnProperty(featureKey)) {
                                    if (serviceProperties[featureKey] != null && serviceProperties[featureKey] !== '' && serviceProperties[featureKey] !== ' ' && featureKey !== 'targetWidgets' && featureKey !== 'color1' && featureKey !== 'color2' && featureKey !== 'realtimeAttributes') {
                                        if (!Array.isArray(serviceProperties[featureKey]) || (Array.isArray(serviceProperties[featureKey] && serviceProperties[featureKey].length > 0))) {
                                            popupText += '<tr><td>' + featureKey + '</td><td>' + serviceProperties[featureKey] + '</td></tr>';
                                        }
                                    }
                                }
                            }
                            if (nodeId != null && serviceProperties["serviceUri"] != null && serviceProperties["serviceUri"] != '') {
                                let eventJson = new Object();
                                eventJson.latitude = feature.geometry.coordinates[1];
                                eventJson.longitude = feature.geometry.coordinates[0];
                                eventJson.serviceUri = serviceProperties["serviceUri"];
                                currentValue = JSON.stringify(eventJson);
                                triggerEventOnIotApp(map.defaultMapRef, currentValue);
                            }

                            popupText += '</tbody>';
                            popupText += '</table>';

                            /*if (geoJsonServiceData.hasOwnProperty('busLines')) {
                                if (geoJsonServiceData.busLines.results.bindings.length > 0) {
                                    popupText += '<b>Lines: </b>';
                                    for (var i = 0; i < geoJsonServiceData.busLines.results.bindings.length; i++) {
                                        popupText += '<span style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + geoJsonServiceData.busLines.results.bindings[i].busLine.value + '</span> ';
                                    }
                                }
                            }*/

                            if (geoJsonServiceData.hasOwnProperty("BusStop")) {
                                popupText += '<div class="tplProgressBar" style="display:none; width:100%; height:1em; margin-top:1em; background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');"></div>';
                            }

                            popupText += '</div>';

                            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDescContainer">';

                            if ((serviceProperties.serviceUri !== '') && (serviceProperties.serviceUri !== undefined) && (serviceProperties.serviceUri !== 'undefined') && (serviceProperties.serviceUri !== null) && (serviceProperties.serviceUri !== 'null')) {
                                popupText += "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + "<br>";
                            }

                            if ((serviceProperties.serviceType !== '') && (serviceProperties.serviceType !== undefined) && (serviceProperties.serviceType !== 'undefined') && (serviceProperties.serviceType !== null) && (serviceProperties.serviceType !== 'null')) {
                                popupText += "Nature: " + serviceProperties.serviceType.split(/_(.+)/)[0] + "<br>";
                                popupText += "Subnature: " + serviceProperties.serviceType.split(/_(.+)/)[1] + "<br><br>";
                            }

                            if (serviceProperties.hasOwnProperty('description')) {
                                if ((serviceProperties.description !== '') && (serviceProperties.description !== undefined) && (serviceProperties.description !== 'undefined') && (serviceProperties.description !== null) && (serviceProperties.description !== 'null')) {
                                    popupText += serviceProperties.description + "<br>";
                                } else {
                                    popupText += "No description available";
                                }
                            } else {
                                popupText += 'No description available';
                            }

                            popupText += '</div>';

                            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapContactsContainer">';

                            var hasRealTime = false;

                            if (geoJsonServiceData.hasOwnProperty("realtime")) {
                                if (!jQuery.isEmptyObject(geoJsonServiceData.realtime)) {
                                    realTimeData = geoJsonServiceData.realtime;
                                    if (selectedMetrics != null) {
                                        realTimeData.head.vars = selectedMetrics;
                                    }
                                    popupText += '<div class="popupLastUpdateContainer centerWithFlex"><b>Last update:&nbsp;</b><span class="popupLastUpdate" data-id="' + latLngId + '"></span></div>';

                                    if ((serviceClass.includes("Emergency")) && (serviceSubclass.includes("First aid"))) {
                                        //Tabella ad hoc per First Aid
                                        popupText += '<table id="' + latLngId + '" class="psPopupTable">';
                                        var series = {
                                            "firstAxis": {
                                                "desc": "Priority",
                                                "labels": [
                                                    "Red code",
                                                    "Yellow code",
                                                    "Green code",
                                                    "Blue code",
                                                    "White code"
                                                ]
                                            },
                                            "secondAxis": {
                                                "desc": "Status",
                                                "labels": [],
                                                "series": []
                                            }
                                        };

                                        var dataSlot = null;

                                        measuredTime = realTimeData.results.bindings[0].measuredTime.value.replace("T", " ").replace("Z", "");

                                        for (var i = 0; i < realTimeData.results.bindings.length; i++) {
                                            if (realTimeData.results.bindings[i].state.value.indexOf("estinazione") > 0) {
                                                series.secondAxis.labels.push("Addressed");
                                            }

                                            if (realTimeData.results.bindings[i].state.value.indexOf("ttesa") > 0) {
                                                series.secondAxis.labels.push("Waiting");
                                            }

                                            if (realTimeData.results.bindings[i].state.value.indexOf("isita") > 0) {
                                                series.secondAxis.labels.push("In visit");
                                            }

                                            if (realTimeData.results.bindings[i].state.value.indexOf("emporanea") > 0) {
                                                series.secondAxis.labels.push("Observation");
                                            }

                                            if (realTimeData.results.bindings[i].state.value.indexOf("tali") > 0) {
                                                series.secondAxis.labels.push("Totals");
                                            }

                                            dataSlot = [];
                                            dataSlot.push(realTimeData.results.bindings[i].redCode.value);
                                            dataSlot.push(realTimeData.results.bindings[i].yellowCode.value);
                                            dataSlot.push(realTimeData.results.bindings[i].greenCode.value);
                                            dataSlot.push(realTimeData.results.bindings[i].blueCode.value);
                                            dataSlot.push(realTimeData.results.bindings[i].whiteCode.value);

                                            series.secondAxis.series.push(dataSlot);
                                        }

                                        var colsQt = parseInt(parseInt(series.firstAxis.labels.length) + 1);
                                        var rowsQt = parseInt(parseInt(series.secondAxis.labels.length) + 1);

                                        for (var i = 0; i < rowsQt; i++) {
                                            var newRow = $("<tr></tr>");
                                            var z = parseInt(parseInt(i) - 1);

                                            if (i === 0) {
                                                //Riga di intestazione
                                                for (var j = 0; j < colsQt; j++) {
                                                    if (j === 0) {
                                                        //Cella (0,0)
                                                        var newCell = $("<td></td>");

                                                        newCell.css("background-color", "transparent");
                                                    } else {
                                                        //Celle labels
                                                        var k = parseInt(parseInt(j) - 1);
                                                        var colLabelBckColor = null;
                                                        switch (k) {
                                                            case 0:
                                                                colLabelBckColor = "#ff0000";
                                                                break;

                                                            case 1:
                                                                colLabelBckColor = "#ffff00";
                                                                break;

                                                            case 2:
                                                                colLabelBckColor = "#66ff33";
                                                                break;

                                                            case 3:
                                                                colLabelBckColor = "#66ccff";
                                                                break;

                                                            case 4:
                                                                colLabelBckColor = "#ffffff";
                                                                break;
                                                        }

                                                        newCell = $("<td><span>" + series.firstAxis.labels[k] + "</span></td>");
                                                        newCell.css("font-weight", "bold");
                                                        newCell.css("background-color", colLabelBckColor);
                                                    }
                                                    newRow.append(newCell);
                                                }
                                            } else {
                                                //Righe dati
                                                for (var j = 0; j < colsQt; j++) {
                                                    k = parseInt(parseInt(j) - 1);
                                                    if (j === 0) {
                                                        //Cella label
                                                        newCell = $("<td>" + series.secondAxis.labels[z] + "</td>");
                                                        newCell.css("font-weight", "bold");
                                                    } else {
                                                        //Celle dati
                                                        newCell = $("<td>" + series.secondAxis.series[z][k] + "</td>");
                                                        if (i === (rowsQt - 1)) {
                                                            newCell.css('font-weight', 'bold');
                                                            switch (j) {
                                                                case 1:
                                                                    newCell.css('background-color', '#ffb3b3');
                                                                    break;

                                                                case 2:
                                                                    newCell.css('background-color', '#ffff99');
                                                                    break;

                                                                case 3:
                                                                    newCell.css('background-color', '#d9ffcc');
                                                                    break;

                                                                case 4:
                                                                    newCell.css('background-color', '#cceeff');
                                                                    break;

                                                                case 5:
                                                                    newCell.css('background-color', 'white');
                                                                    break;
                                                            }
                                                        }
                                                    }
                                                    newRow.append(newCell);
                                                }
                                            }
                                            popupText += newRow.prop('outerHTML');
                                        }

                                        popupText += '</table>';
                                    } else {
                                        //Tabella nuovo stile
                                        popupText += '<table id="' + latLngId + '" class="gisPopupTable">';

                                        //Intestazione
                                        popupText += '<thead>';
                                        popupText += '<th style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Description</th>';
                                        popupText += '<th style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Value</th>';
                                        popupText += '<th colspan="9" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Buttons</th>';
                                        popupText += '</thead>';

                                        //Corpo
                                        popupText += '<tbody>';
                                        var dataDesc, dataVal, dataLastBtn, data4HBtn, dataDayBtn, data7DayBtn,
                                            data30DayBtn, data6MonthsBtn, data1YearBtn, data2YearBtn, data10YearBtn,
                                            value_unit = null;
                                        if (realTimeData.head != null) {
                                            for (var i = 0; i < realTimeData.head.vars.length; i++) {
                                                if (realTimeData.results.bindings[0][realTimeData.head.vars[i]] !== null && realTimeData.results.bindings[0][realTimeData.head.vars[i]] !== undefined) {
                                                    if ((realTimeData.results.bindings[0][realTimeData.head.vars[i]]) && (realTimeData.results.bindings[0][realTimeData.head.vars[i]].value.trim() !== '') && (realTimeData.head.vars[i] !== null) && (realTimeData.head.vars[i] !== 'undefined')) {
                                                        if ((realTimeData.head.vars[i] !== 'updating') && (realTimeData.head.vars[i] !== 'measuredTime') && (realTimeData.head.vars[i] !== 'instantTime')) {
                                                            if (!realTimeData.results.bindings[0][realTimeData.head.vars[i]].value.includes('Not Available')) {
                                                                //realTimeData.results.bindings[0][realTimeData.head.vars[i]].value = '-';
                                                                /*   dataDesc = realTimeData.head.vars[i].replace(/([A-Z])/g, ' $1').replace(/^./, function (str) {
                                                                       return str.toUpperCase();
                                                                   });*/
                                                                dataDesc = realTimeData.head.vars[i];
                                                                dataVal = realTimeData.results.bindings[0][realTimeData.head.vars[i]].value;
                                                                if (serviceProperties.realtimeAttributes && serviceProperties.realtimeAttributes[realTimeData.head.vars[i]] && serviceProperties.realtimeAttributes[realTimeData.head.vars[i]].value_unit) {
                                                                    value_unit = serviceProperties.realtimeAttributes[realTimeData.head.vars[i]].value_unit;
                                                                }
                                                                if (dataVal.length > 50 && value_unit !== "SURI") {
                                                                    dataVal = '<div class="tooltipSuri">' + encodeHTMLEntities(dataVal).substring(0, 20) + '... <span class="tooltipSuriText">' + dataVal + '</span></div>';
                                                                }
                                                                if (value_unit == "SURI") {
                                                                    if (dataVal.includes("http://www.disit.org/km4city")) {
                                                                        dataVal = '<div class="tooltipSuri">[SURI id]<span class="tooltipSuriText">' + dataVal + '</span></div>';
                                                                    } else {
                                                                        dataVal = '<div class="tooltipSuri">[WEB Url]<span class="tooltipSuriText">' + dataVal + '</span></div>';
                                                                    }
                                                                }
                                                                if (dataVal.length > 50) {
                                                                    dataLastBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="lastValueBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-id="' + latLngId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-lastDataClicked="false" data-targetWidgets="' + targetWidgets + '" data-lastValue="' + (realTimeData.results.bindings[0][realTimeData.head.vars[i]].value).replace(/["]+/g, '') + '" data-color1="' + color1 + '" data-color2="' + color2 + '" data-value_unit="' + value_unit + '">Last</button></td>';
                                                                } else {
                                                                    dataLastBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="lastValueBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-id="' + latLngId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-lastDataClicked="false" data-targetWidgets="' + targetWidgets + '" data-lastValue="' + realTimeData.results.bindings[0][realTimeData.head.vars[i]].value + '" data-color1="' + color1 + '" data-color2="' + color2 + '" data-value_unit="' + value_unit + '">Last</button></td>';
                                                                }
                                                                data4HBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-id="' + latLngId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="4 Hours" data-range="4/HOUR" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">4h</button></td>';
                                                                dataDayBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="Day" data-range="1/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">24h</button></td>';
                                                                data7DayBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="7 days" data-range="7/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">7d</button></td>';
                                                                data30DayBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="30 days" data-range="30/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">30d</button></td>';
                                                                data6MonthsBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="6 months" data-range="180/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">6m</button></td>';
                                                                data1YearBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="1 year" data-range="365/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">1y</button></td>';
                                                                data2YearBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="2 year" data-range="730/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">2y</button></td>';
                                                                data10YearBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="10 year" data-range="3650/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">10y</button></td>';
                                                                popupText += '<tr><td>' + dataDesc + '</td><td>' + dataVal + '</td>' + dataLastBtn + data4HBtn + dataDayBtn + data7DayBtn + data30DayBtn + data6MonthsBtn + data1YearBtn + data2YearBtn + data10YearBtn + '</tr>';
                                                            }
                                                        } else {
                                                            measuredTime = realTimeData.results.bindings[0][realTimeData.head.vars[i]].value.replace("T", " ");
                                                            var now = new Date();
                                                            var measuredTimeDate = new Date(measuredTime);
                                                            rtDataAgeSec = Math.abs(now - measuredTimeDate) / 1000;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        popupText += '</tbody>';
                                        popupText += '</table>';
                                        popupText += '<p><b>Keep data on target widget(s) after popup close: </b><input data-id="' + latLngId + '" type="checkbox" class="gisPopupKeepDataCheck" data-keepData="false"/></p>';
                                    }

                                    hasRealTime = true;
                                }
                            }

                            popupText += '</div>';

                            if (geoJsonServiceData.hasOwnProperty("BusStop")) {
                                popupText += '<div id="linesof_' + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + '" class="recreativeEventMapDataContainer recreativeEventMapTplContainer">Please wait...</div>';
                                popupText += '<div id="tmtblof_' + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + '" class="recreativeEventMapDataContainer recreativeEventMapTplTmtblContainer">Please wait...</div>';
                            }

                            newpopup = L.popup({
                                closeOnClick: false,//Non lo levare, sennò autoclose:false non funziona
                                autoClose: false,
                                offset: [15, 0],
                                //minWidth: 435,
                                minWidth: 400,
                                maxWidth: 1200,
                                //	className: geoJsonServiceData.hasOwnProperty("BusStop")?"draggableAndResizablePopup":"nonDraggableAndResizablePopup"
                                className: "draggableAndResizablePopup"
                            }).setContent(popupText);

                            event.target.bindPopup(newpopup).openPopup();

                            // draggable
                            var makeDraggable = function (popup, excluding) {
                            	popupResizeObserver.observe(popup._wrapper)
                                var pos = map.defaultMapRef.latLngToLayerPoint(popup.getLatLng());
                                L.DomUtil.setPosition(popup._wrapper.parentNode, pos);
                                console.log("POPUP", popup._wrapper, $(popup._wrapper).children(".leaflet-popup-content"))
                                var draggable = new L.Draggable(popup._container, popup._wrapper);
                                var popup_content = $(popup._wrapper).children(".leaflet-popup-content")[0]
                                popup._wrapper._draggable = draggable
                                $(popup_content).css("width", "")
                                draggable.enable();
                                $(".draggableAndResizablePopup").css("cursor", "move");
                                draggable.on('dragend', function () {
                                    var pos = map.defaultMapRef.layerPointToLatLng(this._newPos);
                                    popup.setLatLng(pos);
                                    $(popup._wrapper).siblings(".leaflet-popup-tip-container").hide();
                                });
                                excluding.forEach((excluded) => {
                                    $(excluded).css("cursor", "auto").on("mouseover", function (e) {
                                        draggable.disable();
                                    }).on("mouseout", function (e) {
                                        draggable.enable();
                                    });
                                });
                            };
                            //	if(newpopup.options.className == "draggableAndResizablePopup") makeDraggable(newpopup, [".draggableAndResizablePopup table.gisPopupGeneralDataTable"]);
                            if (newpopup.options.className == "draggableAndResizablePopup") makeDraggable(newpopup, [".draggableAndResizablePopup .recreativeEventMapDataContainer"]);


                            //

                            // resizable
                            $(".draggableAndResizablePopup .leaflet-popup-content-wrapper").css({
                                "resize": "both",
                                "overflow": "auto",
                                "min-width": "400px",
                                "max-width": "1200px",
                                "min-height": "100px",
                                "max-height": "400px"
                            });
                            //

                            // responsive
                            $(".draggableAndResizablePopup .recreativeEventMapDataContainer").css({
                                "width": "100%",
                                "height": "100%"
                            });
                            //

                            if (geoJsonServiceData.hasOwnProperty("BusStop")) {

                                $.getJSON('<?= $whatifmdtendpt ?>?stop=' + encodeURIComponent(serviceProperties['serviceUri']) + "&list=graphs", function (graphs) {
                                    var pAgency = graphs.join();
                                    var routesMarkup = "<p class=\"tplpoi_routesSubHead\" style=\"background-color:black; color:white; padding:0.5em;\"><strong>Date:</strong>&nbsp;" + new Date().toLocaleDateString("en", {
                                        weekday: 'long',
                                        year: 'numeric',
                                        month: 'long',
                                        day: 'numeric'
                                    }) + "</p>";
                                    var progress = { todo: -1, done: -1, bar: 0 };
                                    $.getJSON('<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&stop=' + encodeURIComponent(serviceProperties['serviceUri']) + '&date=' + encodeURIComponent(new Date().toISOString().slice(0, 10)) + '&list=routes', function (routes) {
                                        if (Object.keys(routes).length == 0) {
                                            $(".recreativeEventMapTplBtn").hide();
                                            return;
                                        }
                                        Object.keys(routes).forEach(function (key) {
                                            var route = routes[key];
                                            var rteBtnUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&route=' + encodeURIComponent(route["uri"]) + "&stop=" + encodeURIComponent(serviceProperties['serviceUri']) + "&date=" + encodeURIComponent(new Date().toISOString().slice(0, 10)) + "&list=trips";
                                            routesMarkup += "<p class=\"tplpoi_wifstprte\"><button class=\"polyin_" + route["uri"].replace(/[^a-zA-Z0-9]/g, "") + "\" data-uri=\"" + route["uri"] + "\" data-url=\"" + rteBtnUrl + "\" data-geoms=\"" + route["geoms"].join("|") + "\" data-key=\"" + key + "\" style=\"width:100%; background-color:#" + route["color"] + "; color:#" + route["text_color"] + "\">" + route["type"] + " " + route["short_name"] + " " + route["long_name"] + "</button></p>";
                                            route["geoms"].forEach(function (path) {
                                                var latlngs = [];
                                                path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                                    latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                                });
                                                var polyline = new L.Polyline(latlngs, {
                                                    className: "tplPoiPolyline polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " polyin_" + route["uri"].replace(/[^a-zA-Z0-9]/g, ""),
                                                    color: "#" + route["color"],
                                                    weight: 6
                                                }).bindTooltip(route["type"] + " " + route["short_name"] + " " + route["long_name"], { direction: 'right' });
                                                polyline.on("mouseover", function (e) {
                                                    e.target.openTooltip(e.latlng);
                                                });
                                                if ("undefined" == typeof tplPoiItems) {
                                                    tplPoiItems = new L.FeatureGroup();
                                                    map.defaultMapRef.addLayer(tplPoiItems);
                                                }
                                                polyline.addTo(tplPoiItems);
                                            });
                                            newpopup.on('remove', function () {
                                                $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).hide(); // TODO Remove only those related to the specific stop!!
                                            });
                                            // qui andiamo a generare tutte le stop raggiungibili direttamente (senza cambi) da quella selezionata
                                            $.getJSON(rteBtnUrl, function (trips) {
                                                var tripGeoms = [];
                                                Object.keys(trips).forEach(function (tripkey) {
                                                    if (!tripGeoms.includes(trips[tripkey]["path"])) {
                                                        tripGeoms.push(trips[tripkey]["path"]);
                                                        $.getJSON('<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&trip=' + encodeURIComponent(trips[tripkey]["uri"]) + "&list=stops", function (stops) {
                                                            var eventDesc = null;
                                                            map["eventsOnMap"].forEach(function (mapevt) {
                                                                if (mapevt["color1"] == feature["properties"]["color1"] && mapevt["color2"] == feature["properties"]["color2"]) {
                                                                    eventDesc = mapevt["desc"];
                                                                }
                                                            });
                                                            if (progress.todo == -1 && stops.length > 0) {
                                                                progress.todo = stops.length;
                                                            } else {
                                                                progress.todo += stops.length;
                                                            }
                                                            stops.forEach(function (stop) {
                                                                Number.prototype.countDecimals = function () {
                                                                    if (Math.floor(this.valueOf()) === this.valueOf()) return 0;
                                                                    return this.toString().split(".")[1].length || 0;
                                                                };
                                                                for (var l = 0; l < gisLayersOnMap[eventDesc].getLayers().length; l++) {
                                                                    var layer = gisLayersOnMap[eventDesc].getLayers()[l];
                                                                    if ((layer["feature"] && layer["feature"]["properties"]["serviceUri"] == stop["stop_uri"]) ||
                                                                        ((!layer["feature"]) && layer["_latlng"] && layer["_latlng"]["lat"] && parseFloat(layer["_latlng"]["lat"]) == parseFloat(stop["pos_lat"]).toFixed(parseFloat(layer["_latlng"]["lat"]).countDecimals()) && layer["_latlng"]["lng"] && parseFloat(layer["_latlng"]["lng"]) == parseFloat(stop["pos_lon"]).toFixed(parseFloat(layer["_latlng"]["lng"]).countDecimals()))) {
                                                                        if (progress.done == -1) progress.done = 1; else progress.done += 1;
                                                                        if (progress.done > -1 && progress.todo > -1 && progress.bar <= 100 * progress.done / progress.todo) {
                                                                            progress.bar = 100 * progress.done / progress.todo;
                                                                            $(newpopup._container).find("div.tplProgressBar").css("width", (100 * progress.done / progress.todo) + "%");
                                                                            $(newpopup._container).find("div.tplProgressBar").show();
                                                                            //console.log(progress);
                                                                        } else {
                                                                            if (progress.bar < 99) {
                                                                                progress.bar++;
                                                                                $(newpopup._container).find("div.tplProgressBar").css("width", progress.bar + "%");
                                                                                $(newpopup._container).find("div.tplProgressBar").show();
                                                                            }
                                                                        }
                                                                        return;
                                                                    }
                                                                }
                                                                $.getJSON("<?= $superServiceMapProxy ?>/api/v1?realtime=false&graphUri=" + encodeURIComponent(pAgency) + "&serviceUri=" + encodeURIComponent(stop["stop_uri"]), function (stopdata) {
                                                                    var newFeature = stopdata["BusStop"]["features"][0];
                                                                    newFeature["properties"]["color1"] = feature["properties"]["color1"];
                                                                    newFeature["properties"]["color2"] = feature["properties"]["color2"];
                                                                    newFeature["properties"]["pinattr"] = feature["properties"]["pinattr"];
                                                                    newFeature["properties"]["pincolor"] = feature["properties"]["pincolor"];
                                                                    newFeature["properties"]["symbolcolor"] = feature["properties"]["symbolcolor"];
                                                                    var newMarker = gisPrepareCustomMarker(newFeature, {
                                                                        "lng": newFeature["geometry"]["coordinates"][0],
                                                                        "lat": newFeature["geometry"]["coordinates"][1]
                                                                    });
                                                                    newMarker.addTo(gisLayersOnMap[eventDesc]);
                                                                    if (progress.done == -1) progress.done = 1; else progress.done += 1;
                                                                    if (progress.done > -1 && progress.todo > -1 && progress.bar < 100 * progress.done / progress.todo) {
                                                                        progress.bar = 100 * progress.done / progress.todo;
                                                                        $(newpopup._container).find("div.tplProgressBar").css("width", (100 * progress.done / progress.todo) + "%");
                                                                        $(newpopup._container).find("div.tplProgressBar").show();
                                                                    } else {
                                                                        if (progress.bar < 99) {
                                                                            progress.bar++;
                                                                            $(newpopup._container).find("div.tplProgressBar").css("width", progress.bar + "%");
                                                                            $(newpopup._container).find("div.tplProgressBar").show();
                                                                        }
                                                                    }
                                                                });
                                                            });
                                                        });
                                                    }
                                                });
                                            });
                                            //
                                        });
                                        if (Object.keys(routes).length === 0 && routes.constructor === Object) routesMarkup += "<p>No routes found for this date.</p>";
                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).empty().append($(routesMarkup));
                                        $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).click(function () {
                                            var classes = $(this).attr('class').split(/\s+/);
                                            $.each(classes, function (i, c) {
                                                if (c.startsWith('polyin_')) {
                                                    $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').click();
                                                    $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').parent().siblings('div.recreativeEventMapTplContainer').find("button." + c).click();
                                                    map.defaultMapRef.panTo(new L.LatLng(event.target.getLatLng().lat, event.target.getLatLng().lng));
                                                }
                                            });
                                        });


                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_wifstprte button").click(function () {
                                            var wifstprtebtn = $(this);
                                            var wifstprtebtnhtml = $(this).html();
                                            var rteUri = $(this).data("uri");
                                            $(this).html("Please wait...");
                                            var hrRouteTxt = $(this).data("key");
                                            lastSelectedRoute = hrRouteTxt;

                                            var bg = $(this).css("background-color");
                                            var fg = $(this).css("color");
                                            $.getJSON($(this).data("url"), function (trips) {
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p").hide();
                                                wifstprtebtn.html(wifstprtebtnhtml);
                                                var affectedTripsMarkup = "";
                                                var tripsMarkup = "<p class=\"tplpoi_tripsSubHead\" style=\"background-color:black; color:white; padding:0.5em;\"><strong>Date:</strong>&nbsp;" + new Date().toLocaleDateString("en", {
                                                    weekday: 'long',
                                                    year: 'numeric',
                                                    month: 'long',
                                                    day: 'numeric'
                                                }) + "<br><strong>Route:</strong>&nbsp;" + hrRouteTxt + "</p><div style=\"height:100%; border: medium solid black; padding:0.5em;\" class=\"tplpoi_tripsDivInRoute\"><p class=\"tplpoi_preserveplease\" style=\"margin:0px 0; display:none;\"><strong>Affected Trips:</strong></p><div id=\"tplpoi_affectedtrips\" style=\"display:none;\"></div><p class=\"tplpoi_preserveplease\" style=\"margin:0px 0;\"><strong style=\"display:none;\">All Trips:</strong></p>";
                                                $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).hide();
                                                Object.keys(trips).sort(function (a, b) {
                                                    if (trips[a]["start"] > trips[b]["start"]) return 1; else return -1;
                                                }).forEach(function (tripkey) {
                                                    var trip = trips[tripkey];
                                                    var theTripUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&trip=' + encodeURIComponent(trip["uri"]) + "&list=stops";
                                                    tripsMarkup += "<p class=\"tplpoi_wifstptrp\"><button style=\"text-align:left; width:100%; background-color:" + bg + "; color:" + fg + ";\" data-tripkey=\"" + tripkey + "\" data-path=\"" + trip["path"] + "\" data-url=\"" + theTripUrl + "\" data-routeuri=\"" + rteUri + "\" data-routebgcolor=\"" + trip["route"]["bg_color"] + "\" data-routefgcolor=\"" + trip["route"]["fg_color"] + "\" data-routeshortname=\"" + trip["route"]["short_name"] + "\" data-routelongname=\"" + trip["route"]["long_name"] + "\" data-routetype=\"" + trip["route"]["type"] + "\" data-agencyname=\"" + trip["route"]["agency"] + "\">" + trip["start"].substring(0, 5) + "&nbsp;<span style=\"border:thin solid " + fg + "; padding:0.2em;\">" + (trip["direction"] == "0" ? "&rharu;" : "&lhard;") + "</span>&nbsp;" + trip["headsign"] + "</button></p>";
                                                    var latlngs = [];
                                                    trip["path"].split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                                        latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                                    });
                                                    var polyline = new L.Polyline(latlngs, {
                                                        weight: 6,
                                                        color: wifstprtebtn.css("background-color"),
                                                        className: "tplPoiPolyline polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " polyof_" + rteUri.replace(/[^a-zA-Z0-9]/g, "")
                                                    });
                                                    polyline.addTo(tplPoiItems);
                                                });
                                                tripsMarkup += "</div>";
                                                tripsMarkup += "<p class=\"tplpoi_backToRoutes\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_tripsSubHead").remove();
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_tripsDivInRoute").remove();
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_backToRoutes").remove();
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).append($(tripsMarkup));

                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToRoutes button").click(function () {
                                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p").hide();
                                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_tripsDivInRoute").hide();
                                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_routesSubHead").show();
                                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_wifstprte").show();
                                                    $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).show();
                                                });

                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_wifstptrp button").click(function () {
                                                    var wifstptrpbtn = $(this);
                                                    var wifstptrpbtnhtml = $(this).html();
                                                    var theaffectedstopsMarkup = "";
                                                    var theTripMarkup = "<p class=\"tplpoi_theTripSubhead\" style=\"background-color:black; color:white;  padding:0.5em;\"><strong>Agency:</strong>&nbsp;" + $(this).data("agencyname") + "<br><strong>Route:</strong>&nbsp;" + $(this).data("routetype") + " " + $(this).data("routeshortname") + " " + $(this).data("routelongname") + "<br><strong>Trip:</strong>&nbsp;" + $(this).html().replace("<strong>", "").replace("</strong>", "") + "</p><div class=\"tplpoi_fullTripData\" style=\"height:100%; border: medium solid black; padding:0.5em;\"><p style=\"margin:0px 0; display:none;\"><strong>Affected Stops:</strong></p><div id=\"tplpoi_affectedstops\" style=\"display:none;\"></div><p style=\"margin:0px 0;\"><strong style=\"display:none;\">All Stops:</strong></p>";
                                                    $(this).html("Please wait...");
                                                    var bgcolor = $(this).data("routebgcolor");
                                                    var fgcolor = $(this).data("routefgcolor");
                                                    var routetype = $(this).data("routetype");
                                                    var path = $(this).data("path");
                                                    var tripkey = $(this).data("tripkey");
                                                    var routeUri = $(this).data("routeuri");

                                                    $.getJSON($(this).data("url"), function (tripdata) {
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_tripsSubHead").hide();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_wifstptrp").hide();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_backToRoutes").hide();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_tripsDivInRoute").hide();
                                                        wifstptrpbtn.html(wifstptrpbtnhtml);
                                                        $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).hide();
                                                        var latlngs = [];
                                                        path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                                            latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                                        });
                                                        var polyline = new L.Polyline(latlngs, {
                                                            weight: 6,
                                                            color: "#" + bgcolor,
                                                            className: "tplPoiPolyline polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")
                                                        });
                                                        polyline.addTo(tplPoiItems);
                                                        tripdata.forEach(function (oneStop, stopNum) {
                                                            if (serviceProperties['serviceUri'] == oneStop["stop_uri"]) {
                                                                theTripMarkup += "<button data-serviceuri=\"" + oneStop["stop_uri"] + "\" data-lat=\"" + oneStop["pos_lat"] + "\" data-lon=\"" + oneStop["pos_lon"] + "\" class=\"tplpoi_stopbtn\" style=\"text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + "; font-size:larger; font-weight:bold; \">#" + parseInt(oneStop["sequence"]) + " " + oneStop["code"] + " " + oneStop["name"] + "<br>ARR " + (stopNum > 0 ? oneStop["arrival"].substring(0, 5) : "--:--") + " DEP " + (stopNum < tripdata.length - 1 ? oneStop["departure"].substring(0, 5) : "--:--") + "</button>";
                                                            } else {
                                                                theTripMarkup += "<button data-serviceuri=\"" + oneStop["stop_uri"] + "\" data-lat=\"" + oneStop["pos_lat"] + "\" data-lon=\"" + oneStop["pos_lon"] + "\" class=\"tplpoi_stopbtn\" style=\"text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + ";\">#" + parseInt(oneStop["sequence"]) + " " + oneStop["code"] + " " + oneStop["name"] + "<br>ARR " + (stopNum > 0 ? oneStop["arrival"].substring(0, 5) : "--:--") + " DEP " + (stopNum < tripdata.length - 1 ? oneStop["departure"].substring(0, 5) : "--:--") + "</button>";
                                                            }
                                                        });
                                                        theTripMarkup += "</div>";
                                                        theTripMarkup += "<p class=\"tplpoi_backToTrips\"><button style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_theTripSubhead").remove();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_fullTripData").remove();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_backToTrips").remove();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).append($(theTripMarkup));
                                                        if (theaffectedstopsMarkup == "") {
                                                            theaffectedstopsMarkup = "<p>No stops found.</p>";
                                                        }
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToTrips button").click(
                                                            function () {
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p").hide();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_fullTripData").hide();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_tripsSubHead").show();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_tripsDivInRoute").show();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_wifstptrp").show();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_backToRoutes").show();
                                                                $(".polyof_" + routeUri.replace(/[^a-zA-Z0-9]/g, "")).show();
                                                            }
                                                        );
                                                        Number.prototype.countDecimals = function () {
                                                            if (Math.floor(this.valueOf()) === this.valueOf()) return 0;
                                                            return this.toString().split(".")[1].length || 0;
                                                        };
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " button.tplpoi_stopbtn").click(function () {
                                                            //console.log("stopbtn");
                                                            var serviceuri = $(this).data("serviceuri");
                                                            var lat = $(this).data("lat");
                                                            var lon = $(this).data("lon");
                                                            var eventDesc = null;
                                                            map["eventsOnMap"].forEach(function (mapevt) {
                                                                if (mapevt["color1"] == feature["properties"]["color1"] && mapevt["color2"] == feature["properties"]["color2"]) {
                                                                    eventDesc = mapevt["desc"];
                                                                }
                                                            });
                                                            /*var doCreate = true;
                                                            gisLayersOnMap[eventDesc].getLayers().forEach(function(layer){
                                                                if( ( layer["feature"] && layer["feature"]["properties"]["serviceUri"] == serviceuri ) ||
                                                                    ( (!layer["feature"]) &&  layer["_latlng"]["lat"] == lat.toFixed(layer["_latlng"]["lat"].countDecimals()) && layer["_latlng"]["lng"] == lon.toFixed(layer["_latlng"]["lng"].countDecimals())  )){
                                                                    try { layer.closePopup(); } catch(e) {}
                                                                    layer.fire('click');
                                                                    doCreate=false;
                                                                }
                                                            });
                                                            if(!doCreate) return;												*/
                                                            for (var l = 0; l < gisLayersOnMap[eventDesc].getLayers().length; l++) {
                                                                var layer = gisLayersOnMap[eventDesc].getLayers()[l];
                                                                if ((layer["feature"] && layer["feature"]["properties"]["serviceUri"] == serviceuri) ||
                                                                    ((!layer["feature"]) && layer["_latlng"]["lat"] == lat.toFixed(layer["_latlng"]["lat"].countDecimals()) && layer["_latlng"]["lng"] == lon.toFixed(layer["_latlng"]["lng"].countDecimals()))) {
                                                                    try {
                                                                        layer.closePopup();
                                                                    } catch (e) {
                                                                    }
                                                                    layer.fire('click');
                                                                    console.log("click");
                                                                    return;
                                                                }
                                                            }
                                                            $.getJSON("<?= $superServiceMapProxy ?>/api/v1?serviceUri=" + encodeURIComponent(serviceuri), function (stopdata) {
                                                                var newFeature = stopdata["BusStop"]["features"][0];
                                                                newFeature["properties"]["color1"] = feature["properties"]["color1"];
                                                                newFeature["properties"]["color2"] = feature["properties"]["color2"];
                                                                newFeature["properties"]["pinattr"] = feature["properties"]["pinattr"];
                                                                newFeature["properties"]["pincolor"] = feature["properties"]["pincolor"];
                                                                newFeature["properties"]["symbolcolor"] = feature["properties"]["symbolcolor"];
                                                                var newMarker = gisPrepareCustomMarker(newFeature, {
                                                                    "lng": newFeature["geometry"]["coordinates"][0],
                                                                    "lat": newFeature["geometry"]["coordinates"][1]
                                                                });
                                                                newMarker.addTo(gisLayersOnMap[eventDesc]);
                                                                newMarker.fire('click');
                                                            });
                                                        });
                                                    });

                                                });

                                            });

                                        });

                                    });
                                });
                            }

                            if (hasRealTime) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').show();
                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').trigger("click");
                                $('#<?= $_REQUEST['name_w'] ?>_map span.popupLastUpdate[data-id="' + latLngId + '"]').html(measuredTime);
                            } else {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').hide();
                            }

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDetailsBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDetailsBtn[data-id="' + latLngId + '"]').click(function () {
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapDetailsContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDescriptionBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDescriptionBtn[data-id="' + latLngId + '"]').click(function () {
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapDescContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').click(function () {
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapContactsContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').click(function () {
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapTplContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                                if ($("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToTrips button").is(":visible")) {
                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToTrips button").click();
                                }
                                if ($("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToRoutes button").is(":visible")) {
                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToRoutes button").click();
                                }
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplTmtblBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplTmtblBtn[data-id="' + latLngId + '"]').click(function () {
                                //console.log("clicked "+'#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplTmtblBtn[data-id="' + latLngId + '"]');
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapTplTmtblContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                                var tmtblBtn = $(this);
                                var tmtblMarkup = "";
                                $.getJSON('<?= $whatifmdtendpt ?>?stop=' + encodeURIComponent(serviceProperties['serviceUri']) + "&list=graphs", function (graphs) {
                                    var pAgency = graphs.join();
                                    $.getJSON('<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&stop=' + encodeURIComponent(serviceProperties['serviceUri']) + "&list=timetable", function (timetable) {
                                        //console.log(timetable);
                                        timetable.forEach(function (entry, rownum) {
                                            //console.log(entry);
                                            tmtblMarkup += "<p class=\"tplpoi_tmtblrow\"><button data-r=\"" + entry["route"].replace(/[^a-zA-Z0-9]/g, "") + "\" data-t=\"" + entry["trip"] + "\" data-n=\"" + rownum + "\" style=\"width:100%; background-color:#" + entry["bgcolor"] + "; color:#" + entry["fgcolor"] + "\"><p style=\"font-size:larger; font-weight:bold; margin:0px; padding:0px; text-align:left;\">" + (entry["departure"] ? entry["departure"] : entry["arrival"]).substring(0, 5) + "&nbsp;<span style=\"font-size:larger; border:thin solid #" + entry["fgcolor"] + ";\">" + entry["number"] + "</span>&nbsp;" + entry["headsign"] + "</p><p class=\"nextstops\" style=\"margin:0px; padding:0px; font-weight:normal; text-align:left;\"></p></button></p>";
                                        });
                                        if (timetable.length == 0) {
                                            tmtblMarkup += "<p class=\"tplpoi_tmtblrow\">The timetable is currently not available for this stop.</p>";
                                        }
                                        tmtblBtn.parent().siblings('div.recreativeEventMapTplTmtblContainer').empty();
                                        tmtblBtn.parent().siblings('div.recreativeEventMapTplTmtblContainer').append($(tmtblMarkup));
                                        timetable.forEach(function (entry, rownum) {
                                            var theTripUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&trip=' + encodeURIComponent(entry["trip_uri"]) + "&list=stops";
                                            var n = rownum;
                                            $.getJSON(theTripUrl, function (alltripstops) {
                                                //console.log(alltripstops);
                                                var span = $("p.tplpoi_tmtblrow button[data-t=\"" + entry["trip"] + "\"][data-n=\"" + n + "\"] p.nextstops");
                                                var spanMarkup = "";
                                                var isNext = false;
                                                alltripstops.forEach(function (stop) {
                                                    if (isNext) {
                                                        if (-1 == spanMarkup.indexOf(stop["arrival"].substring(0, 5) + "&nbsp;" + stop["name"].replaceAll(" ", "&nbsp;") + "&nbsp;&bull; ")) {
                                                            spanMarkup += stop["arrival"].substring(0, 5) + "&nbsp;" + stop["name"].replaceAll(" ", "&nbsp;") + "&nbsp;&bull; ";
                                                        }
                                                    }
                                                    if (stop["stop_uri"] == serviceProperties['serviceUri']) {
                                                        isNext = true;
                                                    }
                                                });
                                                if (!spanMarkup) {
                                                    spanMarkup += "This is the terminus stop, the trip does not continue further.&nbsp;&bull; ";
                                                }
                                                // console.log("Appending "+spanMarkup.substring(0,spanMarkup.length-13));
                                                span.append(spanMarkup.substring(0, spanMarkup.length - 13));
                                            });
                                        });
                                        $(".tplpoi_tmtblrow button").click(function () {
                                            //console.log($(this).data("r")); console.log($(this).data("t"));
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').click();
                                            var t = $(this).data("t");
                                            var observer = new MutationObserver(function (mutations, observer) {
                                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').parent().siblings('div.recreativeEventMapTplContainer').find('.tplpoi_tripsDivInRoute .tplpoi_wifstptrp button[data-tripkey="' + t + '"]').click();
                                                observer.disconnect();
                                            });
                                            observer.observe($('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').parent().siblings('div.recreativeEventMapTplContainer')[0], { childList: true });
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').parent().siblings('div.recreativeEventMapTplContainer').find("button.polyin_" + $(this).data("r")).click();
                                        });
                                    });
                                });
                            });

                            if (hasRealTime) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').trigger("click");
                            }

                            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').css("background", color2);
                            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').css("border", "none");
                            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').css("color", "black");

                            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').focus(function () {
                                $(this).css("outline", "0");
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map input.gisPopupKeepDataCheck[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map input.gisPopupKeepDataCheck[data-id="' + latLngId + '"]').click(function () {
                                if ($(this).attr("data-keepData") === "false") {
                                    $(this).attr("data-keepData", "true");
                                } else {
                                    $(this).attr("data-keepData", "false");
                                }
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').off('mouseenter');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').off('mouseleave');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-id="' + latLngId + '"]').hover(function () {
                                if ($(this).attr("data-lastDataClicked") === "false") {
                                    $(this).css("background", color1);
                                    $(this).css("background", "-webkit-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                    $(this).css("background", "background: -o-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                    $(this).css("background", "background: -moz-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                    $(this).css("background", "background: linear-gradient(to left, " + color1 + ", " + color2 + ")");
                                    $(this).css("font-weight", "bold");
                                }

                                var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                var colIndex = $(this).parent().index();
                                //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html();
                                var title = $(this).parents("tr").find("td").eq(0).html();

                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "mouseOverLastDataFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i],
                                        value: $(this).attr("data-lastValue"),
                                        color1: $(this).attr("data-color1"),
                                        color2: $(this).attr("data-color2"),
                                        widgetTitle: title
                                    });
                                }
                            },
                                function () {
                                    if ($(this).attr("data-lastDataClicked") === "false") {
                                        $(this).css("background", color2);
                                        $(this).css("font-weight", "normal");
                                    }
                                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');

                                    for (var i = 0; i < widgetTargetList.length; i++) {
                                        $.event.trigger({
                                            type: "mouseOutLastDataFromExternalContentGis_" + widgetTargetList[i],
                                            eventGenerator: $(this),
                                            targetWidget: widgetTargetList[i],
                                            value: $(this).attr("data-lastValue"),
                                            color1: $(this).attr("data-color1"),
                                            color2: $(this).attr("data-color2")
                                        });
                                    }
                                });

                            //Disabilitiamo i 4Hours se last update più vecchio di 4 ore
                            if (rtDataAgeSec > 14400) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="4/HOUR"]').attr("data-disabled", "true");
                                //Disabilitiamo i 24Hours se last update più vecchio di 24 ore
                                if (rtDataAgeSec > 86400) {
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="1/DAY"]').attr("data-disabled", "true");
                                    //Disabilitiamo i 7 days se last update più vecchio di 7 days
                                    if (rtDataAgeSec > 604800) {
                                        $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="7/DAY"]').attr("data-disabled", "true");
                                        //Disabilitiamo i 30 days se last update più vecchio di 30 days
                                        //if(rtDataAgeSec > 18144000)
                                        if (rtDataAgeSec > 2592000) {
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="30/DAY"]').attr("data-disabled", "true");
                                            //Disabilitiamo i 6 months se last update più vecchio di 180 days
                                            if (rtDataAgeSec > 15552000) {
                                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="180/DAY"]').attr("data-disabled", "true");
                                                //Disabilitiamo i 1 year se last update più vecchio di 365 days
                                                if (rtDataAgeSec > 31536000) {
                                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="365/DAY"]').attr("data-disabled", "true");
                                                    //Disabilitiamo i 2 year se last update più vecchio di 730 days
                                                    if (rtDataAgeSec > 31536000 * 2) {
                                                        $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="730/DAY"]').attr("data-disabled", "true");
                                                        //Disabilitiamo i 10 year se last update più vecchio di 730 days
                                                        if (rtDataAgeSec > 315360000) {
                                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="3650/DAY"]').attr("data-disabled", "true");

                                                        } else {
                                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="3650/DAY"]').attr("data-disabled", "false");
                                                        }

                                                    } else {
                                                        $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="730/DAY"]').attr("data-disabled", "false");
                                                    }
                                                } else {
                                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="365/DAY"]').attr("data-disabled", "false");
                                                }
                                            } else {
                                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="180/DAY"]').attr("data-disabled", "false");
                                            }
                                        } else {
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="30/DAY"]').attr("data-disabled", "false");
                                        }
                                    } else {
                                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen button.timeTrendBtn[data-id="' + latLngId + '"][data-range="7/DAY"]').attr("data-disabled", "false");
                                    }
                                } else {
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="1/DAY"]').attr("data-disabled", "false");
                                }
                            } else {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="4/HOUR"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="1/DAY"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="7/DAY"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="30/DAY"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="180/DAY"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="365/DAY"]').attr("data-disabled", "false");
                            }

                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').off('mouseenter');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').off('mouseleave');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"]').hover(function () {
                                if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                    $(this).css("background-color", "#e6e6e6");
                                    $(this).off("hover");
                                    $(this).off("click");
                                } else {
                                    if ($(this).attr("data-timeTrendClicked") === "false") {
                                        $(this).css("background", color1);
                                        $(this).css("background", "-webkit-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                        $(this).css("background", "background: -o-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                        $(this).css("background", "background: -moz-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                        $(this).css("background", "background: linear-gradient(to left, " + color1 + ", " + color2 + ")");
                                        $(this).css("font-weight", "bold");
                                    }

                                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                    //var colIndex = $(this).parent().index();
                                    //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html() + " - " + $(this).attr("data-range-shown");
                                    var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");

                                    for (var i = 0; i < widgetTargetList.length; i++) {
                                        $.event.trigger({
                                            type: "mouseOverTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                            eventGenerator: $(this),
                                            targetWidget: widgetTargetList[i],
                                            value: $(this).attr("data-lastValue"),
                                            color1: $(this).attr("data-color1"),
                                            color2: $(this).attr("data-color2"),
                                            widgetTitle: title
                                        });
                                    }
                                }
                            },
                                function () {
                                    if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                        $(this).css("background-color", "#e6e6e6");
                                        $(this).off("hover");
                                        $(this).off("click");
                                    } else {
                                        if ($(this).attr("data-timeTrendClicked") === "false") {
                                            $(this).css("background", color2);
                                            $(this).css("font-weight", "normal");
                                        }

                                        var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                        for (var i = 0; i < widgetTargetList.length; i++) {
                                            $.event.trigger({
                                                type: "mouseOutTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                                eventGenerator: $(this),
                                                targetWidget: widgetTargetList[i],
                                                value: $(this).attr("data-lastValue"),
                                                color1: $(this).attr("data-color1"),
                                                color2: $(this).attr("data-color2")
                                            });
                                        }
                                    }
                                });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-id=' + latLngId + ']').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-id=' + latLngId + ']').click(function (event) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').each(function (i) {
                                    $(this).css("background", $(this).attr("data-color2"));
                                });
                                $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').css("font-weight", "normal");
                                $(this).css("background", $(this).attr("data-color1"));
                                $(this).css("font-weight", "bold");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').attr("data-lastDataClicked", "false");
                                $(this).attr("data-lastDataClicked", "true");
                                var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                var colIndex = $(this).parent().index();
                                var title = $(this).parents("tr").find("td").eq(0).html();

                                if ($(this).attr("data-value_unit") == "SURI") {
                                    let q = "";
                                    let qType = "";
                                    let passData = {};
                                    let widTargets = "";
                                    if ($(this).attr("data-lastValue").includes("http://www.disit.org/km4city")) {
                                        qType = "Default";
                                        q = "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + encodeServiceUri($(this).attr("data-lastValue")) + "&format=json&fullCount=false";
                                        for (var i = 0; i < widgetTargetList.length; i++) {
                                            if (widTargets == "") {
                                                widTargets = widgetTargetList[i];
                                            } else {
                                                widTargets = widTargets + "," + widgetTargetList[i];
                                            }
                                        }
                                        passData.desc = "SURI_" + $(this).attr("data-field");
                                        passData.query = q;
                                        passData.queryType = qType;
                                        passData.color1 = $(this).attr("data-color1");
                                        passData.color2 = $(this).attr("data-color2");
                                        passData.targets = widTargets;
                                        passData.fromSURI = true

                                        $.event.trigger({
                                            type: "addSelectorPin",
                                            target: map.mapName,
                                            passedData: passData,
                                            // passedParams: passedParams
                                        });
                                    } else if ($(this).attr("data-lastValue").includes("http://") || $(this).attr("data-lastValue").includes("https://")) {
                                        window.open($(this).attr("data-lastValue"), '_blank');
                                    } else {
                                        qType = "MyPOI";
                                        q = $(this).attr("data-lastValue");
                                    }

                                }

                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "showLastDataFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i],
                                        value: $(this).attr("data-lastValue"),
                                        color1: $(this).attr("data-color1"),
                                        color2: $(this).attr("data-color2"),
                                        widgetTitle: title,
                                        field: $(this).attr("data-field"),
                                        serviceUri: $(this).attr("data-serviceUri"),
                                        marker: markersCache["" + $(this).attr("data-id") + ""],
                                        mapRef: map.defaultMapRef,
                                        fake: $(this).attr("data-fake"),
                                        fakeId: $(this).attr("data-fakeId")
                                    });
                                }

                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"]').each(function (i) {
                                    if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                        $(this).css("background-color", "#e6e6e6");
                                        $(this).off("hover");
                                        $(this).off("click");
                                    }
                                });

                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').click(function (event) {
                                if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                    $(this).css("background-color", "#e6e6e6");
                                    $(this).off("hover");
                                    $(this).off("click");
                                } else {
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').css("background", $(this).attr("data-color2"));
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').css("font-weight", "normal");
                                    $(this).css("background", $(this).attr("data-color1"));
                                    $(this).css("font-weight", "bold");
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').attr("data-timeTrendClicked", "false");
                                    $(this).attr("data-timeTrendClicked", "true");
                                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                    var colIndex = $(this).parent().index();
                                    var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");
                                    var lastUpdateTime = $(this).parents('div.recreativeEventMapContactsContainer').find('span.popupLastUpdate').html();

                                    var now = new Date();
                                    var lastUpdateDate = new Date(lastUpdateTime);
                                    var diff = parseFloat(Math.abs(now - lastUpdateDate) / 1000);
                                    var range = $(this).attr("data-range");

                                    for (var i = 0; i < widgetTargetList.length; i++) {
                                        $.event.trigger({
                                            type: "showTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                            eventGenerator: $(this),
                                            targetWidget: widgetTargetList[i],
                                            range: range,
                                            color1: $(this).attr("data-color1"),
                                            color2: $(this).attr("data-color2"),
                                            widgetTitle: title,
                                            field: $(this).attr("data-field"),
                                            serviceUri: $(this).attr("data-serviceUri"),
                                            marker: markersCache["" + $(this).attr("data-id") + ""],
                                            mapRef: map.defaultMapRef,
                                            fake: false
                                            //fake: $(this).attr("data-fake")
                                        });
                                    }

                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"]').each(function (i) {
                                        if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                            $(this).css("background-color", "#e6e6e6");
                                            $(this).off("hover");
                                            $(this).off("click");
                                        }
                                    });
                                }
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"]').each(function (i) {
                                if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                    $(this).css("background-color", "#e6e6e6");
                                    $(this).off("hover");
                                    $(this).off("click");
                                }
                            });

                            map.defaultMapRef.off('popupclose');
                            map.defaultMapRef.on('popupclose', function (closeEvt) {
                                var popupContent = $('<div></div>');
                                popupContent.html(closeEvt.popup._content);

                                if (popupContent.find("button.lastValueBtn").length > 0) {
                                    var widgetTargetList = popupContent.find("button.lastValueBtn").eq(0).attr("data-targetWidgets").split(',');

                                    if (($('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-lastDataClicked=true]').length > 0) && ($('input.gisPopupKeepDataCheck').attr('data-keepData') === "false")) {
                                        for (var i = 0; i < widgetTargetList.length; i++) {
                                            $.event.trigger({
                                                type: "restoreOriginalLastDataFromExternalContentGis_" + widgetTargetList[i],
                                                eventGenerator: $(this),
                                                targetWidget: widgetTargetList[i],
                                                value: $(this).attr("data-lastValue"),
                                                color1: $(this).attr("data-color1"),
                                                color2: $(this).attr("data-color2")
                                            });
                                        }
                                    }

                                    if (($('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-timeTrendClicked=true]').length > 0) && ($('input.gisPopupKeepDataCheck').attr('data-keepData') === "false")) {
                                        for (var i = 0; i < widgetTargetList.length; i++) {
                                            $.event.trigger({
                                                type: "restoreOriginalTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                                eventGenerator: $(this),
                                                targetWidget: widgetTargetList[i]
                                            });
                                        }
                                    }
                                }
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map div.leaflet-popup').off('click');

                        },
                        error: function (errorData) {
                            console.log("Error in data retrieval");
                            console.log(JSON.stringify(errorData));
                            var serviceProperties = feature.properties;

                            var underscoreIndex = serviceProperties.serviceType.indexOf("_");
                            var serviceClass = serviceProperties.serviceType.substr(0, underscoreIndex);
                            var serviceSubclass = serviceProperties.serviceType.substr(underscoreIndex);
                            serviceSubclass = serviceSubclass.replace(/_/g, " ");

                            popupText = '<h3 class="gisPopupTitle">' + serviceProperties.name + '</h3>' +
                                '<p><b>Typology: </b>' + serviceClass + " - " + serviceSubclass + '</p>' +
                                '<p><i>Data are limited due to an issue in their retrieval</i></p>';

                            event.target.bindPopup(popupText, {
                                offset: [15, 0],
                                minWidth: 215,
                                maxWidth: 600
                            }).openPopup();
                        }
                    });
                }

            });

            return marker;
        }
        function haversineDistance(lat1, lon1, lat2, lon2, R=6371) {
            function toRad(x) {
                return x * Math.PI / 180;
            }

            var x1 = lat2 - lat1;
            var dLat = toRad(x1);
            var x2 = lon2 - lon1;
            var dLon = toRad(x2)
            var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            var d = R * c;

            return d; //in km
        }

        function setServiceUrl(org, bounds) {
            let sUrl = null;
            lat = bounds.lat;
            lng = bounds.lng;
            let routing = JSON.parse(org.ghRouting);
            //console.log(routing);
            if (routing) {
                ghoptions = routing.length;
                //console.log(ghoptions);
                for (let i = 0; i < ghoptions; i++) {
                    let routing_lat = routing[i].centreLatLng[0];
                    let routing_lng = routing[i].centreLatLng[1];
                    let routing_dist = routing[i].dist;
                    let routing_ghUrl = routing[i].ghUrl;
                    //console.log("havdist");
                    //console.log(haversineDistance(lat,lng,routing_lat,routing_lng));
                    if (haversineDistance(lat, lng, routing_lat, routing_lng) < routing_dist) {
                        sUrl = routing_ghUrl + "route";
                        //console.log("sUrl");
                        //console.log(sUrl);
                    }
                }
            }
            return sUrl;
        }

        function encodeHTMLEntities(text) {
            var textArea = document.createElement('textarea');
            textArea.innerText = text;
            return textArea.innerHTML;
        }

        function triggerEventOnIotApp(map, message) {

            var data = {
                "msgType": "SendToEmitter",
                "widgetUniqueName": widgetName,
                "value": message,
                "inputName": nodeRedInputName,
                //   "dashboardId": <? $_REQUEST['id_dashboard'] ?>,
                "username": $('#authForm #hiddenUsername').val(),
                "nrInputId": nrInputId
            };
            var webSocket = Window.webSockets[widgetName];
            webSocket.ackReceived = false;
            webSocket.onAck = function (data) {
                console.log(widgetName + " SUCCESS ackReceived:" + webSocket.ackReceived)
                requestComplete = true;
                //    clearInterval(setUpdatingMsgInterval);
                switch (data.result) {
                    case "insertQueryKo":
                        //    showUpdateResult("DB KO");
                        console.log("DB KO on Insert");
                        break;

                    case "updateBlockKo":
                        //    showUpdateResult("Device KO");
                        console.log("Device KO");
                        break;

                    case "updateBlockAndUpdateQueryKo":
                        //    showUpdateResult("DB and device KO");
                        console.log("DB and device KO");
                        break;

                    case "updateQueryKo":
                        //    showUpdateResult("DB KO");
                        console.log("DB KO on Update");
                        break;

                    case "Ok":
                        //    showUpdateResult("Device OK");
                        console.log("Device OK");
                        break;
                }
            }
            console.log(widgetName + " SEND ackReceived:" + webSocket.ackReceived)
            if (webSocket.readyState == webSocket.OPEN) {
                webSocket.send(JSON.stringify(data));
                webSocket.timeout = setTimeout(function () {
                    if (!webSocket.ackReceived) {
                        console.log(widgetName + " ERR1 ackReceived:" + webSocket.ackReceived)
                        requestComplete = true;
                        //   clearInterval(setUpdatingMsgInterval);
                        //   showUpdateResult("API KO");
                        console.log("Update value KO");
                    }
                }, 60000)
            } else {
                console.log(widgetName + " ERR1 socket not OPEN");
                requestComplete = true;
                //    clearInterval(setUpdatingMsgInterval);
                //    showUpdateResult("API KO");
                console.log("Update value KO");
            }


        }

        function onEachFeature(feature, layer) {
            //console.log(layer);

            /*var dataObj = {};

            dataObj.lat = layer.feature.geometry.coordinates[1];
            dataObj.lng = layer.feature.geometry.coordinates[0];
            dataObj.eventType = "selectorEvent";

            map.eventsOnMap.push(dataObj);
            console.log(map.eventsOnMap);*/

        }

        function onEachFeatureSpiderify(feature, layer) {
            oms.addMarker(layer);
        }

        //Funzione di associazione delle icone alle feature e preparazione popup per la mappa GIS
        function gisPrepareCustomMarker(feature, latlng) {
            if (feature.properties.altViewMode == "CustomPin" || feature.properties.altViewMode == "DynamicCustomPin") {
                //   if (feature.properties.serviceType == "GovernmentOffice_Civil_registry") {
                if (wsConnect != null && altViewMode == "DynamicCustomPin") {
                    // Subscribe device to new WS
                    var updateResponse = subscribeWsDevice(feature.properties.serviceUri, bubbleSelectedMetric[currentCustomSvgLayer], currentCustomSvgLayer, feature.properties.isMobile);
                }
                countSvgCnt++;
                let svgContainer = null;
                let tplPath = feature.properties.iconFilePath;
                svgContainer = $('<div id="' + widgetName + '_svgCtn' + countSvgCnt + '">');
                $("#" + widgetName).append(svgContainer);
                if (feature.properties.lastValue != null) {
                    buildSvgIcon(tplPath, feature.properties.lastValue[bubbleSelectedMetric[currentCustomSvgLayer]], 'error', null, svgContainer, widgetName, "map", countSvgCnt, totalSvgCnt, currentCustomSvgLayer, svgContainerArray, false);
                } else if (feature.properties.values != null) {
                    buildSvgIcon(tplPath, feature.properties.values[bubbleSelectedMetric[currentCustomSvgLayer]], 'error', null, svgContainer, widgetName, "map", countSvgCnt, totalSvgCnt, currentCustomSvgLayer, svgContainerArray, false);
                }
            }
            if (feature.properties.pinattr != "pin" && feature.properties.altViewMode != "CustomPin" && feature.properties.altViewMode != "DynamicCustomPin") {
                var mapPinImg = '../img/gisMapIcons/' + feature.properties.serviceType + '.png';
                if ("TransferServiceAndRenting_BusStop" == feature.properties.serviceType) {
                    if (feature.properties.hasOwnProperty("busStopCategory")) {
                        mapPinImg = '../img/gisMapIcons/' + feature.properties.busStopCategory + '.png';
                    }
                    else {
                        if (feature.properties.agency.includes("ATAF") || feature.properties.agency.includes("GEST")) {
                            mapPinImg = '../img/gisMapIcons/' + feature.properties.serviceType + '_Urban.png'
                        }
                        else {
                            mapPinImg = '../img/gisMapIcons/' + feature.properties.serviceType + '_Suburban.png'
                        }
                    }
                }
                var markerIcon = markerIcon = L.icon({
                    iconUrl: mapPinImg,
                    iconAnchor: [16, 37]
                });
            } else {

                var filePinPath = "../img/outputPngIcons/pin-generico.png";
                if (feature.properties.iconFilePath != null && feature.properties.altViewMode != "CustomPin" && feature.properties.altViewMode != "DynamicCustomPin") {
                    if (feature.properties.iconFilePath.includes("/nature/")) {
                        filePinPath = feature.properties.iconFilePath.split("/nature/")[1].split(".svg")[0];
                    } else if (feature.properties.iconFilePath.includes("/subnature/")) {
                        filePinPath = feature.properties.iconFilePath.split("/subnature/")[1].split(".svg")[0];
                    } else if (feature.properties.iconFilePath.includes("/hlt/")) {
                        filePinPath = feature.properties.iconFilePath.split("/hlt/")[1].split(".svg")[0];
                    }

                    if (feature.properties.pinattr == "pin" && feature.properties.pincolor == "Default") {
                        var newIconPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png';
                    } else {
                        var pinColor = feature.properties.symbolcolor;
                        if (pinColor.includes("#")) {
                            pinColor = pinColor.split("#")[1];
                        }
                        //    var newIconPath = '../img/outputPngIcons/' + feature.properties.serviceType + '/' + feature.properties.serviceType + '_' + pinColor + '_' + widgetName.split("_widget")[1] + '.png';
                        var newIconPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_' + pinColor + '.png';

                        if (iconsFileBuffer[newIconPath] == null) {
                            if (!UrlExists(newIconPath)) {
                                iconsFileBuffer[newIconPath] = false;
                                if (!UrlExists('../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png')) {
                                    newIconPath = '../img/outputPngIcons/generic/generic_' + pinColor + '.png';
                                    if (!UrlExists(newIconPath)) {
                                        iconsFileBuffer[newIconPath] = false;
                                        newIconPath = '../img/outputPngIcons/pin-generico.png';
                                    } else {
                                        iconsFileBuffer[newIconPath] = true;
                                    }
                                } else {
                                    newIconPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png';
                                    iconsFileBuffer[newIconPath] = true;
                                }
                            } else {
                                iconsFileBuffer[newIconPath] = true;
                            }
                        } else {
                            if (iconsFileBuffer[newIconPath] === false) {
                                if (!UrlExists('../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png')) {
                                    if (iconsFileBuffer['../img/outputPngIcons/generic/generic_' + pinColor + '_' + '.png'] === false) {
                                        newIconPath = '../img/outputPngIcons/pin-generico.png';
                                    } else {
                                        newIconPath = '../img/outputPngIcons/generic/generic_' + pinColor + '.png';
                                    }
                                } else {
                                    newIconPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png';
                                    iconsFileBuffer[newIconPath] = true;
                                }
                            } else {
                                newIconPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_' + pinColor + '.png';
                            }
                        }
                    }
                } else {
                    var newIconPath = '../img/outputPngIcons/pin-generico.png';
                }
                //   iconsFileBuffer.push(newIconPath);

                //   var mapPinImg = '../img/gisMapIconsNew/Accommodation.png';
                var markerIcon = L.icon({
                    iconUrl: newIconPath,
                    iconAnchor: [16, 37]
                });

            }

            var marker = new L.Marker(latlng, { icon: markerIcon });

            if ("BusStop" == feature.properties.typeLabel) {
                marker = new L.Marker(latlng, { icon: markerIcon, title: feature.properties.typeLabel + " " + feature.properties.agency + " " + feature.properties.name });
            }

            var latLngKey = latlng.lat + "" + latlng.lng;

            latLngKey = latLngKey.replace(".", "");
            latLngKey = latLngKey.replace(".", "");//Incomprensibile il motivo ma con l'espressione regolare /./g non funziona
            markersCache["" + latLngKey + ""] = marker;

            marker.on('mouseover', function (event) {
                if (feature.properties.deviceName != null && tooltipOnHover === true) {
                    let tooltipString = "";
                    if (feature.properties.deviceName.includes("building") || feature.properties.deviceName.includes("floor")) {
                        if (feature.properties.deviceName.split("_").length > 2) {
                            tooltipString = "Floor " + feature.properties.deviceName.split("_")[1] + "_" + feature.properties.deviceName.split("_")[2];
                        } else {
                            tooltipString = "Building " + feature.properties.deviceName.split("_")[1];
                        }
                    } else {
                        tooltipString = feature.properties.deviceName;
                    }
                    this.bindTooltip(tooltipString);
                    event.target.openTooltip();
                }
                if (feature.properties.altViewMode != "CustomPin" && feature.properties.altViewMode != "DynamicCustomPin") {
                    if (feature.properties.pinattr != "pin") {
                        var hoverImg = '../img/gisMapIcons/over/' + feature.properties.serviceType + '_over.png';
                        if ("TransferServiceAndRenting_BusStop" == feature.properties.serviceType) {
                            if (feature.properties.hasOwnProperty("busStopCategory")) {
                                hoverImg = '../img/gisMapIcons/over/' + feature.properties.busStopCategory + '_over.png';
                            }
                            else {
                                if (feature.properties.agency.includes("ATAF") || feature.properties.agency.includes("GEST")) {
                                    hoverImg = '../img/gisMapIcons/over/' + feature.properties.serviceType + '_Urban_over.png'
                                }
                                else {
                                    hoverImg = '../img/gisMapIcons/over/' + feature.properties.serviceType + '_Suburban_over.png'
                                }
                            }
                        }
                        var hoverIcon = L.icon({
                            iconUrl: hoverImg
                        });
                        event.target.setIcon(hoverIcon);
                    } else {

                        var filePinPath = "../img/outputPngIcons/pin-generico.png";
                        if (feature.properties.iconFilePath != null) {
                            if (feature.properties.iconFilePath.includes("/nature/")) {
                                filePinPath = feature.properties.iconFilePath.split("/nature/")[1].split(".svg")[0];
                            } else if (feature.properties.iconFilePath.includes("/subnature/")) {
                                filePinPath = feature.properties.iconFilePath.split("/subnature/")[1].split(".svg")[0];
                            } else if (feature.properties.iconFilePath.includes("/hlt/")) {
                                filePinPath = feature.properties.iconFilePath.split("/hlt/")[1].split(".svg")[0];
                            }
                            var newIconOverPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '-over' + '.png';

                            if (iconsFileBuffer[newIconOverPath] == null) {
                                if (!UrlExists(newIconOverPath)) {
                                    iconsFileBuffer[newIconOverPath] = false;
                                    newIconOverPath = '../img/outputPngIcons/generic/generic-over' + '.png';
                                    if (!UrlExists(newIconOverPath)) {
                                        iconsFileBuffer[newIconOverPath] = false;
                                        newIconOverPath = '../img/outputPngIcons/pin-generico.png';
                                    } else {
                                        iconsFileBuffer[newIconOverPath] = true;
                                    }
                                } else {
                                    iconsFileBuffer[newIconOverPath] = true;
                                }
                            } else {
                                if (iconsFileBuffer[newIconOverPath] === false) {
                                    if (iconsFileBuffer['../img/outputPngIcons/generic/generic-over' + '.png'] === false) {
                                        newIconOverPath = '../img/outputPngIcons/pin-generico.png';
                                    } else {
                                        newIconOverPath = '../img/outputPngIcons/generic/generic-over' + '.png';
                                    }
                                } else {
                                    newIconOverPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '-over' + '.png';
                                }
                            }
                        } else {
                            var newIconOverPath = '../img/outputPngIcons/generic/generic-over' + '.png';
                        }

                        var hoverIcon = L.icon({
                            iconUrl: newIconOverPath,
                            iconAnchor: [16, 37]
                        });
                        event.target.setIcon(hoverIcon);

                    }
                    //    console.log("Mouse Over");
                }
            });

            marker.on('mouseout', function (event) {
                if (feature.properties.altViewMode != "CustomPin" && feature.properties.altViewMode != "DynamicCustomPin") {
                    if (feature.properties.pinattr != "pin") {
                        var outImg = '../img/gisMapIcons/' + feature.properties.serviceType + '.png';
                        if ("TransferServiceAndRenting_BusStop" == feature.properties.serviceType) {
                            if (feature.properties.hasOwnProperty("busStopCategory")) {
                                outImg = '../img/gisMapIcons/' + feature.properties.busStopCategory + '.png';
                            }
                            else {
                                if (feature.properties.agency.includes("ATAF") || feature.properties.agency.includes("GEST")) {
                                    outImg = '../img/gisMapIcons/' + feature.properties.serviceType + '_Urban.png'
                                }
                                else {
                                    outImg = '../img/gisMapIcons/' + feature.properties.serviceType + '_Suburban.png'
                                }
                            }
                        }
                        var outIcon = L.icon({
                            iconUrl: outImg
                        });
                        event.target.setIcon(outIcon);
                    } else {

                        var pinColor = feature.properties.symbolcolor;
                        if (pinColor.includes("#")) {
                            pinColor = pinColor.split("#")[1];
                        }

                        var filePinPath = "../img/outputPngIcons/pin-generico.png";
                        if (feature.properties.iconFilePath != null) {
                            if (feature.properties.iconFilePath.includes("/nature/")) {
                                filePinPath = feature.properties.iconFilePath.split("/nature/")[1].split(".svg")[0];
                            } else if (feature.properties.iconFilePath.includes("/subnature/")) {
                                filePinPath = feature.properties.iconFilePath.split("/subnature/")[1].split(".svg")[0];
                            } else if (feature.properties.iconFilePath.includes("/hlt/")) {
                                filePinPath = feature.properties.iconFilePath.split("/hlt/")[1].split(".svg")[0];
                            }

                            if (feature.properties.pinattr == "pin" && feature.properties.pincolor == "Default") {
                                var newIconOutPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png';
                            } else {
                                var newIconOutPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_' + pinColor + '.png';

                                if (iconsFileBuffer[newIconOutPath] == null) {
                                    if (!UrlExists(newIconOutPath)) {
                                        iconsFileBuffer[newIconOutPath] = false;
                                        if (!UrlExists('../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png')) {
                                            newIconOutPath = '../img/outputPngIcons/generic/generic_' + pinColor + '.png';
                                            if (!UrlExists(newIconOutPath)) {
                                                iconsFileBuffer[newIconOutPath] = false;
                                                newIconOutPath = '../img/outputPngIcons/pin-generico.png';
                                            } else {
                                                iconsFileBuffer[newIconOutPath] = true;
                                            }
                                        } else {
                                            newIconOutPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png';
                                            iconsFileBuffer[newIconOutPath] = true;
                                        }
                                    } else {
                                        iconsFileBuffer[newIconOutPath] = true;
                                    }
                                } else {
                                    if (iconsFileBuffer[newIconOutPath] === false) {
                                        if (!UrlExists('../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png')) {
                                            if (iconsFileBuffer['../img/outputPngIcons/generic/generic_' + pinColor + '.png'] === false) {
                                                newIconOutPath = '../img/outputPngIcons/pin-generico.png';
                                            } else {
                                                newIconOutPath = '../img/outputPngIcons/generic/generic_' + pinColor + '.png';
                                            }
                                        } else {
                                            newIconOutPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_default.png';
                                            iconsFileBuffer[newIconOutPath] = true;
                                        }
                                    } else {
                                        newIconOutPath = '../img/outputPngIcons/' + filePinPath + '/' + filePinPath + '_' + pinColor + '.png';
                                    }
                                }
                            }
                        } else {
                            var newIconOutPath = '../img/outputPngIcons/pin-generico.png';
                        }

                        var outIcon = L.icon({
                            iconUrl: newIconOutPath
                        });
                        event.target.setIcon(outIcon);

                        //    $(event.target.getElement()).children(0).children(0).children(0).find('path').attr("fill", "#2192c3");
                        //    $(event.target.getElement()).children(0).children(0)[1].outerHTML = '<img src="../img/widgetSelectorIconsPool/subnature/' + feature.properties.serviceType + '-white.svg" alt="" style="position: absolute; top:1px; left:5px; width: 22px; height: 22px;">';

                    }
                    //    console.log("Mouse OUT");
                }
            });

            marker.on('click', function (event) {
                //    map.defaultMapRef.off('moveend');
                if (feature.properties.deviceName != null) {
                    this.unbindTooltip(feature.properties.deviceName);
                } else if (feature.properties.name != null) {
                    this.unbindTooltip(feature.properties.name);
                }
                if (widgetParameters.mode && widgetParameters.mode == "ckeditor" && code) {
                    let i = 1;
                    if (localStorage.getItem("events") == null) {

                        var events = [];
                        events.push("MapMarkerClick1");
                        localStorage.setItem("events", JSON.stringify(events));
                    }
                    else {
                        var events = JSON.parse(localStorage.getItem("events"));
                        for (var e in events) {
                            if (events[e].slice(0, 9) == "MapMarker")
                                i = i + 1;
                        }
                        events.push("MapMarkerClick" + i);
                        localStorage.setItem("events", JSON.stringify(events));
                    }
                    let newId = "MapMarkerClick" + i;
                    $('#BIMenuCnt').append('<div id="' + newId + '" class="row" data-selected="false"></div>');
                    $('#' + newId).append('<div class="col-md-12 orgMenuSubItemCnt">' + newId + '</div>');
                    $('#' + newId).on("click", function () {
                        var widgets = JSON.parse(localStorage.getItem("widgets"));
                        var index = JSON.parse(localStorage.getItem("events")).indexOf(newId);
                        for (var w in widgets) {
                            if (widgets[w] != null) {
                                $('body').trigger({
                                    type: "reloadPreviousContent_" + widgets[w],
                                    index: index
                                });
                            }
                        }
                    });
                    $('#' + newId).mouseover(function () {
                        $('#' + newId).css('cursor', 'pointer');
                    });

                    var selectedData = {};
                    selectedData.event = "click";
                    selectedData.layers = [];
                    selectedData.layers[0] = marker.feature.properties;
                    if (connections != null) {
                        selectedData.connections = connections;
                    }
                    selectedDataJson = JSON.stringify(selectedData);

                    try {
                        execute_<?= $_REQUEST['name_w'] ?>(selectedDataJson);
                    } catch (e) {
                        console.log("Error in JS function from marker click on " + widgetName);
                    }
                }

                if (popupOnClick != null & popupOnClick === true) {
                    event.target.unbindPopup();
                    newpopup = null;
                    var popupText, realTimeData, measuredTime, rtDataAgeSec, targetWidgets, color1, color2 = null;
                    var urlToCall, fake, fakeId = null;

                    if (feature.properties.fake === 'true') {
                        urlToCall = "../serviceMapFake.php?getSingleGeoJson=true&singleGeoJsonId=" + feature.id;
                        fake = true;
                        fakeId = feature.id;
                    } else {
                        urlToCall = "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + encodeServiceUri(feature.properties.serviceUri) + "&format=json&fullCount=false";
                        fake = false;
                    }
                    console.log('event.target', event.target);
                    var latLngId = event.target.getLatLng().lat + "" + event.target.getLatLng().lng;
                    latLngId = latLngId.replace(".", "");
                    latLngId = latLngId.replace(".", "");//Incomprensibile il motivo ma con l'espressione regolare /./g non funziona

                    // TBD if(this.feature.properties.kpidata != null) { // MAKE MyKPI / MyPOI API CALL AND VISUALIZATION }

                    $.ajax({
                        url: urlToCall,
                        type: "GET",
                        data: {},
                        async: true,
                        dataType: 'json',
                        success: function (geoJsonServiceData) {
                            var fatherNode = null;
                            if (geoJsonServiceData.hasOwnProperty("BusStop")) {
                                fatherNode = geoJsonServiceData.BusStop;
                            } else {
                                if (geoJsonServiceData.hasOwnProperty("Sensor")) {
                                    fatherNode = geoJsonServiceData.Sensor;
                                } else {
                                    //Prevedi anche la gestione del caso in cui non c'è nessuna di queste tre, sennò il widget rimane appeso.
                                    fatherNode = geoJsonServiceData.Service;
                                }
                            }

                            var serviceProperties = fatherNode.features[0].properties;
                            var underscoreIndex = serviceProperties.serviceType.indexOf("_");
                            var serviceClass = serviceProperties.serviceType.substr(0, underscoreIndex);
                            var serviceSubclass = serviceProperties.serviceType.substr(underscoreIndex);
                            serviceSubclass = serviceSubclass.replace(/_/g, " ");

                            fatherNode.features[0].properties.targetWidgets = feature.properties.targetWidgets;
                            fatherNode.features[0].properties.color1 = feature.properties.color1;
                            fatherNode.features[0].properties.color2 = feature.properties.color2;
                            targetWidgets = feature.properties.targetWidgets;
                            color1 = feature.properties.color1;
                            color2 = feature.properties.color2;

                            //Popup nuovo stile uguali a quelli degli eventi ricreativi
                            popupText = '<h3 class="recreativeEventMapTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + serviceProperties.name + '</h3>';
                            if ((serviceProperties.serviceUri !== '') && (serviceProperties.serviceUri !== undefined) && (serviceProperties.serviceUri !== 'undefined') && (serviceProperties.serviceUri !== null) && (serviceProperties.serviceUri !== 'null')) {
                                popupText += '<div class="recreativeEventMapSubTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + '</div>';
                                //  popupText += '<div class="recreativeEventMapSubTitle">' + "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + '</div>';
                            }
                            popupText += '<div class="recreativeEventMapBtnContainer"><button data-id="' + latLngId + '" class="recreativeEventMapDetailsBtn recreativeEventMapBtn recreativeEventMapBtnActive" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Details</button><button data-id="' + latLngId + '" class="recreativeEventMapDescriptionBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Description</button><button data-id="' + latLngId + '" class="recreativeEventMapContactsBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">RT data</button>' + (geoJsonServiceData.hasOwnProperty("BusStop") ? '<button data-id="' + latLngId + '" class="recreativeEventMapTplTmtblBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">TIMETABLE</button><button data-id="' + latLngId + '" class="recreativeEventMapTplBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">BROWSE</button>' : '') + '</div>';

                            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDetailsContainer">';

                            popupText += '<table id="' + latLngId + '" class="gisPopupGeneralDataTable">';
                            //Intestazione
                            popupText += '<thead>';
                            popupText += '<th style="background: ' + color2 + '">Description</th>';
                            popupText += '<th style="background: ' + color2 + '">Value</th>';
                            popupText += '</thead>';

                            //Corpo
                            popupText += '<tbody>';

                            for (var featureKey in serviceProperties) {
                                if (serviceProperties.hasOwnProperty(featureKey)) {
                                    if (serviceProperties[featureKey] != null && serviceProperties[featureKey] !== '' && serviceProperties[featureKey] !== ' ' && featureKey !== 'targetWidgets' && featureKey !== 'color1' && featureKey !== 'color2' && featureKey !== 'realtimeAttributes') {
                                        if (!Array.isArray(serviceProperties[featureKey]) || (Array.isArray(serviceProperties[featureKey] && serviceProperties[featureKey].length > 0))) {
                                            popupText += '<tr><td>' + featureKey + '</td><td>' + serviceProperties[featureKey] + '</td></tr>';
                                        }
                                    }
                                }
                            }
                            if (nodeId != null && serviceProperties["serviceUri"] != null && serviceProperties["serviceUri"] != '') {
                                let eventJson = new Object();
                                eventJson.latitude = feature.geometry.coordinates[1];
                                eventJson.longitude = feature.geometry.coordinates[0];
                                eventJson.serviceUri = serviceProperties["serviceUri"];
                                currentValue = JSON.stringify(eventJson);
                                triggerEventOnIotApp(map.defaultMapRef, currentValue);
                            }

                            popupText += '</tbody>';
                            popupText += '</table>';

                            if (geoJsonServiceData.hasOwnProperty("BusStop")) {
                                popupText += '<div class="tplProgressBar" style="display:none; width:100%; height:1em; margin-top:1em; background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');"></div>';
                            }

                            popupText += '</div>';
                            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDescContainer">';

                            if ((serviceProperties.serviceUri !== '') && (serviceProperties.serviceUri !== undefined) && (serviceProperties.serviceUri !== 'undefined') && (serviceProperties.serviceUri !== null) && (serviceProperties.serviceUri !== 'null')) {
                                popupText += "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + "<br>";
                            }

                            if ((serviceProperties.serviceType !== '') && (serviceProperties.serviceType !== undefined) && (serviceProperties.serviceType !== 'undefined') && (serviceProperties.serviceType !== null) && (serviceProperties.serviceType !== 'null')) {
                                popupText += "Nature: " + serviceProperties.serviceType.split(/_(.+)/)[0] + "<br>";
                                popupText += "Subnature: " + serviceProperties.serviceType.split(/_(.+)/)[1] + "<br><br>";
                            }

                            if (serviceProperties.hasOwnProperty('description')) {
                                if ((serviceProperties.description !== '') && (serviceProperties.description !== undefined) && (serviceProperties.description !== 'undefined') && (serviceProperties.description !== null) && (serviceProperties.description !== 'null')) {
                                    popupText += serviceProperties.description + "<br>";
                                } else {
                                    popupText += "No description available";
                                }
                            } else {
                                popupText += 'No description available';
                            }

                            popupText += '</div>';

                            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapContactsContainer">';

                            var hasRealTime = false;

                            if (geoJsonServiceData.hasOwnProperty("realtime")) {
                                if (!jQuery.isEmptyObject(geoJsonServiceData.realtime)) {
                                    realTimeData = geoJsonServiceData.realtime;
                                    if (selectedMetrics != null) {
                                        realTimeData.head.vars = selectedMetrics;
                                    }
                                    popupText += '<div class="popupLastUpdateContainer centerWithFlex"><b>Last update:&nbsp;</b><span class="popupLastUpdate" data-id="' + latLngId + '"></span></div>';

                                    if ((serviceClass.includes("Emergency")) && (serviceSubclass.includes("First aid"))) {
                                        //Tabella ad hoc per First Aid
                                        popupText += '<table id="' + latLngId + '" class="psPopupTable">';
                                        var series = {
                                            "firstAxis": {
                                                "desc": "Priority",
                                                "labels": [
                                                    "Red code",
                                                    "Yellow code",
                                                    "Green code",
                                                    "Blue code",
                                                    "White code"
                                                ]
                                            },
                                            "secondAxis": {
                                                "desc": "Status",
                                                "labels": [],
                                                "series": []
                                            }
                                        };

                                        var dataSlot = null;

                                        measuredTime = realTimeData.results.bindings[0].measuredTime.value.replace("T", " ").replace("Z", "");

                                        for (var i = 0; i < realTimeData.results.bindings.length; i++) {
                                            if (realTimeData.results.bindings[i].state.value.indexOf("estinazione") > 0) {
                                                series.secondAxis.labels.push("Addressed");
                                            }

                                            if (realTimeData.results.bindings[i].state.value.indexOf("ttesa") > 0) {
                                                series.secondAxis.labels.push("Waiting");
                                            }

                                            if (realTimeData.results.bindings[i].state.value.indexOf("isita") > 0) {
                                                series.secondAxis.labels.push("In visit");
                                            }

                                            if (realTimeData.results.bindings[i].state.value.indexOf("emporanea") > 0) {
                                                series.secondAxis.labels.push("Observation");
                                            }

                                            if (realTimeData.results.bindings[i].state.value.indexOf("tali") > 0) {
                                                series.secondAxis.labels.push("Totals");
                                            }

                                            dataSlot = [];
                                            dataSlot.push(realTimeData.results.bindings[i].redCode.value);
                                            dataSlot.push(realTimeData.results.bindings[i].yellowCode.value);
                                            dataSlot.push(realTimeData.results.bindings[i].greenCode.value);
                                            dataSlot.push(realTimeData.results.bindings[i].blueCode.value);
                                            dataSlot.push(realTimeData.results.bindings[i].whiteCode.value);

                                            series.secondAxis.series.push(dataSlot);
                                        }

                                        var colsQt = parseInt(parseInt(series.firstAxis.labels.length) + 1);
                                        var rowsQt = parseInt(parseInt(series.secondAxis.labels.length) + 1);

                                        for (var i = 0; i < rowsQt; i++) {
                                            var newRow = $("<tr></tr>");
                                            var z = parseInt(parseInt(i) - 1);

                                            if (i === 0) {
                                                //Riga di intestazione
                                                for (var j = 0; j < colsQt; j++) {
                                                    if (j === 0) {
                                                        //Cella (0,0)
                                                        var newCell = $("<td></td>");

                                                        newCell.css("background-color", "transparent");
                                                    } else {
                                                        //Celle labels
                                                        var k = parseInt(parseInt(j) - 1);
                                                        var colLabelBckColor = null;
                                                        switch (k) {
                                                            case 0:
                                                                colLabelBckColor = "#ff0000";
                                                                break;

                                                            case 1:
                                                                colLabelBckColor = "#ffff00";
                                                                break;

                                                            case 2:
                                                                colLabelBckColor = "#66ff33";
                                                                break;

                                                            case 3:
                                                                colLabelBckColor = "#66ccff";
                                                                break;

                                                            case 4:
                                                                colLabelBckColor = "#ffffff";
                                                                break;
                                                        }

                                                        newCell = $("<td><span>" + series.firstAxis.labels[k] + "</span></td>");
                                                        newCell.css("font-weight", "bold");
                                                        newCell.css("background-color", colLabelBckColor);
                                                    }
                                                    newRow.append(newCell);
                                                }
                                            } else {
                                                //Righe dati
                                                for (var j = 0; j < colsQt; j++) {
                                                    k = parseInt(parseInt(j) - 1);
                                                    if (j === 0) {
                                                        //Cella label
                                                        newCell = $("<td>" + series.secondAxis.labels[z] + "</td>");
                                                        newCell.css("font-weight", "bold");
                                                    } else {
                                                        //Celle dati
                                                        newCell = $("<td>" + series.secondAxis.series[z][k] + "</td>");
                                                        if (i === (rowsQt - 1)) {
                                                            newCell.css('font-weight', 'bold');
                                                            switch (j) {
                                                                case 1:
                                                                    newCell.css('background-color', '#ffb3b3');
                                                                    break;

                                                                case 2:
                                                                    newCell.css('background-color', '#ffff99');
                                                                    break;

                                                                case 3:
                                                                    newCell.css('background-color', '#d9ffcc');
                                                                    break;

                                                                case 4:
                                                                    newCell.css('background-color', '#cceeff');
                                                                    break;

                                                                case 5:
                                                                    newCell.css('background-color', 'white');
                                                                    break;
                                                            }
                                                        }
                                                    }
                                                    newRow.append(newCell);
                                                }
                                            }
                                            popupText += newRow.prop('outerHTML');
                                        }

                                        popupText += '</table>';
                                    } else {
                                        //Tabella nuovo stile
                                        popupText += '<table id="' + latLngId + '" class="gisPopupTable">';

                                        //Intestazione
                                        popupText += '<thead>';
                                        popupText += '<th style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Description</th>';
                                        popupText += '<th style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Value</th>';
                                        popupText += '<th colspan="9" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Buttons</th>';
                                        popupText += '</thead>';

                                        //Corpo
                                        popupText += '<tbody>';
                                        var dataDesc, dataVal, dataLastBtn, data4HBtn, dataDayBtn, data7DayBtn,
                                            data30DayBtn, data6MonthsBtn, data1YearBtn, data2YearBtn, data10YearBtn,
                                            value_unit = null;
                                        if (realTimeData.head != null) {
                                            for (var i = 0; i < realTimeData.head.vars.length; i++) {
                                                if (realTimeData.results.bindings[0][realTimeData.head.vars[i]] !== null && realTimeData.results.bindings[0][realTimeData.head.vars[i]] !== undefined) {
                                                    if ((realTimeData.results.bindings[0][realTimeData.head.vars[i]]) && (realTimeData.results.bindings[0][realTimeData.head.vars[i]].value.trim() !== '') && (realTimeData.head.vars[i] !== null) && (realTimeData.head.vars[i] !== 'undefined')) {
                                                        if ((realTimeData.head.vars[i] !== 'updating') && (realTimeData.head.vars[i] !== 'measuredTime') && (realTimeData.head.vars[i] !== 'instantTime')) {
                                                            if (!realTimeData.results.bindings[0][realTimeData.head.vars[i]].value.includes('Not Available')) {
                                                                //realTimeData.results.bindings[0][realTimeData.head.vars[i]].value = '-';
                                                                /*   dataDesc = realTimeData.head.vars[i].replace(/([A-Z])/g, ' $1').replace(/^./, function (str) {
                                                                       return str.toUpperCase();
                                                                   });*/
                                                                dataDesc = realTimeData.head.vars[i];
                                                                dataVal = realTimeData.results.bindings[0][realTimeData.head.vars[i]].value;
                                                                if (serviceProperties.realtimeAttributes && serviceProperties.realtimeAttributes[realTimeData.head.vars[i]] && serviceProperties.realtimeAttributes[realTimeData.head.vars[i]].value_unit) {
                                                                    value_unit = serviceProperties.realtimeAttributes[realTimeData.head.vars[i]].value_unit;
                                                                }
                                                                if (dataVal.length > 50 && value_unit !== "SURI") {
                                                                    dataVal = '<div class="tooltipSuri">' + encodeHTMLEntities(dataVal).substring(0, 20) + '... <span class="tooltipSuriText">' + dataVal + '</span></div>';
                                                                }
                                                                if (value_unit == "SURI") {
                                                                    if (dataVal.includes("http://www.disit.org/km4city")) {
                                                                        dataVal = '<div class="tooltipSuri">[SURI id]<span class="tooltipSuriText">' + dataVal + '</span></div>';
                                                                    } else {
                                                                        dataVal = '<div class="tooltipSuri">[WEB Url]<span class="tooltipSuriText">' + dataVal + '</span></div>';
                                                                    }
                                                                }
                                                                if (dataVal.length > 50) {
                                                                    dataLastBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="lastValueBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-id="' + latLngId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-lastDataClicked="false" data-targetWidgets="' + targetWidgets + '" data-lastValue="' + (realTimeData.results.bindings[0][realTimeData.head.vars[i]].value).replace(/["]+/g, '') + '" data-color1="' + color1 + '" data-color2="' + color2 + '" data-value_unit="' + value_unit + '">Last</button></td>';
                                                                } else {
                                                                    dataLastBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="lastValueBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-id="' + latLngId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-lastDataClicked="false" data-targetWidgets="' + targetWidgets + '" data-lastValue="' + realTimeData.results.bindings[0][realTimeData.head.vars[i]].value + '" data-color1="' + color1 + '" data-color2="' + color2 + '" data-value_unit="' + value_unit + '">Last</button></td>';
                                                                }
                                                                data4HBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-id="' + latLngId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="4 Hours" data-range="4/HOUR" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">4h</button></td>';
                                                                dataDayBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="Day" data-range="1/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">24h</button></td>';
                                                                data7DayBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="7 days" data-range="7/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">7d</button></td>';
                                                                data30DayBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="30 days" data-range="30/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">30d</button></td>';
                                                                data6MonthsBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="6 months" data-range="180/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">6m</button></td>';
                                                                data1YearBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="1 year" data-range="365/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">1y</button></td>';
                                                                data2YearBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="2 year" data-range="730/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">2y</button></td>';
                                                                data10YearBtn = '<td><button style="width: 30px" data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="10 year" data-range="3650/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">10y</button></td>';
                                                                popupText += '<tr><td>' + dataDesc + '</td><td>' + dataVal + '</td>' + dataLastBtn + data4HBtn + dataDayBtn + data7DayBtn + data30DayBtn + data6MonthsBtn + data1YearBtn + data2YearBtn + data10YearBtn + '</tr>';
                                                            }
                                                        } else {
                                                            measuredTime = realTimeData.results.bindings[0][realTimeData.head.vars[i]].value.replace("T", " ");
                                                            var now = new Date();
                                                            var measuredTimeDate = new Date(measuredTime);
                                                            rtDataAgeSec = Math.abs(now - measuredTimeDate) / 1000;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        popupText += '</tbody>';
                                        popupText += '</table>';
                                        popupText += '<p><b>Keep data on target widget(s) after popup close: </b><input data-id="' + latLngId + '" type="checkbox" class="gisPopupKeepDataCheck" data-keepData="false"/></p>';
                                    }

                                    hasRealTime = true;
                                }
                            }

                            popupText += '</div>';

                            if (geoJsonServiceData.hasOwnProperty("BusStop")) {
                                popupText += '<div id="linesof_' + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + '" class="recreativeEventMapDataContainer recreativeEventMapTplContainer">Please wait...</div>';
                                popupText += '<div id="tmtblof_' + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + '" class="recreativeEventMapDataContainer recreativeEventMapTplTmtblContainer">Please wait...</div>';
                            }

                            newpopup = L.popup({
                                closeOnClick: false,//Non lo levare, sennò autoclose:false non funziona
                                autoClose: false,
                                offset: [15, 0],
                                //minWidth: 435,
                                minWidth: 400,
                                maxWidth: 1200,
                                //	className: geoJsonServiceData.hasOwnProperty("BusStop")?"draggableAndResizablePopup":"nonDraggableAndResizablePopup"
                                className: "draggableAndResizablePopup"
                            }).setContent(popupText);

                            event.target.bindPopup(newpopup).openPopup();

                            // draggable
                            var makeDraggable = function (popup, excluding) {
                            	popupResizeObserver.observe(popup._wrapper)
                                var pos = map.defaultMapRef.latLngToLayerPoint(popup.getLatLng());
                                L.DomUtil.setPosition(popup._wrapper.parentNode, pos);
                                console.log("POPUP", popup._wrapper, $(popup._wrapper).children(".leaflet-popup-content"))
                                var draggable = new L.Draggable(popup._container, popup._wrapper);
                                var popup_content = $(popup._wrapper).children(".leaflet-popup-content")[0]
                                popup._wrapper._draggable = draggable
                                $(popup_content).css("width", "")
                                draggable.enable();
                                $(".draggableAndResizablePopup").css("cursor", "move");
                                draggable.on('dragend', function () {
                                    var pos = map.defaultMapRef.layerPointToLatLng(this._newPos);
                                    popup.setLatLng(pos);
                                    $(popup._wrapper).siblings(".leaflet-popup-tip-container").hide();
                                });
                                excluding.forEach((excluded) => {
                                    $(excluded).css("cursor", "auto").on("mouseover", function (e) {
                                        draggable.disable();
                                    }).on("mouseout", function (e) {
                                        draggable.enable();
                                    });
                                });
                            };
                            //	if(newpopup.options.className == "draggableAndResizablePopup") makeDraggable(newpopup, [".draggableAndResizablePopup table.gisPopupGeneralDataTable"]);
                            if (newpopup.options.className == "draggableAndResizablePopup") makeDraggable(newpopup, [".draggableAndResizablePopup .recreativeEventMapDataContainer"]);


                            //

                            // resizable
                            $(".draggableAndResizablePopup .leaflet-popup-content-wrapper").css({
                                "resize": "both",
                                "overflow": "auto",
                                "min-width": "400px",
                                "max-width": "1200px",
                                "min-height": "100px",
                                "max-height": "400px"
                            });
                            //

                            // responsive
                            $(".draggableAndResizablePopup .recreativeEventMapDataContainer").css({
                                "width": "100%",
                                "height": "100%"
                            });
                            //

                            if (geoJsonServiceData.hasOwnProperty("BusStop")) {

                                $.getJSON('<?= $whatifmdtendpt ?>?stop=' + encodeURIComponent(serviceProperties['serviceUri']) + "&list=graphs", function (graphs) {
                                    var pAgency = graphs.join();
                                    var routesMarkup = "<p class=\"tplpoi_routesSubHead\" style=\"background-color:black; color:white; padding:0.5em;\"><strong>Date:</strong>&nbsp;" + new Date().toLocaleDateString("en", {
                                        weekday: 'long',
                                        year: 'numeric',
                                        month: 'long',
                                        day: 'numeric'
                                    }) + "</p>";
                                    var progress = { todo: -1, done: -1, bar: 0 };
                                    $.getJSON('<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&stop=' + encodeURIComponent(serviceProperties['serviceUri']) + '&date=' + encodeURIComponent(new Date().toISOString().slice(0, 10)) + '&list=routes', function (routes) {
                                        if (Object.keys(routes).length == 0) {
                                            $(".recreativeEventMapTplBtn").hide();
                                            return;
                                        }
                                        Object.keys(routes).forEach(function (key) {
                                            var route = routes[key];
                                            var rteBtnUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&route=' + encodeURIComponent(route["uri"]) + "&stop=" + encodeURIComponent(serviceProperties['serviceUri']) + "&date=" + encodeURIComponent(new Date().toISOString().slice(0, 10)) + "&list=trips";
                                            routesMarkup += "<p class=\"tplpoi_wifstprte\"><button class=\"polyin_" + route["uri"].replace(/[^a-zA-Z0-9]/g, "") + "\" data-uri=\"" + route["uri"] + "\" data-url=\"" + rteBtnUrl + "\" data-geoms=\"" + route["geoms"].join("|") + "\" data-key=\"" + key + "\" style=\"width:100%; background-color:#" + route["color"] + "; color:#" + route["text_color"] + "\">" + route["type"] + " " + route["short_name"] + " " + route["long_name"] + "</button></p>";
                                            route["geoms"].forEach(function (path) {
                                                var latlngs = [];
                                                path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                                    latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                                });
                                                var polyline = new L.Polyline(latlngs, {
                                                    className: "tplPoiPolyline polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " polyin_" + route["uri"].replace(/[^a-zA-Z0-9]/g, ""),
                                                    color: "#" + route["color"],
                                                    weight: 6
                                                }).bindTooltip(route["type"] + " " + route["short_name"] + " " + route["long_name"], { direction: 'right' });
                                                polyline.on("mouseover", function (e) {
                                                    e.target.openTooltip(e.latlng);
                                                });
                                                if ("undefined" == typeof tplPoiItems) {
                                                    tplPoiItems = new L.FeatureGroup();
                                                    map.defaultMapRef.addLayer(tplPoiItems);
                                                }
                                                polyline.addTo(tplPoiItems);
                                            });
                                            newpopup.on('remove', function () {
                                                $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).hide(); // TODO Remove only those related to the specific stop!!
                                            });
                                            // qui andiamo a generare tutte le stop raggiungibili direttamente (senza cambi) da quella selezionata
                                            $.getJSON(rteBtnUrl, function (trips) {
                                                var tripGeoms = [];
                                                Object.keys(trips).forEach(function (tripkey) {
                                                    if (!tripGeoms.includes(trips[tripkey]["path"])) {
                                                        tripGeoms.push(trips[tripkey]["path"]);
                                                        $.getJSON('<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&trip=' + encodeURIComponent(trips[tripkey]["uri"]) + "&list=stops", function (stops) {
                                                            var eventDesc = null;
                                                            map["eventsOnMap"].forEach(function (mapevt) {
                                                                if (mapevt["color1"] == feature["properties"]["color1"] && mapevt["color2"] == feature["properties"]["color2"]) {
                                                                    eventDesc = mapevt["desc"];
                                                                }
                                                            });
                                                            if (progress.todo == -1 && stops.length > 0) {
                                                                progress.todo = stops.length;
                                                            } else {
                                                                progress.todo += stops.length;
                                                            }
                                                            stops.forEach(function (stop) {
                                                                Number.prototype.countDecimals = function () {
                                                                    if (Math.floor(this.valueOf()) === this.valueOf()) return 0;
                                                                    return this.toString().split(".")[1].length || 0;
                                                                };
                                                                for (var l = 0; l < gisLayersOnMap[eventDesc].getLayers().length; l++) {
                                                                    var layer = gisLayersOnMap[eventDesc].getLayers()[l];
                                                                    if ((layer["feature"] && layer["feature"]["properties"]["serviceUri"] == stop["stop_uri"]) ||
                                                                        ((!layer["feature"]) && layer["_latlng"] && layer["_latlng"]["lat"] && parseFloat(layer["_latlng"]["lat"]) == parseFloat(stop["pos_lat"]).toFixed(parseFloat(layer["_latlng"]["lat"]).countDecimals()) && layer["_latlng"]["lng"] && parseFloat(layer["_latlng"]["lng"]) == parseFloat(stop["pos_lon"]).toFixed(parseFloat(layer["_latlng"]["lng"]).countDecimals()))) {
                                                                        if (progress.done == -1) progress.done = 1; else progress.done += 1;
                                                                        if (progress.done > -1 && progress.todo > -1 && progress.bar <= 100 * progress.done / progress.todo) {
                                                                            progress.bar = 100 * progress.done / progress.todo;
                                                                            $(newpopup._container).find("div.tplProgressBar").css("width", (100 * progress.done / progress.todo) + "%");
                                                                            $(newpopup._container).find("div.tplProgressBar").show();
                                                                            //console.log(progress);
                                                                        } else {
                                                                            if (progress.bar < 99) {
                                                                                progress.bar++;
                                                                                $(newpopup._container).find("div.tplProgressBar").css("width", progress.bar + "%");
                                                                                $(newpopup._container).find("div.tplProgressBar").show();
                                                                            }
                                                                        }
                                                                        return;
                                                                    }
                                                                }
                                                                $.getJSON("<?= $superServiceMapProxy ?>/api/v1?realtime=false&graphUri=" + encodeURIComponent(pAgency) + "&serviceUri=" + encodeURIComponent(stop["stop_uri"]), function (stopdata) {
                                                                    var newFeature = stopdata["BusStop"]["features"][0];
                                                                    newFeature["properties"]["color1"] = feature["properties"]["color1"];
                                                                    newFeature["properties"]["color2"] = feature["properties"]["color2"];
                                                                    newFeature["properties"]["pinattr"] = feature["properties"]["pinattr"];
                                                                    newFeature["properties"]["pincolor"] = feature["properties"]["pincolor"];
                                                                    newFeature["properties"]["symbolcolor"] = feature["properties"]["symbolcolor"];
                                                                    var newMarker = gisPrepareCustomMarker(newFeature, {
                                                                        "lng": newFeature["geometry"]["coordinates"][0],
                                                                        "lat": newFeature["geometry"]["coordinates"][1]
                                                                    });
                                                                    newMarker.addTo(gisLayersOnMap[eventDesc]);
                                                                    if (progress.done == -1) progress.done = 1; else progress.done += 1;
                                                                    if (progress.done > -1 && progress.todo > -1 && progress.bar < 100 * progress.done / progress.todo) {
                                                                        progress.bar = 100 * progress.done / progress.todo;
                                                                        $(newpopup._container).find("div.tplProgressBar").css("width", (100 * progress.done / progress.todo) + "%");
                                                                        $(newpopup._container).find("div.tplProgressBar").show();
                                                                    } else {
                                                                        if (progress.bar < 99) {
                                                                            progress.bar++;
                                                                            $(newpopup._container).find("div.tplProgressBar").css("width", progress.bar + "%");
                                                                            $(newpopup._container).find("div.tplProgressBar").show();
                                                                        }
                                                                    }
                                                                });
                                                            });
                                                        });
                                                    }
                                                });
                                            });
                                            //
                                        });
                                        if (Object.keys(routes).length === 0 && routes.constructor === Object) routesMarkup += "<p>No routes found for this date.</p>";
                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).empty().append($(routesMarkup));
                                        $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).click(function () {
                                            var classes = $(this).attr('class').split(/\s+/);
                                            $.each(classes, function (i, c) {
                                                if (c.startsWith('polyin_')) {
                                                    $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').click();
                                                    $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').parent().siblings('div.recreativeEventMapTplContainer').find("button." + c).click();
                                                    map.defaultMapRef.panTo(new L.LatLng(event.target.getLatLng().lat, event.target.getLatLng().lng));
                                                }
                                            });
                                        });


                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_wifstprte button").click(function () {
                                            var wifstprtebtn = $(this);
                                            var wifstprtebtnhtml = $(this).html();
                                            var rteUri = $(this).data("uri");
                                            $(this).html("Please wait...");
                                            var hrRouteTxt = $(this).data("key");
                                            lastSelectedRoute = hrRouteTxt;

                                            var bg = $(this).css("background-color");
                                            var fg = $(this).css("color");
                                            $.getJSON($(this).data("url"), function (trips) {
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p").hide();
                                                wifstprtebtn.html(wifstprtebtnhtml);
                                                var affectedTripsMarkup = "";
                                                var tripsMarkup = "<p class=\"tplpoi_tripsSubHead\" style=\"background-color:black; color:white; padding:0.5em;\"><strong>Date:</strong>&nbsp;" + new Date().toLocaleDateString("en", {
                                                    weekday: 'long',
                                                    year: 'numeric',
                                                    month: 'long',
                                                    day: 'numeric'
                                                }) + "<br><strong>Route:</strong>&nbsp;" + hrRouteTxt + "</p><div style=\"height:100%; border: medium solid black; padding:0.5em;\" class=\"tplpoi_tripsDivInRoute\"><p class=\"tplpoi_preserveplease\" style=\"margin:0px 0; display:none;\"><strong>Affected Trips:</strong></p><div id=\"tplpoi_affectedtrips\" style=\"display:none;\"></div><p class=\"tplpoi_preserveplease\" style=\"margin:0px 0;\"><strong style=\"display:none;\">All Trips:</strong></p>";
                                                $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).hide();
                                                Object.keys(trips).sort(function (a, b) {
                                                    if (trips[a]["start"] > trips[b]["start"]) return 1; else return -1;
                                                }).forEach(function (tripkey) {
                                                    var trip = trips[tripkey];
                                                    var theTripUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&trip=' + encodeURIComponent(trip["uri"]) + "&list=stops";
                                                    tripsMarkup += "<p class=\"tplpoi_wifstptrp\"><button style=\"text-align:left; width:100%; background-color:" + bg + "; color:" + fg + ";\" data-tripkey=\"" + tripkey + "\" data-path=\"" + trip["path"] + "\" data-url=\"" + theTripUrl + "\" data-routeuri=\"" + rteUri + "\" data-routebgcolor=\"" + trip["route"]["bg_color"] + "\" data-routefgcolor=\"" + trip["route"]["fg_color"] + "\" data-routeshortname=\"" + trip["route"]["short_name"] + "\" data-routelongname=\"" + trip["route"]["long_name"] + "\" data-routetype=\"" + trip["route"]["type"] + "\" data-agencyname=\"" + trip["route"]["agency"] + "\">" + trip["start"].substring(0, 5) + "&nbsp;<span style=\"border:thin solid " + fg + "; padding:0.2em;\">" + (trip["direction"] == "0" ? "&rharu;" : "&lhard;") + "</span>&nbsp;" + trip["headsign"] + "</button></p>";
                                                    var latlngs = [];
                                                    trip["path"].split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                                        latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                                    });
                                                    var polyline = new L.Polyline(latlngs, {
                                                        weight: 6,
                                                        color: wifstprtebtn.css("background-color"),
                                                        className: "tplPoiPolyline polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " polyof_" + rteUri.replace(/[^a-zA-Z0-9]/g, "")
                                                    });
                                                    polyline.addTo(tplPoiItems);
                                                });
                                                tripsMarkup += "</div>";
                                                tripsMarkup += "<p class=\"tplpoi_backToRoutes\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_tripsSubHead").remove();
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_tripsDivInRoute").remove();
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_backToRoutes").remove();
                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).append($(tripsMarkup));

                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToRoutes button").click(function () {
                                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p").hide();
                                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_tripsDivInRoute").hide();
                                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_routesSubHead").show();
                                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_wifstprte").show();
                                                    $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).show();
                                                });

                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_wifstptrp button").click(function () {
                                                    var wifstptrpbtn = $(this);
                                                    var wifstptrpbtnhtml = $(this).html();
                                                    var theaffectedstopsMarkup = "";
                                                    var theTripMarkup = "<p class=\"tplpoi_theTripSubhead\" style=\"background-color:black; color:white;  padding:0.5em;\"><strong>Agency:</strong>&nbsp;" + $(this).data("agencyname") + "<br><strong>Route:</strong>&nbsp;" + $(this).data("routetype") + " " + $(this).data("routeshortname") + " " + $(this).data("routelongname") + "<br><strong>Trip:</strong>&nbsp;" + $(this).html().replace("<strong>", "").replace("</strong>", "") + "</p><div class=\"tplpoi_fullTripData\" style=\"height:100%; border: medium solid black; padding:0.5em;\"><p style=\"margin:0px 0; display:none;\"><strong>Affected Stops:</strong></p><div id=\"tplpoi_affectedstops\" style=\"display:none;\"></div><p style=\"margin:0px 0;\"><strong style=\"display:none;\">All Stops:</strong></p>";
                                                    $(this).html("Please wait...");
                                                    var bgcolor = $(this).data("routebgcolor");
                                                    var fgcolor = $(this).data("routefgcolor");
                                                    var routetype = $(this).data("routetype");
                                                    var path = $(this).data("path");
                                                    var tripkey = $(this).data("tripkey");
                                                    var routeUri = $(this).data("routeuri");

                                                    $.getJSON($(this).data("url"), function (tripdata) {
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_tripsSubHead").hide();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_wifstptrp").hide();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_backToRoutes").hide();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_tripsDivInRoute").hide();
                                                        wifstptrpbtn.html(wifstptrpbtnhtml);
                                                        $(".polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).hide();
                                                        var latlngs = [];
                                                        path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                                            latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                                        });
                                                        var polyline = new L.Polyline(latlngs, {
                                                            weight: 6,
                                                            color: "#" + bgcolor,
                                                            className: "tplPoiPolyline polyof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")
                                                        });
                                                        polyline.addTo(tplPoiItems);
                                                        tripdata.forEach(function (oneStop, stopNum) {
                                                            if (serviceProperties['serviceUri'] == oneStop["stop_uri"]) {
                                                                theTripMarkup += "<button data-serviceuri=\"" + oneStop["stop_uri"] + "\" data-lat=\"" + oneStop["pos_lat"] + "\" data-lon=\"" + oneStop["pos_lon"] + "\" class=\"tplpoi_stopbtn\" style=\"text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + "; font-size:larger; font-weight:bold; \">#" + parseInt(oneStop["sequence"]) + " " + oneStop["code"] + " " + oneStop["name"] + "<br>ARR " + (stopNum > 0 ? oneStop["arrival"].substring(0, 5) : "--:--") + " DEP " + (stopNum < tripdata.length - 1 ? oneStop["departure"].substring(0, 5) : "--:--") + "</button>";
                                                            } else {
                                                                theTripMarkup += "<button data-serviceuri=\"" + oneStop["stop_uri"] + "\" data-lat=\"" + oneStop["pos_lat"] + "\" data-lon=\"" + oneStop["pos_lon"] + "\" class=\"tplpoi_stopbtn\" style=\"text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + ";\">#" + parseInt(oneStop["sequence"]) + " " + oneStop["code"] + " " + oneStop["name"] + "<br>ARR " + (stopNum > 0 ? oneStop["arrival"].substring(0, 5) : "--:--") + " DEP " + (stopNum < tripdata.length - 1 ? oneStop["departure"].substring(0, 5) : "--:--") + "</button>";
                                                            }
                                                        });
                                                        theTripMarkup += "</div>";
                                                        theTripMarkup += "<p class=\"tplpoi_backToTrips\"><button style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_theTripSubhead").remove();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_fullTripData").remove();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_backToTrips").remove();
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).append($(theTripMarkup));
                                                        if (theaffectedstopsMarkup == "") {
                                                            theaffectedstopsMarkup = "<p>No stops found.</p>";
                                                        }
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToTrips button").click(
                                                            function () {
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p").hide();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_fullTripData").hide();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_tripsSubHead").show();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("div.tplpoi_tripsDivInRoute").show();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_wifstptrp").show();
                                                                $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "")).find("p.tplpoi_backToRoutes").show();
                                                                $(".polyof_" + routeUri.replace(/[^a-zA-Z0-9]/g, "")).show();
                                                            }
                                                        );
                                                        Number.prototype.countDecimals = function () {
                                                            if (Math.floor(this.valueOf()) === this.valueOf()) return 0;
                                                            return this.toString().split(".")[1].length || 0;
                                                        };
                                                        $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " button.tplpoi_stopbtn").click(function () {
                                                            //console.log("stopbtn");
                                                            var serviceuri = $(this).data("serviceuri");
                                                            var lat = $(this).data("lat");
                                                            var lon = $(this).data("lon");
                                                            var eventDesc = null;
                                                            map["eventsOnMap"].forEach(function (mapevt) {
                                                                if (mapevt["color1"] == feature["properties"]["color1"] && mapevt["color2"] == feature["properties"]["color2"]) {
                                                                    eventDesc = mapevt["desc"];
                                                                }
                                                            });

                                                            for (var l = 0; l < gisLayersOnMap[eventDesc].getLayers().length; l++) {
                                                                var layer = gisLayersOnMap[eventDesc].getLayers()[l];
                                                                if ((layer["feature"] && layer["feature"]["properties"]["serviceUri"] == serviceuri) ||
                                                                    ((!layer["feature"]) && layer["_latlng"]["lat"] == lat.toFixed(layer["_latlng"]["lat"].countDecimals()) && layer["_latlng"]["lng"] == lon.toFixed(layer["_latlng"]["lng"].countDecimals()))) {
                                                                    try {
                                                                        layer.closePopup();
                                                                    } catch (e) {
                                                                    }
                                                                    layer.fire('click');
                                                                    console.log("click");
                                                                    return;
                                                                }
                                                            }
                                                            $.getJSON("<?= $superServiceMapProxy ?>/api/v1?serviceUri=" + encodeURIComponent(serviceuri), function (stopdata) {
                                                                var newFeature = stopdata["BusStop"]["features"][0];
                                                                newFeature["properties"]["color1"] = feature["properties"]["color1"];
                                                                newFeature["properties"]["color2"] = feature["properties"]["color2"];
                                                                newFeature["properties"]["pinattr"] = feature["properties"]["pinattr"];
                                                                newFeature["properties"]["pincolor"] = feature["properties"]["pincolor"];
                                                                newFeature["properties"]["symbolcolor"] = feature["properties"]["symbolcolor"];
                                                                var newMarker = gisPrepareCustomMarker(newFeature, {
                                                                    "lng": newFeature["geometry"]["coordinates"][0],
                                                                    "lat": newFeature["geometry"]["coordinates"][1]
                                                                });
                                                                newMarker.addTo(gisLayersOnMap[eventDesc]);
                                                                newMarker.fire('click');
                                                            });
                                                        });
                                                    });

                                                });

                                            });

                                        });

                                    });
                                });
                            }

                            if (hasRealTime) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').show();
                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').trigger("click");
                                $('#<?= $_REQUEST['name_w'] ?>_map span.popupLastUpdate[data-id="' + latLngId + '"]').html(measuredTime);
                            } else {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').hide();
                            }

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDetailsBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDetailsBtn[data-id="' + latLngId + '"]').click(function () {
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapDetailsContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDescriptionBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDescriptionBtn[data-id="' + latLngId + '"]').click(function () {
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapDescContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').click(function () {
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapContactsContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').click(function () {
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapTplContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                                if ($("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToTrips button").is(":visible")) {
                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToTrips button").click();
                                }
                                if ($("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToRoutes button").is(":visible")) {
                                    $("#linesof_" + serviceProperties['serviceUri'].replace(/[^a-zA-Z0-9]/g, "") + " p.tplpoi_backToRoutes button").click();
                                }
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplTmtblBtn[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplTmtblBtn[data-id="' + latLngId + '"]').click(function () {
                                //console.log("clicked "+'#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplTmtblBtn[data-id="' + latLngId + '"]');
                                $(this).parent().siblings('div.recreativeEventMapDataContainer').hide();
                                $(this).parent().siblings('div.recreativeEventMapTplTmtblContainer').show();
                                $(this).siblings('button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                                var tmtblBtn = $(this);
                                var tmtblMarkup = "";
                                $.getJSON('<?= $whatifmdtendpt ?>?stop=' + encodeURIComponent(serviceProperties['serviceUri']) + "&list=graphs", function (graphs) {
                                    var pAgency = graphs.join();
                                    $.getJSON('<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&stop=' + encodeURIComponent(serviceProperties['serviceUri']) + "&list=timetable", function (timetable) {
                                        //console.log(timetable);
                                        timetable.forEach(function (entry, rownum) {
                                            //console.log(entry);
                                            tmtblMarkup += "<p class=\"tplpoi_tmtblrow\"><button data-r=\"" + entry["route"].replace(/[^a-zA-Z0-9]/g, "") + "\" data-t=\"" + entry["trip"] + "\" data-n=\"" + rownum + "\" style=\"width:100%; background-color:#" + entry["bgcolor"] + "; color:#" + entry["fgcolor"] + "\"><p style=\"font-size:larger; font-weight:bold; margin:0px; padding:0px; text-align:left;\">" + (entry["departure"] ? entry["departure"] : entry["arrival"]).substring(0, 5) + "&nbsp;<span style=\"font-size:larger; border:thin solid #" + entry["fgcolor"] + ";\">" + entry["number"] + "</span>&nbsp;" + entry["headsign"] + "</p><p class=\"nextstops\" style=\"margin:0px; padding:0px; font-weight:normal; text-align:left;\"></p></button></p>";
                                        });
                                        if (timetable.length == 0) {
                                            tmtblMarkup += "<p class=\"tplpoi_tmtblrow\">The timetable is currently not available for this stop.</p>";
                                        }
                                        tmtblBtn.parent().siblings('div.recreativeEventMapTplTmtblContainer').empty();
                                        tmtblBtn.parent().siblings('div.recreativeEventMapTplTmtblContainer').append($(tmtblMarkup));
                                        timetable.forEach(function (entry, rownum) {
                                            var theTripUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(pAgency) + '&trip=' + encodeURIComponent(entry["trip_uri"]) + "&list=stops";
                                            var n = rownum;
                                            $.getJSON(theTripUrl, function (alltripstops) {
                                                //console.log(alltripstops);
                                                var span = $("p.tplpoi_tmtblrow button[data-t=\"" + entry["trip"] + "\"][data-n=\"" + n + "\"] p.nextstops");
                                                var spanMarkup = "";
                                                var isNext = false;
                                                alltripstops.forEach(function (stop) {
                                                    if (isNext) {
                                                        if (-1 == spanMarkup.indexOf(stop["arrival"].substring(0, 5) + "&nbsp;" + stop["name"].replaceAll(" ", "&nbsp;") + "&nbsp;&bull; ")) {
                                                            spanMarkup += stop["arrival"].substring(0, 5) + "&nbsp;" + stop["name"].replaceAll(" ", "&nbsp;") + "&nbsp;&bull; ";
                                                        }
                                                    }
                                                    if (stop["stop_uri"] == serviceProperties['serviceUri']) {
                                                        isNext = true;
                                                    }
                                                });
                                                if (!spanMarkup) {
                                                    spanMarkup += "This is the terminus stop, the trip does not continue further.&nbsp;&bull; ";
                                                }
                                                // console.log("Appending "+spanMarkup.substring(0,spanMarkup.length-13));
                                                span.append(spanMarkup.substring(0, spanMarkup.length - 13));
                                            });
                                        });
                                        $(".tplpoi_tmtblrow button").click(function () {
                                            //console.log($(this).data("r")); console.log($(this).data("t"));
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').click();
                                            var t = $(this).data("t");
                                            var observer = new MutationObserver(function (mutations, observer) {
                                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').parent().siblings('div.recreativeEventMapTplContainer').find('.tplpoi_tripsDivInRoute .tplpoi_wifstptrp button[data-tripkey="' + t + '"]').click();
                                                observer.disconnect();
                                            });
                                            observer.observe($('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').parent().siblings('div.recreativeEventMapTplContainer')[0], { childList: true });
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTplBtn[data-id="' + latLngId + '"]').parent().siblings('div.recreativeEventMapTplContainer').find("button.polyin_" + $(this).data("r")).click();
                                        });
                                    });
                                });
                            });

                            if (hasRealTime) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').trigger("click");
                            }

                            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').css("background", color2);
                            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').css("border", "none");
                            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').css("color", "black");

                            $('#<?= $_REQUEST['name_w'] ?>_map table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').focus(function () {
                                $(this).css("outline", "0");
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map input.gisPopupKeepDataCheck[data-id="' + latLngId + '"]').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map input.gisPopupKeepDataCheck[data-id="' + latLngId + '"]').click(function () {
                                if ($(this).attr("data-keepData") === "false") {
                                    $(this).attr("data-keepData", "true");
                                } else {
                                    $(this).attr("data-keepData", "false");
                                }
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').off('mouseenter');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').off('mouseleave');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-id="' + latLngId + '"]').hover(function () {
                                if ($(this).attr("data-lastDataClicked") === "false") {
                                    $(this).css("background", color1);
                                    $(this).css("background", "-webkit-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                    $(this).css("background", "background: -o-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                    $(this).css("background", "background: -moz-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                    $(this).css("background", "background: linear-gradient(to left, " + color1 + ", " + color2 + ")");
                                    $(this).css("font-weight", "bold");
                                }

                                var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                var colIndex = $(this).parent().index();
                                //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html();
                                var title = $(this).parents("tr").find("td").eq(0).html();

                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "mouseOverLastDataFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i],
                                        value: $(this).attr("data-lastValue"),
                                        color1: $(this).attr("data-color1"),
                                        color2: $(this).attr("data-color2"),
                                        widgetTitle: title
                                    });
                                }
                            },
                                function () {
                                    if ($(this).attr("data-lastDataClicked") === "false") {
                                        $(this).css("background", color2);
                                        $(this).css("font-weight", "normal");
                                    }
                                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');

                                    for (var i = 0; i < widgetTargetList.length; i++) {
                                        $.event.trigger({
                                            type: "mouseOutLastDataFromExternalContentGis_" + widgetTargetList[i],
                                            eventGenerator: $(this),
                                            targetWidget: widgetTargetList[i],
                                            value: $(this).attr("data-lastValue"),
                                            color1: $(this).attr("data-color1"),
                                            color2: $(this).attr("data-color2")
                                        });
                                    }
                                });

                            //Disabilitiamo i 4Hours se last update più vecchio di 4 ore
                            if (rtDataAgeSec > 14400) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="4/HOUR"]').attr("data-disabled", "true");
                                //Disabilitiamo i 24Hours se last update più vecchio di 24 ore
                                if (rtDataAgeSec > 86400) {
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="1/DAY"]').attr("data-disabled", "true");
                                    //Disabilitiamo i 7 days se last update più vecchio di 7 days
                                    if (rtDataAgeSec > 604800) {
                                        $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="7/DAY"]').attr("data-disabled", "true");
                                        //Disabilitiamo i 30 days se last update più vecchio di 30 days
                                        //if(rtDataAgeSec > 18144000)
                                        if (rtDataAgeSec > 2592000) {
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="30/DAY"]').attr("data-disabled", "true");
                                            //Disabilitiamo i 6 months se last update più vecchio di 180 days
                                            if (rtDataAgeSec > 15552000) {
                                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="180/DAY"]').attr("data-disabled", "true");
                                                //Disabilitiamo i 1 year se last update più vecchio di 365 days
                                                if (rtDataAgeSec > 31536000) {
                                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="365/DAY"]').attr("data-disabled", "true");
                                                    //Disabilitiamo i 2 year se last update più vecchio di 730 days
                                                    if (rtDataAgeSec > 31536000 * 2) {
                                                        $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="730/DAY"]').attr("data-disabled", "true");
                                                        //Disabilitiamo i 10 year se last update più vecchio di 730 days
                                                        if (rtDataAgeSec > 315360000) {
                                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="3650/DAY"]').attr("data-disabled", "true");

                                                        } else {
                                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="3650/DAY"]').attr("data-disabled", "false");
                                                        }

                                                    } else {
                                                        $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="730/DAY"]').attr("data-disabled", "false");
                                                    }
                                                } else {
                                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="365/DAY"]').attr("data-disabled", "false");
                                                }
                                            } else {
                                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="180/DAY"]').attr("data-disabled", "false");
                                            }
                                        } else {
                                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="30/DAY"]').attr("data-disabled", "false");
                                        }
                                    } else {
                                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen button.timeTrendBtn[data-id="' + latLngId + '"][data-range="7/DAY"]').attr("data-disabled", "false");
                                    }
                                } else {
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="1/DAY"]').attr("data-disabled", "false");
                                }
                            } else {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="4/HOUR"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="1/DAY"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="7/DAY"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="30/DAY"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="180/DAY"]').attr("data-disabled", "false");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"][data-range="365/DAY"]').attr("data-disabled", "false");
                            }

                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').off('mouseenter');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').off('mouseleave');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"]').hover(function () {
                                if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                    $(this).css("background-color", "#e6e6e6");
                                    $(this).off("hover");
                                    $(this).off("click");
                                } else {
                                    if ($(this).attr("data-timeTrendClicked") === "false") {
                                        $(this).css("background", color1);
                                        $(this).css("background", "-webkit-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                        $(this).css("background", "background: -o-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                        $(this).css("background", "background: -moz-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                        $(this).css("background", "background: linear-gradient(to left, " + color1 + ", " + color2 + ")");
                                        $(this).css("font-weight", "bold");
                                    }

                                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                    //var colIndex = $(this).parent().index();
                                    //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html() + " - " + $(this).attr("data-range-shown");
                                    var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");

                                    for (var i = 0; i < widgetTargetList.length; i++) {
                                        $.event.trigger({
                                            type: "mouseOverTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                            eventGenerator: $(this),
                                            targetWidget: widgetTargetList[i],
                                            value: $(this).attr("data-lastValue"),
                                            color1: $(this).attr("data-color1"),
                                            color2: $(this).attr("data-color2"),
                                            widgetTitle: title
                                        });
                                    }
                                }
                            },
                                function () {
                                    if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                        $(this).css("background-color", "#e6e6e6");
                                        $(this).off("hover");
                                        $(this).off("click");
                                    } else {
                                        if ($(this).attr("data-timeTrendClicked") === "false") {
                                            $(this).css("background", color2);
                                            $(this).css("font-weight", "normal");
                                        }

                                        var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                        for (var i = 0; i < widgetTargetList.length; i++) {
                                            $.event.trigger({
                                                type: "mouseOutTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                                eventGenerator: $(this),
                                                targetWidget: widgetTargetList[i],
                                                value: $(this).attr("data-lastValue"),
                                                color1: $(this).attr("data-color1"),
                                                color2: $(this).attr("data-color2")
                                            });
                                        }
                                    }
                                });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-id=' + latLngId + ']').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-id=' + latLngId + ']').click(function (event) {
                                $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').each(function (i) {
                                    $(this).css("background", $(this).attr("data-color2"));
                                });
                                $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').css("font-weight", "normal");
                                $(this).css("background", $(this).attr("data-color1"));
                                $(this).css("font-weight", "bold");
                                $('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn').attr("data-lastDataClicked", "false");
                                $(this).attr("data-lastDataClicked", "true");
                                var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                var colIndex = $(this).parent().index();
                                var title = $(this).parents("tr").find("td").eq(0).html();

                                if ($(this).attr("data-value_unit") == "SURI") {
                                    let q = "";
                                    let qType = "";
                                    let passData = {};
                                    let widTargets = "";
                                    if ($(this).attr("data-lastValue").includes("http://www.disit.org/km4city")) {
                                        qType = "Default";
                                        q = "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + encodeServiceUri($(this).attr("data-lastValue")) + "&format=json&fullCount=false";
                                        for (var i = 0; i < widgetTargetList.length; i++) {
                                            if (widTargets == "") {
                                                widTargets = widgetTargetList[i];
                                            } else {
                                                widTargets = widTargets + "," + widgetTargetList[i];
                                            }
                                        }
                                        passData.desc = "SURI_" + $(this).attr("data-field");
                                        passData.query = q;
                                        passData.queryType = qType;
                                        passData.color1 = $(this).attr("data-color1");
                                        passData.color2 = $(this).attr("data-color2");
                                        passData.targets = widTargets;
                                        passData.fromSURI = true

                                        $.event.trigger({
                                            type: "addSelectorPin",
                                            target: map.mapName,
                                            passedData: passData,
                                            // passedParams: passedParams
                                        });
                                    } else if ($(this).attr("data-lastValue").includes("http://") || $(this).attr("data-lastValue").includes("https://")) {
                                        window.open($(this).attr("data-lastValue"), '_blank');
                                    } else {
                                        qType = "MyPOI";
                                        q = $(this).attr("data-lastValue");
                                    }

                                }

                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "showLastDataFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i],
                                        value: $(this).attr("data-lastValue"),
                                        color1: $(this).attr("data-color1"),
                                        color2: $(this).attr("data-color2"),
                                        widgetTitle: title,
                                        field: $(this).attr("data-field"),
                                        serviceUri: $(this).attr("data-serviceUri"),
                                        marker: markersCache["" + $(this).attr("data-id") + ""],
                                        mapRef: map.defaultMapRef,
                                        fake: $(this).attr("data-fake"),
                                        fakeId: $(this).attr("data-fakeId")
                                    });
                                }

                                $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"]').each(function (i) {
                                    if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                        $(this).css("background-color", "#e6e6e6");
                                        $(this).off("hover");
                                        $(this).off("click");
                                    }
                                });

                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').click(function (event) {
                                if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                    $(this).css("background-color", "#e6e6e6");
                                    $(this).off("hover");
                                    $(this).off("click");
                                } else {
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').css("background", $(this).attr("data-color2"));
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').css("font-weight", "normal");
                                    $(this).css("background", $(this).attr("data-color1"));
                                    $(this).css("font-weight", "bold");
                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn').attr("data-timeTrendClicked", "false");
                                    $(this).attr("data-timeTrendClicked", "true");
                                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                    var colIndex = $(this).parent().index();
                                    var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");
                                    var lastUpdateTime = $(this).parents('div.recreativeEventMapContactsContainer').find('span.popupLastUpdate').html();

                                    var now = new Date();
                                    var lastUpdateDate = new Date(lastUpdateTime);
                                    var diff = parseFloat(Math.abs(now - lastUpdateDate) / 1000);
                                    var range = $(this).attr("data-range");

                                    for (var i = 0; i < widgetTargetList.length; i++) {
                                        $.event.trigger({
                                            type: "showTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                            eventGenerator: $(this),
                                            targetWidget: widgetTargetList[i],
                                            range: range,
                                            color1: $(this).attr("data-color1"),
                                            color2: $(this).attr("data-color2"),
                                            widgetTitle: title,
                                            field: $(this).attr("data-field"),
                                            serviceUri: $(this).attr("data-serviceUri"),
                                            marker: markersCache["" + $(this).attr("data-id") + ""],
                                            mapRef: map.defaultMapRef,
                                            fake: false
                                            //fake: $(this).attr("data-fake")
                                        });
                                    }

                                    $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"]').each(function (i) {
                                        if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                            $(this).css("background-color", "#e6e6e6");
                                            $(this).off("hover");
                                            $(this).off("click");
                                        }
                                    });
                                }
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-id="' + latLngId + '"]').each(function (i) {
                                if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                    $(this).css("background-color", "#e6e6e6");
                                    $(this).off("hover");
                                    $(this).off("click");
                                }
                            });

                            map.defaultMapRef.off('popupclose');
                            map.defaultMapRef.on('popupclose', function (closeEvt) {
                                var popupContent = $('<div></div>');
                                popupContent.html(closeEvt.popup._content);

                                if (popupContent.find("button.lastValueBtn").length > 0) {
                                    var widgetTargetList = popupContent.find("button.lastValueBtn").eq(0).attr("data-targetWidgets").split(',');

                                    if (($('#<?= $_REQUEST['name_w'] ?>_map button.lastValueBtn[data-lastDataClicked=true]').length > 0) && ($('input.gisPopupKeepDataCheck').attr('data-keepData') === "false")) {
                                        for (var i = 0; i < widgetTargetList.length; i++) {
                                            $.event.trigger({
                                                type: "restoreOriginalLastDataFromExternalContentGis_" + widgetTargetList[i],
                                                eventGenerator: $(this),
                                                targetWidget: widgetTargetList[i],
                                                value: $(this).attr("data-lastValue"),
                                                color1: $(this).attr("data-color1"),
                                                color2: $(this).attr("data-color2")
                                            });
                                        }
                                    }

                                    if (($('#<?= $_REQUEST['name_w'] ?>_map button.timeTrendBtn[data-timeTrendClicked=true]').length > 0) && ($('input.gisPopupKeepDataCheck').attr('data-keepData') === "false")) {
                                        for (var i = 0; i < widgetTargetList.length; i++) {
                                            $.event.trigger({
                                                type: "restoreOriginalTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                                eventGenerator: $(this),
                                                targetWidget: widgetTargetList[i]
                                            });
                                        }
                                    }
                                }
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map div.leaflet-popup').off('click');
                        },
                        error: function (errorData) {
                            console.log("Error in data retrieval");
                            console.log(JSON.stringify(errorData));
                            var serviceProperties = feature.properties;

                            var underscoreIndex = serviceProperties.serviceType.indexOf("_");
                            var serviceClass = serviceProperties.serviceType.substr(0, underscoreIndex);
                            var serviceSubclass = serviceProperties.serviceType.substr(underscoreIndex);
                            serviceSubclass = serviceSubclass.replace(/_/g, " ");

                            popupText = '<h3 class="gisPopupTitle">' + serviceProperties.name + '</h3>' +
                                '<p><b>Typology: </b>' + serviceClass + " - " + serviceSubclass + '</p>' +
                                '<p><i>Data are limited due to an issue in their retrieval</i></p>';

                            event.target.bindPopup(popupText, {
                                offset: [15, 0],
                                minWidth: 215,
                                maxWidth: 600
                            }).openPopup();
                        }
                    });
                }
            });

            return marker;
        }

    function gisPrepareCustomMarkerFullScreen(feature, latlng) {
        var mapPinImg = '../img/gisMapIcons/' + feature.properties.serviceType + '.png';
        var markerIcon = L.icon({
            iconUrl: mapPinImg,
            iconAnchor: [16, 37]
        });

        var marker = new L.Marker(latlng, { icon: markerIcon });

        var latLngKey = latlng.lat + "" + latlng.lng;

        latLngKey = latLngKey.replace(".", "");
        latLngKey = latLngKey.replace(".", "");//Incomprensibile il motivo ma con l'espressione regolare /./g non funziona
        markersCache["" + latLngKey + ""] = marker;

        marker.on('mouseover', function (event) {
            var hoverImg = '../img/gisMapIcons/over/' + feature.properties.serviceType + '_over.png';
            var hoverIcon = L.icon({
                iconUrl: hoverImg
            });
            event.target.setIcon(hoverIcon);
        });

        marker.on('mouseout', function (event) {
            var outImg = '../img/gisMapIcons/' + feature.properties.serviceType + '.png';
            var outIcon = L.icon({
                iconUrl: outImg
            });
            event.target.setIcon(outIcon);
        });

        marker.on('click', function (event) {
            fullscreendefaultMapRef.off('moveend');

            event.target.unbindPopup();
            newpopup = null;
            var popupText, realTimeData, measuredTime, rtDataAgeSec, targetWidgets, color1, color2 = null;
            var urlToCall, fake, fakeId = null;

            if (feature.properties.fake === 'true') {
                urlToCall = "../serviceMapFake.php?getSingleGeoJson=true&singleGeoJsonId=" + feature.id;
                fake = true;
                fakeId = feature.id;
            }
            else {
                urlToCall = "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + encodeServiceUri(feature.properties.serviceUri) + "&format=json&fullCount=false";
                fake = false;
            }

            var latLngId = event.target.getLatLng().lat + "" + event.target.getLatLng().lng;
            latLngId = latLngId.replace(".", "");
            latLngId = latLngId.replace(".", "");//Incomprensibile il motivo ma con l'espressione regolare /./g non funziona

            $.ajax({
                url: urlToCall,
                type: "GET",
                data: {},
                async: true,
                dataType: 'json',
                success: function (geoJsonServiceData) {
                    var fatherNode = null;
                    if (geoJsonServiceData.hasOwnProperty("BusStop")) {
                        fatherNode = geoJsonServiceData.BusStop;
                    }
                    else {
                        if (geoJsonServiceData.hasOwnProperty("Sensor")) {
                            fatherNode = geoJsonServiceData.Sensor;
                        }
                        else {
                            //Prevedi anche la gestione del caso in cui non c'è nessuna di queste tre, sennò il widget rimane appeso.
                            fatherNode = geoJsonServiceData.Service;
                        }
                    }

                    var serviceProperties = fatherNode.features[0].properties;
                    var underscoreIndex = serviceProperties.serviceType.indexOf("_");
                    var serviceClass = serviceProperties.serviceType.substr(0, underscoreIndex);
                    var serviceSubclass = serviceProperties.serviceType.substr(underscoreIndex);
                    serviceSubclass = serviceSubclass.replace(/_/g, " ");

                    fatherNode.features[0].properties.targetWidgets = feature.properties.targetWidgets;
                    fatherNode.features[0].properties.color1 = feature.properties.color1;
                    fatherNode.features[0].properties.color2 = feature.properties.color2;
                    targetWidgets = feature.properties.targetWidgets;
                    color1 = feature.properties.color1;
                    color2 = feature.properties.color2;

                    //Popup nuovo stile uguali a quelli degli eventi ricreativi
                    popupText = '<h3 class="recreativeEventMapTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + serviceProperties.name + '</h3>';
                    if ((serviceProperties.serviceUri !== '') && (serviceProperties.serviceUri !== undefined) && (serviceProperties.serviceUri !== 'undefined') && (serviceProperties.serviceUri !== null) && (serviceProperties.serviceUri !== 'null')) {
                        popupText += '<div class="recreativeEventMapSubTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + '</div>';
                        //   popupText += '<div class="recreativeEventMapSubTitle">' + "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + '</div>';
                    }
                    popupText += '<div class="recreativeEventMapBtnContainer"><button data-id="' + latLngId + '" class="recreativeEventMapDetailsBtn recreativeEventMapBtn recreativeEventMapBtnActive" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Details</button><button data-id="' + latLngId + '" class="recreativeEventMapDescriptionBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Description</button><button data-id="' + latLngId + '" class="recreativeEventMapContactsBtn recreativeEventMapBtn" type="button" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">RT data</button></div>';

                    popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDetailsContainer">';

                    popupText += '<table id="' + latLngId + '" class="gisPopupGeneralDataTable">';
                    //Intestazione
                    popupText += '<thead>';
                    popupText += '<th style="background: ' + color2 + '">Description</th>';
                    popupText += '<th style="background: ' + color2 + '">Value</th>';
                    popupText += '</thead>';

                    //Corpo
                    popupText += '<tbody>';

                    if ((serviceProperties.serviceUri !== '') && (serviceProperties.serviceUri !== undefined) && (serviceProperties.serviceUri !== 'undefined') && (serviceProperties.serviceUri !== null) && (serviceProperties.serviceUri !== 'null')) {
                        popupText += '<tr><td>Value Name</td><td>' + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + '<td></tr>';
                    }

                    if (serviceProperties.hasOwnProperty('website')) {
                        if ((serviceProperties.website !== '') && (serviceProperties.website !== undefined) && (serviceProperties.website !== 'undefined') && (serviceProperties.website !== null) && (serviceProperties.website !== 'null')) {
                            if (serviceProperties.website.includes('http') || serviceProperties.website.includes('https')) {
                                popupText += '<tr><td>Website</td><td><a href="' + serviceProperties.website + '" target="_blank">Link</a></td></tr>';
                            }
                            else {
                                popupText += '<tr><td>Website</td><td><a href="' + serviceProperties.website + '" target="_blank">Link</a></td></tr>';
                            }
                        }
                        else {
                            popupText += '<tr><td>Website</td><td>-</td></tr>';
                        }
                    }
                    else {
                        popupText += '<tr><td>Website</td><td>-</td></tr>';
                    }

                    if (serviceProperties.hasOwnProperty('email')) {
                        if ((serviceProperties.email !== '') && (serviceProperties.email !== undefined) && (serviceProperties.email !== 'undefined') && (serviceProperties.email !== null) && (serviceProperties.email !== 'null')) {
                            popupText += '<tr><td>E-Mail</td><td>' + serviceProperties.email + '<td></tr>';
                        }
                        else {
                            popupText += '<tr><td>E-Mail</td><td>-</td></tr>';
                        }
                    }
                    else {
                        popupText += '<tr><td>E-Mail</td><td>-</td></tr>';
                    }

                    if (serviceProperties.hasOwnProperty('address')) {
                        if ((serviceProperties.address !== '') && (serviceProperties.address !== undefined) && (serviceProperties.address !== 'undefined') && (serviceProperties.address !== null) && (serviceProperties.address !== 'null')) {
                            popupText += '<tr><td>Address</td><td>' + serviceProperties.address + '</td></tr>';
                        }
                        else {
                            popupText += '<tr><td>Address</td><td>-</td></tr>';
                        }
                    }
                    else {
                        popupText += '<tr><td>Address</td><td>-</td></tr>';
                    }

                    if (serviceProperties.hasOwnProperty('civic')) {
                        if ((serviceProperties.civic !== '') && (serviceProperties.civic !== undefined) && (serviceProperties.civic !== 'undefined') && (serviceProperties.civic !== null) && (serviceProperties.civic !== 'null')) {
                            popupText += '<tr><td>Civic n.</td><td>' + serviceProperties.civic + '</td></tr>';
                        }
                        else {
                            popupText += '<tr><td>Civic n.</td><td>-</td></tr>';
                        }
                    }
                    else {
                        popupText += '<tr><td>Civic n.</td><td>-</td></tr>';
                    }

                    if (serviceProperties.hasOwnProperty('cap')) {
                        if ((serviceProperties.cap !== '') && (serviceProperties.cap !== undefined) && (serviceProperties.cap !== 'undefined') && (serviceProperties.cap !== null) && (serviceProperties.cap !== 'null')) {
                            popupText += '<tr><td>C.A.P.</td><td>' + serviceProperties.cap + '</td></tr>';
                        }
                    }

                    if (serviceProperties.hasOwnProperty('city')) {
                        if ((serviceProperties.city !== '') && (serviceProperties.city !== undefined) && (serviceProperties.city !== 'undefined') && (serviceProperties.city !== null) && (serviceProperties.city !== 'null')) {
                            popupText += '<tr><td>City</td><td>' + serviceProperties.city + '</td></tr>';
                        }
                        else {
                            popupText += '<tr><td>City</td><td>-</td></tr>';
                        }
                    }
                    else {
                        popupText += '<tr><td>City</td><td>-</td></tr>';
                    }

                    if (serviceProperties.hasOwnProperty('province')) {
                        if ((serviceProperties.province !== '') && (serviceProperties.province !== undefined) && (serviceProperties.province !== 'undefined') && (serviceProperties.province !== null) && (serviceProperties.province !== 'null')) {
                            popupText += '<tr><td>Province</td><td>' + serviceProperties.province + '</td></tr>';
                        }
                    }

                    if (serviceProperties.hasOwnProperty('phone')) {
                        if ((serviceProperties.phone !== '') && (serviceProperties.phone !== undefined) && (serviceProperties.phone !== 'undefined') && (serviceProperties.phone !== null) && (serviceProperties.phone !== 'null')) {
                            popupText += '<tr><td>Phone</td><td>' + serviceProperties.phone + '</td></tr>';
                        }
                        else {
                            popupText += '<tr><td>Phone</td><td>-</td></tr>';
                        }
                    }
                    else {
                        popupText += '<tr><td>Phone</td><td>-</td></tr>';
                    }

                    if (serviceProperties.hasOwnProperty('fax')) {
                        if ((serviceProperties.fax !== '') && (serviceProperties.fax !== undefined) && (serviceProperties.fax !== 'undefined') && (serviceProperties.fax !== null) && (serviceProperties.fax !== 'null')) {
                            popupText += '<tr><td>Fax</td><td>' + serviceProperties.fax + '</td></tr>';
                        }
                    }

                    if (serviceProperties.hasOwnProperty('note')) {
                        if ((serviceProperties.note !== '') && (serviceProperties.note !== undefined) && (serviceProperties.note !== 'undefined') && (serviceProperties.note !== null) && (serviceProperties.note !== 'null')) {
                            popupText += '<tr><td>Notes</td><td>' + serviceProperties.note + '</td></tr>';
                        }
                    }

                    if (serviceProperties.hasOwnProperty('agency')) {
                        if ((serviceProperties.agency !== '') && (serviceProperties.agency !== undefined) && (serviceProperties.agency !== 'undefined') && (serviceProperties.agency !== null) && (serviceProperties.agency !== 'null')) {
                            popupText += '<tr><td>Agency</td><td>' + serviceProperties.agency + '</td></tr>';
                        }
                    }

                    if (serviceProperties.hasOwnProperty('code')) {
                        if ((serviceProperties.code !== '') && (serviceProperties.code !== undefined) && (serviceProperties.code !== 'undefined') && (serviceProperties.code !== null) && (serviceProperties.code !== 'null')) {
                            popupText += '<tr><td>Code</td><td>' + serviceProperties.code + '</td></tr>';
                        }
                    }

                    popupText += '</tbody>';
                    popupText += '</table>';

                    if (geoJsonServiceData.hasOwnProperty('busLines')) {
                        if (geoJsonServiceData.busLines.results.bindings.length > 0) {
                            popupText += '<b>Lines: </b>';
                            for (var i = 0; i < geoJsonServiceData.busLines.results.bindings.length; i++) {
                                popupText += '<span style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + geoJsonServiceData.busLines.results.bindings[i].busLine.value + '</span> ';
                            }
                        }
                    }

                    popupText += '</div>';

                    popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDescContainer">';

                    if ((serviceProperties.serviceUri !== '') && (serviceProperties.serviceUri !== undefined) && (serviceProperties.serviceUri !== 'undefined') && (serviceProperties.serviceUri !== null) && (serviceProperties.serviceUri !== 'null')) {
                        popupText += "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + "<br>";
                    }

                    if ((serviceProperties.serviceType !== '') && (serviceProperties.serviceType !== undefined) && (serviceProperties.serviceType !== 'undefined') && (serviceProperties.serviceType !== null) && (serviceProperties.serviceType !== 'null')) {
                        popupText += "Nature: " + serviceProperties.serviceType.split(/_(.+)/)[0] + "<br>";
                        popupText += "Subnature: " + serviceProperties.serviceType.split(/_(.+)/)[1] + "<br><br>";
                    }

                    if (serviceProperties.hasOwnProperty('description')) {
                        if ((serviceProperties.description !== '') && (serviceProperties.description !== undefined) && (serviceProperties.description !== 'undefined') && (serviceProperties.description !== null) && (serviceProperties.description !== 'null')) {
                            popupText += serviceProperties.description + "<br>";
                        }
                        else {
                            popupText += "No description available";
                        }
                    }
                    else {
                        popupText += 'No description available';
                    }

                    popupText += '</div>';

                    popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapContactsContainer">';

                    var hasRealTime = false;

                    if (geoJsonServiceData.hasOwnProperty("realtime")) {
                        if (!jQuery.isEmptyObject(geoJsonServiceData.realtime)) {
                            realTimeData = geoJsonServiceData.realtime;
                            popupText += '<div class="popupLastUpdateContainer centerWithFlex"><b>Last update:&nbsp;</b><span class="popupLastUpdate" data-id="' + latLngId + '"></span></div>';

                            if ((serviceClass.includes("Emergency")) && (serviceSubclass.includes("First aid"))) {
                                //Tabella ad hoc per First Aid
                                popupText += '<table id="' + latLngId + '" class="psPopupTable">';
                                var series = {
                                    "firstAxis": {
                                        "desc": "Priority",
                                        "labels": [
                                            "Red code",
                                            "Yellow code",
                                            "Green code",
                                            "Blue code",
                                            "White code"
                                        ]
                                    },
                                    "secondAxis": {
                                        "desc": "Status",
                                        "labels": [],
                                        "series": []
                                    }
                                };

                                var dataSlot = null;

                                measuredTime = realTimeData.results.bindings[0].measuredTime.value.replace("T", " ").replace("Z", "");

                                for (var i = 0; i < realTimeData.results.bindings.length; i++) {
                                    if (realTimeData.results.bindings[i].state.value.indexOf("estinazione") > 0) {
                                        series.secondAxis.labels.push("Addressed");
                                    }

                                    if (realTimeData.results.bindings[i].state.value.indexOf("ttesa") > 0) {
                                        series.secondAxis.labels.push("Waiting");
                                    }

                                    if (realTimeData.results.bindings[i].state.value.indexOf("isita") > 0) {
                                        series.secondAxis.labels.push("In visit");
                                    }

                                    if (realTimeData.results.bindings[i].state.value.indexOf("emporanea") > 0) {
                                        series.secondAxis.labels.push("Observation");
                                    }

                                    if (realTimeData.results.bindings[i].state.value.indexOf("tali") > 0) {
                                        series.secondAxis.labels.push("Totals");
                                    }

                                    dataSlot = [];
                                    dataSlot.push(realTimeData.results.bindings[i].redCode.value);
                                    dataSlot.push(realTimeData.results.bindings[i].yellowCode.value);
                                    dataSlot.push(realTimeData.results.bindings[i].greenCode.value);
                                    dataSlot.push(realTimeData.results.bindings[i].blueCode.value);
                                    dataSlot.push(realTimeData.results.bindings[i].whiteCode.value);

                                    series.secondAxis.series.push(dataSlot);
                                }

                                var colsQt = parseInt(parseInt(series.firstAxis.labels.length) + 1);
                                var rowsQt = parseInt(parseInt(series.secondAxis.labels.length) + 1);

                                for (var i = 0; i < rowsQt; i++) {
                                    var newRow = $("<tr></tr>");
                                    var z = parseInt(parseInt(i) - 1);

                                    if (i === 0) {
                                        //Riga di intestazione
                                        for (var j = 0; j < colsQt; j++) {
                                            if (j === 0) {
                                                //Cella (0,0)
                                                var newCell = $("<td></td>");

                                                newCell.css("background-color", "transparent");
                                            }
                                            else {
                                                //Celle labels
                                                var k = parseInt(parseInt(j) - 1);
                                                var colLabelBckColor = null;
                                                switch (k) {
                                                    case 0:
                                                        colLabelBckColor = "#ff0000";
                                                        break;

                                                    case 1:
                                                        colLabelBckColor = "#ffff00";
                                                        break;

                                                    case 2:
                                                        colLabelBckColor = "#66ff33";
                                                        break;

                                                    case 3:
                                                        colLabelBckColor = "#66ccff";
                                                        break;

                                                    case 4:
                                                        colLabelBckColor = "#ffffff";
                                                        break;
                                                }

                                                newCell = $("<td><span>" + series.firstAxis.labels[k] + "</span></td>");
                                                newCell.css("font-weight", "bold");
                                                newCell.css("background-color", colLabelBckColor);
                                            }
                                            newRow.append(newCell);
                                        }
                                    }
                                    else {
                                        //Righe dati
                                        for (var j = 0; j < colsQt; j++) {
                                            k = parseInt(parseInt(j) - 1);
                                            if (j === 0) {
                                                //Cella label
                                                newCell = $("<td>" + series.secondAxis.labels[z] + "</td>");
                                                newCell.css("font-weight", "bold");
                                            }
                                            else {
                                                //Celle dati
                                                newCell = $("<td>" + series.secondAxis.series[z][k] + "</td>");
                                                if (i === (rowsQt - 1)) {
                                                    newCell.css('font-weight', 'bold');
                                                    switch (j) {
                                                        case 1:
                                                            newCell.css('background-color', '#ffb3b3');
                                                            break;

                                                        case 2:
                                                            newCell.css('background-color', '#ffff99');
                                                            break;

                                                        case 3:
                                                            newCell.css('background-color', '#d9ffcc');
                                                            break;

                                                        case 4:
                                                            newCell.css('background-color', '#cceeff');
                                                            break;

                                                        case 5:
                                                            newCell.css('background-color', 'white');
                                                            break;
                                                    }
                                                }
                                            }
                                            newRow.append(newCell);
                                        }
                                    }
                                    popupText += newRow.prop('outerHTML');
                                }

                                popupText += '</table>';
                            }
                            else {
                                //Tabella nuovo stile
                                popupText += '<table id="' + latLngId + '" class="gisPopupTable">';

                                //Intestazione
                                popupText += '<thead>';
                                popupText += '<th style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Description</th>';
                                popupText += '<th style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Value</th>';
                                popupText += '<th colspan="5" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Buttons</th>';
                                popupText += '</thead>';

                                //Corpo
                                popupText += '<tbody>';
                                var dataDesc, dataVal, dataLastBtn, data4HBtn, dataDayBtn, data7DayBtn,
                                    data30DayBtn = null;
                                for (var i = 0; i < realTimeData.head.vars.length; i++) {
                                    if (realTimeData.results.bindings[0][realTimeData.head.vars[i]] !== null && realTimeData.results.bindings[0][realTimeData.head.vars[i]] !== undefined) {
                                        if ((realTimeData.results.bindings[0][realTimeData.head.vars[i]]) && (realTimeData.head.vars[i] !== null) && (realTimeData.head.vars[i] !== 'undefined')) {
                                            if ((realTimeData.head.vars[i] !== 'updating') && (realTimeData.head.vars[i] !== 'measuredTime') && (realTimeData.head.vars[i] !== 'instantTime')) {
                                                if (!realTimeData.results.bindings[0][realTimeData.head.vars[i]].value.includes('Not Available')) {
                                                    //realTimeData.results.bindings[0][realTimeData.head.vars[i]].value = '-';
                                                    /*   dataDesc = realTimeData.head.vars[i].replace(/([A-Z])/g, ' $1').replace(/^./, function (str) {
                                                           return str.toUpperCase();
                                                       }); */
                                                    dataDesc = realTimeData.head.vars[i];
                                                    dataVal = realTimeData.results.bindings[0][realTimeData.head.vars[i]].value;
                                                    dataLastBtn = '<td><button data-id="' + latLngId + '" type="button" class="lastValueBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-id="' + latLngId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-lastDataClicked="false" data-targetWidgets="' + targetWidgets + '" data-lastValue="' + realTimeData.results.bindings[0][realTimeData.head.vars[i]].value + '" data-color1="' + color1 + '" data-color2="' + color2 + '">Last<br>value</button></td>';
                                                    data4HBtn = '<td><button data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-fakeid="' + fakeId + '" data-id="' + latLngId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="4 Hours" data-range="4/HOUR" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">Last<br>4 hours</button></td>';
                                                    dataDayBtn = '<td><button data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="Day" data-range="1/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">Last<br>24 hours</button></td>';
                                                    data7DayBtn = '<td><button data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="7 days" data-range="7/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">Last<br>7 days</button></td>';
                                                    data30DayBtn = '<td><button data-id="' + latLngId + '" type="button" class="timeTrendBtn btn btn-sm" data-fake="' + fake + '" data-id="' + fakeId + '" data-field="' + realTimeData.head.vars[i] + '" data-serviceUri="' + feature.properties.serviceUri + '" data-timeTrendClicked="false" data-range-shown="30 days" data-range="30/DAY" data-targetWidgets="' + targetWidgets + '" data-color1="' + color1 + '" data-color2="' + color2 + '">Last<br>30 days</button></td>';
                                                    popupText += '<tr><td>' + dataDesc + '</td><td>' + dataVal + '</td>' + dataLastBtn + data4HBtn + dataDayBtn + data7DayBtn + data30DayBtn + '</tr>';
                                                }
                                            } else {
                                                measuredTime = realTimeData.results.bindings[0][realTimeData.head.vars[i]].value.replace("T", " ");
                                                var now = new Date();
                                                var measuredTimeDate = new Date(measuredTime);
                                                rtDataAgeSec = Math.abs(now - measuredTimeDate) / 1000;
                                            }
                                        }
                                    }
                                }
                                popupText += '</tbody>';
                                popupText += '</table>';
                                popupText += '<p><b>Keep data on target widget(s) after popup close: </b><input data-id="' + latLngId + '" type="checkbox" class="gisPopupKeepDataCheck" data-keepData="false"/></p>';
                            }

                            hasRealTime = true;
                        }
                    }

                    popupText += '</div>';

                    newpopup = L.popup({
                        closeOnClick: false,//Non lo levare, sennò autoclose:false non funziona
                        autoClose: false,
                        offset: [15, 0],
                        minWidth: 435,
                        maxWidth: 435
                    }).setContent(popupText);

                    event.target.bindPopup(newpopup).openPopup();

                    if (hasRealTime) {
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').show();
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').trigger("click");
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap span.popupLastUpdate[data-id="' + latLngId + '"]').html(measuredTime);
                    }
                    else {
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').hide();
                    }

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapDetailsBtn[data-id="' + latLngId + '"]').off('click');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapDetailsBtn[data-id="' + latLngId + '"]').click(function () {
                        $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDataContainer').hide();
                        $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDetailsContainer').show();
                        $('#' + widgetName + '_modalLinkOpenBodyDefaultMap button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                        $(this).addClass('recreativeEventMapBtnActive');
                    });

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapDescriptionBtn[data-id="' + latLngId + '"]').off('click');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapDescriptionBtn[data-id="' + latLngId + '"]').click(function () {
                        $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDataContainer').hide();
                        $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDescContainer').show();
                        $('#' + widgetName + '_modalLinkOpenBodyDefaultMap button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                        $(this).addClass('recreativeEventMapBtnActive');
                    });

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').off('click');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').click(function () {
                        $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDataContainer').hide();
                        $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapContactsContainer').show();
                        $('#' + widgetName + '_modalLinkOpenBodyDefaultMap button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                        $(this).addClass('recreativeEventMapBtnActive');
                    });

                    if (hasRealTime) {
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapContactsBtn[data-id="' + latLngId + '"]').trigger("click");
                    }

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').css("background", color2);
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').css("border", "none");
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').css("color", "black");

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap table.gisPopupTable[id="' + latLngId + '"] button.btn-sm').focus(function () {
                        $(this).css("outline", "0");
                    });

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap input.gisPopupKeepDataCheck[data-id="' + latLngId + '"]').off('click');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap input.gisPopupKeepDataCheck[data-id="' + latLngId + '"]').click(function () {
                        if ($(this).attr("data-keepData") === "false") {
                            $(this).attr("data-keepData", "true");
                        }
                        else {
                            $(this).attr("data-keepData", "false");
                        }
                    });

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').off('mouseenter');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').off('mouseleave');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn[data-id="' + latLngId + '"]').hover(function () {
                        if ($(this).attr("data-lastDataClicked") === "false") {
                            $(this).css("background", color1);
                            $(this).css("background", "-webkit-linear-gradient(left, " + color1 + ", " + color2 + ")");
                            $(this).css("background", "background: -o-linear-gradient(left, " + color1 + ", " + color2 + ")");
                            $(this).css("background", "background: -moz-linear-gradient(left, " + color1 + ", " + color2 + ")");
                            $(this).css("background", "background: linear-gradient(to left, " + color1 + ", " + color2 + ")");
                            $(this).css("font-weight", "bold");
                        }

                        var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                        var colIndex = $(this).parent().index();
                        //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html();
                        var title = $(this).parents("tr").find("td").eq(0).html();

                        for (var i = 0; i < widgetTargetList.length; i++) {
                            $.event.trigger({
                                type: "mouseOverLastDataFromExternalContentGis_" + widgetTargetList[i],
                                eventGenerator: $(this),
                                targetWidget: widgetTargetList[i],
                                value: $(this).attr("data-lastValue"),
                                color1: $(this).attr("data-color1"),
                                color2: $(this).attr("data-color2"),
                                widgetTitle: title
                            });
                        }
                    },
                        function () {
                            if ($(this).attr("data-lastDataClicked") === "false") {
                                $(this).css("background", color2);
                                $(this).css("font-weight", "normal");
                            }
                            var widgetTargetList = $(this).attr("data-targetWidgets").split(',');

                            for (var i = 0; i < widgetTargetList.length; i++) {
                                $.event.trigger({
                                    type: "mouseOutLastDataFromExternalContentGis_" + widgetTargetList[i],
                                    eventGenerator: $(this),
                                    targetWidget: widgetTargetList[i],
                                    value: $(this).attr("data-lastValue"),
                                    color1: $(this).attr("data-color1"),
                                    color2: $(this).attr("data-color2")
                                });
                            }
                        });

                    //Disabilitiamo i 4Hours se last update più vecchio di 4 ore
                    if (rtDataAgeSec > 14400) {
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="4/HOUR"]').attr("data-disabled", "true");
                        //Disabilitiamo i 24Hours se last update più vecchio di 24 ore
                        if (rtDataAgeSec > 86400) {
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="1/DAY"]').attr("data-disabled", "true");
                            //Disabilitiamo i 7 days se last update più vecchio di 7 days
                            if (rtDataAgeSec > 604800) {
                                $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="7/DAY"]').attr("data-disabled", "true");
                                //Disabilitiamo i 30 days se last update più vecchio di 30 days
                                if (rtDataAgeSec > 18144000) {
                                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="30/DAY"]').attr("data-disabled", "true");
                                }
                                else {
                                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="30/DAY"]').attr("data-disabled", "false");
                                }
                            }
                            else {
                                $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen button.timeTrendBtn[data-id="' + latLngId + '"][data-range="7/DAY"]').attr("data-disabled", "false");
                            }
                        }
                        else {
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="1/DAY"]').attr("data-disabled", "false");
                        }
                    }
                    else {
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="4/HOUR"]').attr("data-disabled", "false");
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="1/DAY"]').attr("data-disabled", "false");
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="7/DAY"]').attr("data-disabled", "false");
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"][data-range="30/DAY"]').attr("data-disabled", "false");
                    }

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').off('mouseenter');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').off('mouseleave');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"]').hover(function () {
                        if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                            $(this).css("background-color", "#e6e6e6");
                            $(this).off("hover");
                            $(this).off("click");
                        }
                        else {
                            if ($(this).attr("data-timeTrendClicked") === "false") {
                                $(this).css("background", color1);
                                $(this).css("background", "-webkit-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                $(this).css("background", "background: -o-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                $(this).css("background", "background: -moz-linear-gradient(left, " + color1 + ", " + color2 + ")");
                                $(this).css("background", "background: linear-gradient(to left, " + color1 + ", " + color2 + ")");
                                $(this).css("font-weight", "bold");
                            }

                            var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                            //var colIndex = $(this).parent().index();
                            //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html() + " - " + $(this).attr("data-range-shown");
                            var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");

                            for (var i = 0; i < widgetTargetList.length; i++) {
                                $.event.trigger({
                                    type: "mouseOverTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                    eventGenerator: $(this),
                                    targetWidget: widgetTargetList[i],
                                    value: $(this).attr("data-lastValue"),
                                    color1: $(this).attr("data-color1"),
                                    color2: $(this).attr("data-color2"),
                                    widgetTitle: title
                                });
                            }
                        }
                    },
                        function () {
                            if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                $(this).css("background-color", "#e6e6e6");
                                $(this).off("hover");
                                $(this).off("click");
                            }
                            else {
                                if ($(this).attr("data-timeTrendClicked") === "false") {
                                    $(this).css("background", color2);
                                    $(this).css("font-weight", "normal");
                                }

                                var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "mouseOutTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i],
                                        value: $(this).attr("data-lastValue"),
                                        color1: $(this).attr("data-color1"),
                                        color2: $(this).attr("data-color2")
                                    });
                                }
                            }
                        });

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn[data-id=' + latLngId + ']').off('click');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn[data-id=' + latLngId + ']').click(function (event) {
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').each(function (i) {
                            $(this).css("background", $(this).attr("data-color2"));
                        });
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').css("font-weight", "normal");
                        $(this).css("background", $(this).attr("data-color1"));
                        $(this).css("font-weight", "bold");
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').attr("data-lastDataClicked", "false");
                        $(this).attr("data-lastDataClicked", "true");
                        var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                        var colIndex = $(this).parent().index();
                        var title = $(this).parents("tr").find("td").eq(0).html();

                        for (var i = 0; i < widgetTargetList.length; i++) {
                            $.event.trigger({
                                type: "showLastDataFromExternalContentGis_" + widgetTargetList[i],
                                eventGenerator: $(this),
                                targetWidget: widgetTargetList[i],
                                value: $(this).attr("data-lastValue"),
                                color1: $(this).attr("data-color1"),
                                color2: $(this).attr("data-color2"),
                                widgetTitle: title,
                                field: $(this).attr("data-field"),
                                serviceUri: $(this).attr("data-serviceUri"),
                                marker: markersCache["" + $(this).attr("data-id") + ""],
                                mapRef: fullscreendefaultMapRef,
                                fake: $(this).attr("data-fake"),
                                fakeId: $(this).attr("data-fakeId")
                            });
                        }
                    });

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').off('click');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').click(function (event) {
                        if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                            $(this).css("background-color", "#e6e6e6");
                            $(this).off("hover");
                            $(this).off("click");
                        }
                        else {
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').css("background", $(this).attr("data-color2"));
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').css("font-weight", "normal");
                            $(this).css("background", $(this).attr("data-color1"));
                            $(this).css("font-weight", "bold");
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').attr("data-timeTrendClicked", "false");
                            $(this).attr("data-timeTrendClicked", "true");
                            var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                            var colIndex = $(this).parent().index();
                            var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");
                            var lastUpdateTime = $(this).parents('div.recreativeEventMapContactsContainer').find('span.popupLastUpdate').html();

                            var now = new Date();
                            var lastUpdateDate = new Date(lastUpdateTime);
                            var diff = parseFloat(Math.abs(now - lastUpdateDate) / 1000);
                            var range = $(this).attr("data-range");

                            for (var i = 0; i < widgetTargetList.length; i++) {
                                $.event.trigger({
                                    type: "showTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                    eventGenerator: $(this),
                                    targetWidget: widgetTargetList[i],
                                    range: range,
                                    color1: $(this).attr("data-color1"),
                                    color2: $(this).attr("data-color2"),
                                    widgetTitle: title,
                                    field: $(this).attr("data-field"),
                                    serviceUri: $(this).attr("data-serviceUri"),
                                    marker: markersCache["" + $(this).attr("data-id") + ""],
                                    mapRef: fullscreendefaultMapRef,
                                    fake: false
                                    //fake: $(this).attr("data-fake")
                                });
                            }
                        }
                    });

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"]').each(function (i) {
                        if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                            $(this).css("background-color", "#e6e6e6");
                            $(this).off("hover");
                            $(this).off("click");
                        }
                    });

                    fullscreendefaultMapRef.off('popupclose');
                    fullscreendefaultMapRef.on('popupclose', function (closeEvt) {
                        var popupContent = $('<div></div>');
                        popupContent.html(closeEvt.popup._content);

                        if (popupContent.find("button.lastValueBtn").length > 0) {
                            var widgetTargetList = popupContent.find("button.lastValueBtn").eq(0).attr("data-targetWidgets").split(',');

                            if (($('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn[data-lastDataClicked=true]').length > 0) && ($('input.gisPopupKeepDataCheck').attr('data-keepData') === "false")) {
                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "restoreOriginalLastDataFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i],
                                        value: $(this).attr("data-lastValue"),
                                        color1: $(this).attr("data-color1"),
                                        color2: $(this).attr("data-color2")
                                    });
                                }
                            }

                            if (($('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-timeTrendClicked=true]').length > 0) && ($('input.gisPopupKeepDataCheck').attr('data-keepData') === "false")) {
                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "restoreOriginalTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i]
                                    });
                                }
                            }
                        }
                    });

                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap div.leaflet-popup').off('click');
                    $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap div.leaflet-popup').on('click', function () {
                        var compLatLngId = $(this).find('input[type=hidden]').val();

                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap div.leaflet-popup').css("z-index", "-1");
                        $(this).css("z-index", "999999");

                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap input.gisPopupKeepDataCheck').off('click');
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap input.gisPopupKeepDataCheck[data-id="' + compLatLngId + '"]').click(function () {
                            if ($(this).attr("data-keepData") === "false") {
                                $(this).attr("data-keepData", "true");
                            }
                            else {
                                $(this).attr("data-keepData", "false");
                            }
                        });

                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').off('mouseenter');
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').off('mouseleave');
                        $(this).find('button.lastValueBtn[data-id="' + compLatLngId + '"]').hover(function () {
                            if ($(this).attr("data-lastDataClicked") === "false") {
                                $(this).css("background", $(this).attr('data-color1'));
                                $(this).css("background", "-webkit-linear-gradient(left, " + $(this).attr('data-color1') + ", " + $(this).attr('data-color2') + ")");
                                $(this).css("background", "background: -o-linear-gradient(left, " + $(this).attr('data-color1') + ", " + $(this).attr('data-color2') + ")");
                                $(this).css("background", "background: -moz-linear-gradient(left, " + $(this).attr('data-color1') + ", " + $(this).attr('data-color2') + ")");
                                $(this).css("background", "background: linear-gradient(to left, " + $(this).attr('data-color1') + ", " + $(this).attr('data-color2') + ")");
                                $(this).css("font-weight", "bold");
                            }

                            var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                            var colIndex = $(this).parent().index();
                            //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html();
                            var title = $(this).parents("tr").find("td").eq(0).html();

                            for (var i = 0; i < widgetTargetList.length; i++) {
                                $.event.trigger({
                                    type: "mouseOverLastDataFromExternalContentGis_" + widgetTargetList[i],
                                    eventGenerator: $(this),
                                    targetWidget: widgetTargetList[i],
                                    value: $(this).attr("data-lastValue"),
                                    color1: $(this).attr("data-color1"),
                                    color2: $(this).attr("data-color2"),
                                    widgetTitle: title
                                });
                            }
                        },
                            function () {
                                if ($(this).attr("data-lastDataClicked") === "false") {
                                    $(this).css("background", $(this).attr('data-color2'));
                                    $(this).css("font-weight", "normal");
                                }
                                var widgetTargetList = $(this).attr("data-targetWidgets").split(',');

                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "mouseOutLastDataFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i],
                                        value: $(this).attr("data-lastValue"),
                                        color1: $(this).attr("data-color1"),
                                        color2: $(this).attr("data-color2")
                                    });
                                }
                            });

                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').off('mouseenter');
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').off('mouseleave');
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + compLatLngId + '"]').hover(function () {
                            if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                $(this).css("background-color", "#e6e6e6");
                                $(this).off("hover");
                                $(this).off("click");
                            }
                            else {
                                if ($(this).attr("data-timeTrendClicked") === "false") {
                                    $(this).css("background", $(this).attr('data-color1'));
                                    $(this).css("background", "-webkit-linear-gradient(left, " + $(this).attr('data-color1') + ", " + $(this).attr('data-color2') + ")");
                                    $(this).css("background", "background: -o-linear-gradient(left, " + $(this).attr('data-color1') + ", " + $(this).attr('data-color2') + ")");
                                    $(this).css("background", "background: -moz-linear-gradient(left, " + $(this).attr('data-color1') + ", " + $(this).attr('data-color2') + ")");
                                    $(this).css("background", "background: linear-gradient(to left, " + $(this).attr('data-color1') + ", " + $(this).attr('data-color2') + ")");
                                    $(this).css("font-weight", "bold");
                                }

                                var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                var colIndex = $(this).parent().index();
                                //var title = $(this).parents("tbody").find("tr").eq(0).find("th").eq(colIndex).html() + " - " + $(this).attr("data-range-shown");
                                var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");

                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "mouseOverTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i],
                                        value: $(this).attr("data-lastValue"),
                                        color1: $(this).attr("data-color1"),
                                        color2: $(this).attr("data-color2"),
                                        widgetTitle: title
                                    });
                                }
                            }
                        },
                            function () {
                                if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                    $(this).css("background-color", "#e6e6e6");
                                    $(this).off("hover");
                                    $(this).off("click");
                                }
                                else {
                                    if ($(this).attr("data-timeTrendClicked") === "false") {
                                        $(this).css("background", $(this).attr('data-color2'));
                                        $(this).css("font-weight", "normal");
                                    }

                                    var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                    for (var i = 0; i < widgetTargetList.length; i++) {
                                        $.event.trigger({
                                            type: "mouseOutTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                            eventGenerator: $(this),
                                            targetWidget: widgetTargetList[i],
                                            value: $(this).attr("data-lastValue"),
                                            color1: $(this).attr("data-color1"),
                                            color2: $(this).attr("data-color2")
                                        });
                                    }
                                }
                            });

                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').off('click');
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').click(function (event) {
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').each(function (i) {
                                $(this).css("background", $(this).attr("data-color2"));
                            });
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').css("font-weight", "normal");
                            $(this).css("background", $(this).attr("data-color1"));
                            $(this).css("font-weight", "bold");
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.lastValueBtn').attr("data-lastDataClicked", "false");
                            $(this).attr("data-lastDataClicked", "true");
                            var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                            var colIndex = $(this).parent().index();
                            var title = $(this).parents("tr").find("td").eq(0).html();

                            for (var i = 0; i < widgetTargetList.length; i++) {
                                $.event.trigger({
                                    type: "showLastDataFromExternalContentGis_" + widgetTargetList[i],
                                    eventGenerator: $(this),
                                    targetWidget: widgetTargetList[i],
                                    value: $(this).attr("data-lastValue"),
                                    color1: $(this).attr("data-color1"),
                                    color2: $(this).attr("data-color2"),
                                    widgetTitle: title,
                                    marker: markersCache["" + $(this).attr("data-id") + ""],
                                    mapRef: fullscreendefaultMapRef,
                                    field: $(this).attr("data-field"),
                                    serviceUri: $(this).attr("data-serviceUri"),
                                    fake: $(this).attr("data-fake"),
                                    fakeId: $(this).attr("data-fakeId")
                                });
                            }
                        });

                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').off('click');
                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').click(function (event) {
                            if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                $(this).css("background-color", "#e6e6e6");
                                $(this).off("hover");
                                $(this).off("click");
                            }
                            else {
                                $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').each(function (i) {
                                    $(this).css("background", $(this).attr("data-color2"));
                                });
                                $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').css("font-weight", "normal");
                                $(this).css("background", $(this).attr("data-color1"));
                                $(this).css("font-weight", "bold");
                                $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn').attr("data-timeTrendClicked", "false");
                                $(this).attr("data-timeTrendClicked", "true");
                                var widgetTargetList = $(this).attr("data-targetWidgets").split(',');
                                var colIndex = $(this).parent().index();
                                var title = $(this).parents("tr").find("td").eq(0).html() + " - " + $(this).attr("data-range-shown");
                                var lastUpdateTime = $(this).parents('div.recreativeEventMapContactsContainer').find('span.popupLastUpdate').html();

                                var now = new Date();
                                var lastUpdateDate = new Date(lastUpdateTime);
                                var diff = parseFloat(Math.abs(now - lastUpdateDate) / 1000);
                                var range = $(this).attr("data-range");

                                for (var i = 0; i < widgetTargetList.length; i++) {
                                    $.event.trigger({
                                        type: "showTimeTrendFromExternalContentGis_" + widgetTargetList[i],
                                        eventGenerator: $(this),
                                        targetWidget: widgetTargetList[i],
                                        range: range,
                                        color1: $(this).attr("data-color1"),
                                        color2: $(this).attr("data-color2"),
                                        widgetTitle: title,
                                        field: $(this).attr("data-field"),
                                        serviceUri: $(this).attr("data-serviceUri"),
                                        marker: markersCache["" + $(this).attr("data-id") + ""],
                                        mapRef: fullscreendefaultMapRef,
                                        fake: $(this).attr("data-fake"),
                                        fakeId: $(this).attr("data-fakeId")
                                    });
                                }
                            }
                        });

                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.timeTrendBtn[data-id="' + latLngId + '"]').each(function (i) {
                            if (isNaN(parseFloat($(this).parents('tr').find('td').eq(1).html())) || ($(this).attr("data-disabled") === "true")) {
                                $(this).css("background-color", "#e6e6e6");
                                $(this).off("hover");
                                $(this).off("click");
                            }
                        });
                    });
                },
                error: function (errorData) {
                    console.log("Error in data retrieval");
                    console.log(JSON.stringify(errorData));
                    var serviceProperties = feature.properties;

                    var underscoreIndex = serviceProperties.serviceType.indexOf("_");
                    var serviceClass = serviceProperties.serviceType.substr(0, underscoreIndex);
                    var serviceSubclass = serviceProperties.serviceType.substr(underscoreIndex);
                    serviceSubclass = serviceSubclass.replace(/_/g, " ");

                    popupText = '<h3 class="gisPopupTitle">' + serviceProperties.name + '</h3>' +
                        '<p><b>Typology: </b>' + serviceClass + " - " + serviceSubclass + '</p>' +
                        '<p><i>Data are limited due to an issue in their retrieval</i></p>';

                    event.target.bindPopup(popupText, {
                        offset: [15, 0],
                        minWidth: 215,
                        maxWidth: 600
                    }).openPopup();
                }
            });
        });

        return marker;
    }

    function createFullscreenModal() {
        var fullscreenModal = $('<div class="modal fade" tabindex="-1" id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen" class="modalLinkOpen" role="dialog" aria-labelledby="myModalLabel">' +
            '<div class="modal-dialog" role="document">' +
            '<div class="modal-content">' +
            '<div class="modal-header centerWithFlex">' +
            '<h4 class="modal-title"></h4>' +
            '</div>' +
            '<div class="modal-body">' +
            '<div class="modalLinkOpenBody">' +
            '<iframe class="modalLinkOpenBodyIframe"></iframe>' +
            '<div id="<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyMap" class="modalLinkOpenBodyMap" data-mapRef="null"></div>' +
            '<div id="<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap" class="modalLinkOpenBodyDefaultMap" data-mapRef="null"></div>' +
            '<div id="<?= $_REQUEST['name_w'] ?>_modalLinkOpenGisMap" class="modalLinkOpenGisMap" data-mapRef="null"></div>' +
            '<div id="<?= $_REQUEST['name_w'] ?>_modalLinkOpenGisTimeTrend" class="modalLinkOpenGisTimeTrend"></div>' +
            '</div>' +
            '<div id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_modalLinkLoading" class="loadingDiv">' +
            '<div class="LoadingTextDiv">' +
            '<p>Loading data, please wait</p>' +
            '</div>' +
            '<div class="loadingIconDiv">' +
            '<i class="fa fa-spinner fa-spin"></i>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '<div class="modal-footer">' +
            '<button type="button" id="<?= $_REQUEST['name_w'] ?>_modalLinkOpenCloseBtn" class="btn btn-primary">Back to dashboard</button>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '</div>');

        fullscreenModal.insertAfter("#newTabLinkOpenImpossibile");
        fullscreenModal.css("font-family", "Verdana");
        fullscreenModal.find("div.modal-dialog").css("width", "95vw");
        fullscreenModal.find("div.modalLinkOpenBody").css("height", "80vh");

        fullscreenModal.find("iframe").css("width", "100%");
        fullscreenModal.find("iframe").css("height", "100%");
        fullscreenModal.find("iframe").hide();

        fullscreenModal.find("div.modalLinkOpenBodyMap").css("width", "100%");
        fullscreenModal.find("div.modalLinkOpenBodyMap").css("height", "100%");
        fullscreenModal.find("div.modalLinkOpenBodyMap").hide();

        fullscreenModal.find("div.modalLinkOpenBodyDefaultMap").css("width", "100%");
        fullscreenModal.find("div.modalLinkOpenBodyDefaultMap").css("height", "100%");
        fullscreenModal.find("div.modalLinkOpenBodyDefaultMap").hide();

        fullscreenModal.find("div.modalLinkOpenGisMap").css("width", "100%");
        fullscreenModal.find("div.modalLinkOpenGisMap").css("height", "100%");
        fullscreenModal.find("div.modalLinkOpenGisMap").css("-webkit-transition", "height 0.5s");
        fullscreenModal.find("div.modalLinkOpenGisMap").css("transition", "height 0.5s");
        fullscreenModal.find("div.modalLinkOpenGisMap").hide();

        fullscreenModal.find("div.modalLinkOpenGisTimeTrend").css("width", "100%");
        fullscreenModal.find("div.modalLinkOpenGisTimeTrend").css("height", "0vh");
        fullscreenModal.find("div.modalLinkOpenGisTimeTrend").css("background", "white");
        fullscreenModal.find("div.modalLinkOpenGisTimeTrend").hide();

        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpenCloseBtn").off();
        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpenCloseBtn").click(function () {
                 /*   if ($("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen div.modalLinkOpenBodyDefaultMap").is(":visible")) {

            fullscreendefaultMapRef.off();
            fullscreendefaultMapRef.remove();
        } */

                    if ($("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen div.modalLinkOpenBodyMap").is(":visible")) {
            fullscreenMapRef.off();
            fullscreenMapRef.remove();
        }

        if ($("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen div.modalLinkOpenGisMap").is(":visible")) {
            for (var key in gisGeometryTankForFullscreen) {
                gisGeometryTankForFullscreen[key].shown = false;
                gisGeometryTankForFullscreen[key].lastConsumedIndex = 0;
            }

            clearInterval(checkTankInterval);
            gisFullscreenMapRef.off();
            gisFullscreenMapRef.remove();
        }

        fullscreenModal.find("div.modalLinkOpenGisMap").css("height", "80vh");
        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpenGisTimeTrend").css("height", "0vh");
        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpenGisTimeTrend").hide();
        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpenGisTimeTrend").empty();

        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen").modal('hide');
        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen div.modalLinkOpenBodyMap").modal('hide');
        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen div.modalLinkOpenBodyDefaultMap").modal('hide');
        var stopFlag = 1;
    });
            }

    //calcolo automatico del rettangolo di dimensioni minime per mostrare tutti e soli i pin col massimo grado di zoom possibile
    function resizeMapView(mapRef) {

        let minLat = +90;
        let minLng = +180;
        let maxLat = -90;
        let maxLng = -180;


        for (let i = 0; i < map.eventsOnMap.length; i++) {
            if (map.eventsOnMap[i].eventType !== 'heatmap') {
                if (map.eventsOnMap[i].eventType === 'evacuationPlan') {
                    if (map.eventsOnMap[i].polyGroup.minLng < minLng) {
                        minLng = map.eventsOnMap[i].polyGroup.minLng;
                    }

                    if (map.eventsOnMap[i].polyGroup.maxLng > maxLng) {
                        maxLng = map.eventsOnMap[i].polyGroup.maxLng;
                    }

                    if (map.eventsOnMap[i].polyGroup.minLat < minLat) {
                        minLat = map.eventsOnMap[i].polyGroup.minLat;
                    }

                    if (map.eventsOnMap[i].polyGroup.maxLat > maxLat) {
                        maxLat = map.eventsOnMap[i].polyGroup.maxLat;
                    }
                }
                if (map.eventsOnMap[i].eventType === 'trafficRealTimeDetails') {
                    if (map.eventsOnMap[i].minLng < minLng) {
                        minLng = map.eventsOnMap[i].minLng;
                    }

                    if (map.eventsOnMap[i].maxLng > maxLng) {
                        maxLng = map.eventsOnMap[i].maxLng;
                    }

                    if (map.eventsOnMap[i].minLat < minLat) {
                        minLat = map.eventsOnMap[i].minLat;
                    }

                    if (map.eventsOnMap[i].maxLat > maxLat) {
                        maxLat = map.eventsOnMap[i].maxLat;
                    }
                }
                else {
                    if (map.eventsOnMap[i].lng < minLng) {
                        minLng = map.eventsOnMap[i].lng;
                    }

                    if (map.eventsOnMap[i].lng > maxLng) {
                        maxLng = map.eventsOnMap[i].lng;
                    }

                    if (map.eventsOnMap[i].lat < minLat) {
                        minLat = map.eventsOnMap[i].lat;
                    }

                    if (map.eventsOnMap[i].lat > maxLat) {
                        maxLat = map.eventsOnMap[i].lat;
                    }
                }

            }
        }

        if (map.eventsOnMap.length > 0) {
            mapRef.fitBounds([
                [minLat, minLng],
                [maxLat, maxLng]
            ]);
        }
        else {
            var latInit = 43.769789;
            var lngInit = 11.255694;
            //    map.defaultMapRef.setView([43.769789, 11.255694], 11);
            //   map.defaultMapRef.setView([43.769789, 11.255694], widgetParameters.zoom);
            if (widgetParameters.latLng[0] != null && widgetParameters.latLng[0] != '') {
                latInit = widgetParameters.latLng[0];
            }
            if (widgetParameters.latLng[1] != null && widgetParameters.latLng[1] != '') {
                lngInit = widgetParameters.latLng[1];
            }
            map.defaultMapRef.setView([latInit, lngInit], widgetParameters.zoom);
        }
    }

    function addDefaultBaseMap(map) {
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
            maxZoom: leafletMaxZoom,
            maxNativeZoom: leafletNativeMaxZoom
        }).addTo(map);
    }

    //Tipicamente questa funzione viene invocata dopo che sono stati scaricati i dati per il widget (se ne ha bisogno) e ci va dentro la logica che costruisce il contenuto del widget
    function populateWidget() {
        let lastPopup = null;

        showWidgetContent(widgetName);

        let mapDivLocal = "<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_map";
        map.mapName = widgetName;
        map.mapDivLocal = mapDivLocal;
        var latInit = 43.769789;
        var lngInit = 11.255694;
        //    console.log("Map ZOOM: " + widgetParameters.zoom);
        //    map.defaultMapRef = L.map(mapDivLocal).setView([43.769789, 11.255694], 11);
        //    map.defaultMapRef = L.map(mapDivLocal).setView([43.769789, 11.255694], widgetParameters.zoom);
        if (widgetParameters.latLng[0] != null && widgetParameters.latLng[0] != '') {
            latInit = widgetParameters.latLng[0];
        }
        if (widgetParameters.latLng[1] != null && widgetParameters.latLng[1] != '') {
            lngInit = widgetParameters.latLng[1];
        }
        map.defaultMapRef = L.map(mapDivLocal).setView([latInit, lngInit], widgetParameters.zoom);

        //Inserimento button per drill down
        if (widgetParameters.mode && widgetParameters.mode == "ckeditor" && code) {
            var customControl = L.Control.extend({

                options: {
                    position: 'topleft'
                    //control position - allowed: 'topleft', 'topright', 'bottomleft', 'bottomright'
                },

                onAdd: function (map) {
                    var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');

                    container.style.backgroundColor = 'white';
                    //container.style.backgroundImage = "url('../img/filter-icon.png')";
                    container.style.width = '26px';
                    container.style.height = '26px';
                    container.id = "customLeafletControlDiv";

                    container.onclick = function () {

                        if (getCoordsClick != null) {
                            map.off('click', getCoordsClick)
                        }
                        var selectedData = {};
                        selectedData.event = "zoom";
                        selectedData.layers = {};
                        selectedData.bounds = map.getBounds();
                        let i = 0, lat, lng;
                        for (var type in gisLayersOnMap) {
                            for (var l in gisLayersOnMap[type]._layers) {
                                lng = gisLayersOnMap[type]._layers[l].feature.geometry.coordinates[0];
                                lat = gisLayersOnMap[type]._layers[l].feature.geometry.coordinates[1];
                                if (lng <= selectedData.bounds._northEast.lng && lng >= selectedData.bounds._southWest.lng && lat <= selectedData.bounds._northEast.lat && lat >= selectedData.bounds._southWest.lat) {
                                    selectedData.layers[i] = gisLayersOnMap[type]._layers[l].feature.properties;
                                    i++;
                                }
                            }
                        }
                        let boxCoord = map.getBounds();
                        if (connections != null) {
                            selectedData.connections = connections;
                        }
                        selectedDataJson = JSON.stringify(selectedData);

                        let j = 1;
                        if (localStorage.getItem("events") == null) {

                            var events = [];
                            events.push("MapZoom1");
                            localStorage.setItem("events", JSON.stringify(events));
                        }
                        else {
                            var events = JSON.parse(localStorage.getItem("events"));
                            for (var e in events) {
                                if (events[e].slice(0, 7) == "MapZoom")
                                    j = j + 1;
                            }
                            events.push("MapZoom" + j);
                            localStorage.setItem("events", JSON.stringify(events));
                        }

                        let newId = "MapZoom" + j;
                        $('#BIMenuCnt').append('<div id="' + newId + '" class="row" data-selected="false"></div>');
                        $('#' + newId).append('<div class="col-md-12 orgMenuSubItemCnt">' + newId + '</div>');
                        $('#' + newId).on("click", function () {
                            var widgets = JSON.parse(localStorage.getItem("widgets"));
                            var index = JSON.parse(localStorage.getItem("events")).indexOf(newId);
                            for (var w in widgets) {
                                if (widgets[w] != null) {
                                    $('body').trigger({
                                        type: "reloadPreviousContent_" + widgets[w],
                                        index: index
                                    });
                                }
                            }
                        });
                        $('#' + newId).mouseover(function () {
                            $('#' + newId).css('cursor', 'pointer');
                        });
                        if (getCoordsClick != null) {
                            map.on('click', getCoordsClick)
                        }
                        if (widgetParameters.mode && widgetParameters.mode == "ckeditor" && code) {
                            try {
                                execute_<?= $_REQUEST['name_w'] ?>(selectedDataJson);
                            } catch (e) {
                                console.log("Error in JS function from marker click on " + widgetName);
                            }
                        }
                    }
                    return container;
                },

            });

            map.defaultMapRef.addControl(new customControl());
            $("#customLeafletControlDiv").html(" Drill ");
            $("#customLeafletControlDiv").on("mouseover", function () {
                $(this).css('cursor', 'pointer');
                // console.log("Mouse Over");
            });
        }
        //
        map.eventsOnMap = eventsOnMap;

        oms = new OverlappingMarkerSpiderfier(map.defaultMapRef, { keepSpiderfied: true });
        oms.addListener('click', function (marker) {
            marker.openPopup();
            try{                
                if ($('#currentStatusEdit').val() == 'streets') {
                    dragPopup(document.getElementById('considerOrNotConsiderPanel').parentElement.parentElement.parentElement.parentElement.parentElement, document.getElementById('considerOrNotConsiderPanel'));
                } else {
                    dragPopup(document.getElementById('considerOrNotConsiderPanelView').parentElement.parentElement.parentElement.parentElement.parentElement, document.getElementById('considerOrNotConsiderPanelView'));
                }
            } catch {
                console.log('It is a other sensor popup');
            }
        });

        oms.addListener('spiderfy', function (markers) {
            //    map.defaultMapRef.closePopup();
        });

        oms.addListener('unspiderfy', function (markers) {
            for (let n = 0; n < $(".leaflet-popup-close-button").length; n++) {
                $(".leaflet-popup-close-button")[n].click();
            }
        });

        // Visualize default Orthomap, if configured
        if (styleParameters) {
            if (styleParameters.showOrthomaps && styleParameters.defaultOrthomap) {
                if (styleParameters.showOrthomaps == "yes" && styleParameters.defaultOrthomap != '') {
                    let menuOrthomap = [];
                    if (widgetParameters.dropdownMenu) {
                        for (let n = 0; n < widgetParameters.dropdownMenu.length; n++) {
                            if (widgetParameters.dropdownMenu[n].id == styleParameters.defaultOrthomap) {
                                menuOrthomap = widgetParameters.dropdownMenu[n];
                            }
                        }
                        defaultOrthomapMenuItem = menuOrthomap;
                        //    addTileLayer(null, menuOrthomap);
                        if (menuOrthomap.service == "WMS") {
                            addDefaultBaseMap(map.defaultMapRef);
                            addLayerWMS(null, menuOrthomap);
                        } else {
                            let layer = L.tileLayer(menuOrthomap.linkUrl, {
                                attribution: menuOrthomap.layerAttribution,
                                apikey: menuOrthomap.apiKey
                            }).addTo(map.defaultMapRef);
                        }
                    } else {
                        /* L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                             attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                             maxZoom: leafletMaxZoom
                         }).addTo(map.defaultMapRef);*/
                        addDefaultBaseMap(map.defaultMapRef);
                    }
                } else {
                    /*  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                          attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                          maxZoom: leafletMaxZoom
                      }).addTo(map.defaultMapRef);*/
                    addDefaultBaseMap(map.defaultMapRef);
                }
            } else {
                /* L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                     attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                     maxZoom: leafletMaxZoom
                 }).addTo(map.defaultMapRef);*/
                addDefaultBaseMap(map.defaultMapRef);
            }
        } else {
            /*  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                  attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                  maxZoom: leafletMaxZoom
              }).addTo(map.defaultMapRef);*/
            addDefaultBaseMap(map.defaultMapRef);
        }

        map.defaultMapRef.attributionControl.setPrefix('');

        var rgbToHex = function (rgb) {
            var hex = Number(rgb).toString(16);
            if (hex.length < 2) {
                hex = "0" + hex;
            }
            return hex;
        };

        var fullColorHex = function (rgbArray) {
            var red = rgbToHex((rgbArray.split(",")[0]).trim());
            var green = rgbToHex((rgbArray.split(",")[1]).trim());
            var blue = rgbToHex((rgbArray.split(",")[2]).trim());
            return red + green + blue;
        };

        // Crea un array con tutti i giorni disponibili per la heatmap corrente dai metadati
        function initDaysArray(heatmapMetaData) {
            var outArray = [];
            var outMillisArray = [];
            for (n = 0; n < heatmapData.length; n++) {
                outArray[n] = dateFns.parse(heatmapData[n].metadata.date.replace(" ", "T"));
                outMillisArray[n] = outArray[n].valueOf();
            }
            var dateNow = new Date(Date.now());
            var result = dateFns.closestTo(dateNow, outArray);
            var idx = outMillisArray.indexOf(result.valueOf());
            while (dateFns.isAfter(result, dateNow)) {
                if (idx < outArray.length) {
                    result = outArray[++idx];
                }
            }
            if (idx > heatmapData.length - 1) {
                current_page = heatmapData.length - 1;
            } else {
                current_page = idx;
            }

            var utcDate = getUTCDate(Date.now());
            //    var gmtDate = getGMTDate(Date.now());
            var clientTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

            var datum = new Date(Date.now());
            if (isValidDate(datum)) {
                var convertedDate = datum.epochConverterGMTString();
                var relativeDate = datum.relativeDate();
                var clientLocaleTime = datum.toString();
            }
            return outArray;
            //    return outMillisArray;
        }

        //Risponditore ad eventi innescati dagli widget pilota (aggiungi evento, togli evento)

        $(document).on('updateCustomLeafletMarkers', function (event) {
            //    console.log("Entrato in trigger listener");
            let cnt = 0;
            let iconSize = [];
            let htmlString = "";
            if (event.tpl.includes("thermometer") || event.tpl.includes("Thermometer") || event.tpl.includes("SVG_Value.svg")) {
                iconSize = [96, 96];
            } else {
                iconSize = [48, 48];
            }
            if (event.updateSingleMarkerFlag === true) {
                if (gisLayersOnMap[currentCustomSvgLayer] != null) {
                    gisLayersOnMap[currentCustomSvgLayer].eachLayer(function (marker) {
                        if (marker.feature.properties.serviceUri == event.serviceUri) {
                            if (event.tpl.includes("Traffic_Light_SVG.svg") || event.tpl.includes("Thermometer") || event.tpl.includes("27_Blinking_Alarm_SVG.svg") || event.tpl.includes("119_SVG_PM10_level_vertical_bar.svg")) {
                                if (event.tpl.includes("Thermometer")) {
                                    htmlString = "<img src='" + event.srcUrl + "' height='96px'>";
                                } else {
                                    htmlString = "<img src='" + event.srcUrl + "' height='48px'>";
                                }
                                let icon = L.divIcon({
                                    //   html: svgContainerArray[cnt][0].innerHTML,
                                    html: htmlString,
                                    iconSize: iconSize,
                                    //iconAnchor: [20, 48]
                                });
                                marker.setIcon(icon);
                            } else {
                                if (svgContainerArray[event.id - 1]) {
                                    let icon = L.divIcon({
                                        html: svgContainerArray[event.id - 1][0].innerHTML,
                                        iconSize: iconSize,
                                        //iconAnchor: [20, 48]
                                    });
                                    marker.setIcon(icon);
                                }
                            }
                        }
                    });
                    //   gisLayersOnMap[currentCustomSvgLayer].addTo(map.defaultMapRef);
                }
                //    if (event.tpl.includes("value.svg")) {
                $('div.leaflet-div-icon').css('background-color', "transparent");
                //    }
                $('div.leaflet-div-icon').css('border', "0px");
                //  currentCustomSvgLayer = null;
                svgContainerArray = [];
            } else {
                if (gisLayersOnMap[currentCustomSvgLayer] != null) {
                    gisLayersOnMap[currentCustomSvgLayer].eachLayer(function (marker) {
                        if (svgContainerArray[cnt] != null) {
                            if (event.tpl.includes("Traffic_Light_SVG.svg") || event.tpl.includes("Thermometer") || event.tpl.includes("27_Blinking_Alarm_SVG.svg") || event.tpl.includes("119_SVG_PM10_level_vertical_bar.svg")) {
                                if (event.tpl.includes("Thermometer")) {
                                    htmlString = "<img src='" + svgContainerArray[cnt][0].attributes['src'].value + "' height='96px'>";
                                } else {
                                    htmlString = "<img src='" + svgContainerArray[cnt][0].attributes['src'].value + "' height='48px'>";
                                }
                                let icon = L.divIcon({
                                    //   html: svgContainerArray[cnt][0].innerHTML,
                                    html: htmlString,
                                    iconSize: iconSize,
                                    //iconAnchor: [20, 48]
                                });
                                marker.setIcon(icon);
                            } else {
                                let icon = L.divIcon({
                                    html: svgContainerArray[cnt][0].innerHTML,
                                    iconSize: iconSize,
                                    //iconAnchor: [20, 48]
                                });
                                marker.setIcon(icon);
                            }
                        }

                        /*   marker = L.marker(marker._latlng, {
                               icon: icon
                           }).addTo(map.defaultMapRef);*/
                        cnt++;

                    });
                    gisLayersOnMap[currentCustomSvgLayer].addTo(map.defaultMapRef);
                }
                //    if (event.tpl.includes("value.svg")) {
                $('div.leaflet-div-icon').css('background-color', "transparent");
                //    }
                $('div.leaflet-div-icon').css('border', "0px");
                //   currentCustomSvgLayer = null;
                svgContainerArray = [];
            }
        });

        $(document).on('updateCustomSingleMarker', function (event) {
            //    console.log("Entrato in trigger listener");
            let cnt = 0;
            let iconSize = [];
            let htmlString = "";
            if (event.tpl.includes("thermometer") || event.tpl.includes("Thermometer") || event.tpl.includes("SVG_Value.svg")) {
                iconSize = [96, 96];
            } else {
                iconSize = [48, 48];
            }

            if (gisLayersOnMap[currentCustomSvgLayer] != null) {
                gisLayersOnMap[currentCustomSvgLayer].eachLayer(function (marker) {
                    if (svgContainerArray[cnt] != null) {
                        if (event.tpl.includes("Traffic_Light_SVG.svg") || event.tpl.includes("Thermometer") || event.tpl.includes("27_Blinking_Alarm_SVG.svg") || event.tpl.includes("119_SVG_PM10_level_vertical_bar.svg")) {
                            if (event.tpl.includes("Thermometer")) {
                                htmlString = "<img src='" + svgContainerArray[cnt][0].attributes['src'].value + "' height='96px'>";
                            } else {
                                htmlString = "<img src='" + svgContainerArray[cnt][0].attributes['src'].value + "' height='48px'>";
                            }
                            let icon = L.divIcon({
                                //   html: svgContainerArray[cnt][0].innerHTML,
                                html: htmlString,
                                iconSize: iconSize,
                                iconAnchor: [20, 48]
                            });
                            marker.setIcon(icon);
                        } else {
                            let icon = L.divIcon({
                                html: svgContainerArray[cnt][0].innerHTML,
                                iconSize: iconSize,
                                iconAnchor: [20, 48]
                            });
                            marker.setIcon(icon);
                        }
                    }

                    /*   marker = L.marker(marker._latlng, {
                           icon: icon
                       }).addTo(map.defaultMapRef);*/
                    cnt++;

                });
                gisLayersOnMap[currentCustomSvgLayer].addTo(map.defaultMapRef);
            }
            //    if (event.tpl.includes("value.svg")) {
            $('div.leaflet-div-icon').css('background-color', "transparent");
            //    }
            $('div.leaflet-div-icon').css('border', "0px");
            currentCustomSvgLayer = null;
            svgContainerArray = [];
        });

        $(document).on('addAlarm', function (event) {
            if (event.target === map.mapName) {
                function addAlarmsToMap() {
                    let passedData = event.passedData;

                    for (let j = 0; j < passedData.length; j++) {

                        let lat = passedData[j].lat;
                        let lng = passedData[j].lng;
                        let eventType = passedData[j].eventType;
                        let eventName = passedData[j].eventName;
                        let eventStartDate = passedData[j].eventStartDate;
                        let eventStartTime = passedData[j].eventStartTime;
                        let eventSeverity = passedData[j].eventSeverity;
                        passedData[j].type = "alarmEvent";

                        //Creazione dell'icona custom per il pin
                        switch (eventSeverity) {
                            case "MINOR":
                                mapPinImg = '../img/alarmIcons/' + alarmTypes[eventType].mapIconLow;
                                severityColor = "#ffcc00";
                                break;

                            case "MAJOR":
                                mapPinImg = '../img/alarmIcons/' + alarmTypes[eventType].mapIconMed;
                                severityColor = "#ff9900";
                                break;

                            case "CRITICAL":
                                mapPinImg = '../img/alarmIcons/' + alarmTypes[eventType].mapIconHigh;
                                severityColor = "#ff6666";
                                break;
                        }

                        let pinIcon = new L.DivIcon({
                            className: null,
                            html: '<img src="' + mapPinImg + '" class="leafletPin" />',
                            iconAnchor: [18, 36]
                        });

                        let markerLocation = new L.LatLng(lat, lng);
                        let marker = new L.Marker(markerLocation, { icon: pinIcon });
                        passedData[j].marker = marker;

                        //Creazione del popup per il pin appena creato
                        let popupText = "<span class='mapPopupTitle'>" + eventName + "</span>" +
                            "<span class='mapPopupLine'><i>Start date: </i>" + eventStartDate + " - " + eventStartTime + "</span>" +
                            "<span class='mapPopupLine'><i>Event type: </i>" + alarmTypes[eventType].desc.toUpperCase() + "</span>" +
                            "<span class='mapPopupLine'><i>Event severity: </i><span style='background-color: " + severityColor + "'>" + eventSeverity.toUpperCase() + "</span></span>";

                        map.defaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [-5, -40], maxWidth: 600 }).openPopup();

                        map.eventsOnMap.push(passedData[j]);

                    }
                }

                if (addMode === 'additive') {
                    addAlarmsToMap();
                }

                if (addMode === 'exclusive') {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].type !== 'addAlarm') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;
                            break;
                        }
                    }
                    //Remove WidgetEvacuationPlans active pins
                    $.event.trigger({
                        type: "removeEvacuationPlanPin",
                    });
                    //Remove WidgetSelector active pins
                    $.event.trigger({
                        type: "removeSelectorEventPin",
                    });
                    //Remove WidgetEvents active pins
                    $.event.trigger({
                        type: "removeEventFIPin",
                    });
                    //Remove WidgetResources active pins
                    $.event.trigger({
                        type: "removeResourcePin",
                    });
                    //Remove WidgetOperatorEvents active pins
                    $.event.trigger({
                        type: "removeOperatorEventPin",
                    });
                    //Remove WidgetTrafficEvents active pins
                    $.event.trigger({
                        type: "removeTrafficEventPin",
                    });
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                        maxZoom: leafletMaxZoom,
                        maxNativeZoom: leafletNativeMaxZoom
                    }).addTo(map.defaultMapRef);

                    addAlarmsToMap();
                }

                //console.log(map.eventsOnMap.length);

                //   resizeMapView(map.defaultMapRef);
            }
        });
        $(document).on('addEvacuationPlan', function (event) {
            if (event.target === map.mapName) {
                function addEvacuationPlanToMap() {
                    let passedData = event.passedData;

                    for (let k = 0; k < passedData.length; k++) {

                        let plansObj = passedData[k].plansObj;
                        let planId = passedData[k].planId;
                        let evacuationColors = passedData[k].colors;

                        shownPolyGroup = L.featureGroup();
                        shownPolyGroup.eventType = passedData[k].eventType;


                        for (let j = 0; j < plansObj[planId].payload.evacuation_paths.length; j++) {
                            path = [];

                            for (let i = 0; i < plansObj[planId].payload.evacuation_paths[j].coords.length; i++) {
                                let point = [];
                                point[0] = plansObj[planId].payload.evacuation_paths[j].coords[i].latitude;
                                point[1] = plansObj[planId].payload.evacuation_paths[j].coords[i].longitude;
                                path.push(point);
                                console.log(path);
                            }

                            let polyline = L.polyline(path, { color: evacuationColors[j % 6] });
                            shownPolyGroup.addLayer(polyline);
                        }
                        passedData[k].polyGroup = shownPolyGroup;
                        map.eventsOnMap.push(passedData[k]);
                    }
                    map.defaultMapRef.addLayer(shownPolyGroup);

                    shownPolyGroup.maxLat = shownPolyGroup.getBounds()._northEast.lat;
                    shownPolyGroup.minLat = shownPolyGroup.getBounds()._southWest.lat;
                    shownPolyGroup.maxLng = shownPolyGroup.getBounds()._northEast.lng;
                    shownPolyGroup.minLng = shownPolyGroup.getBounds()._southWest.lng;
                }

                if (addMode === 'additive') {
                    addEvacuationPlanToMap();
                }

                if (addMode === 'exclusive') {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType !== 'evacuationPlan') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;
                            break;
                        }
                    }
                    //Remove WidgetAlarm active pins
                    $.event.trigger({
                        type: "removeAlarmPin",
                    });
                    //Remove WidgetSelector active pins
                    $.event.trigger({
                        type: "removeSelectorEventPin",
                    });
                    //Remove WidgetEvents active pins
                    $.event.trigger({
                        type: "removeEventFIPin",
                    });
                    //Remove WidgetResources active pins
                    $.event.trigger({
                        type: "removeResourcePin",
                    });
                    //Remove WidgetOperatorEvents active pins
                    $.event.trigger({
                        type: "removeOperatorEventPin",
                    });
                    //Remove WidgetTrafficEvents active pins
                    $.event.trigger({
                        type: "removeTrafficEventPin",
                    });
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                        maxZoom: leafletMaxZoom,
                        maxNativeZoom: leafletNativeMaxZoom
                    }).addTo(map.defaultMapRef);

                    addEvacuationPlanToMap();
                }

                //console.log(map.eventsOnMap.length);

                // resizeMapView(map.defaultMapRef);
            }
        });

        $(document).on('addBubbleChart', function (event) {

            if (event.target === map.mapName) {
                if (lastPopup !== null) {
                    lastPopup.closePopup();
                }

                function addSelectorEventToMap() {
                    var passedData = event.passedData;

                    var mapBounds = map.defaultMapRef.getBounds();
                    var query = passedData.query;
                    var targets = passedData.targets;
                    var eventGenerator = passedData.eventGenerator;
                    var color1 = passedData.color1;
                    var color2 = passedData.color2;
                    var queryType = passedData.queryType;
                    var desc = passedData.desc;
                    var display = passedData.display;
                    if (desc == "") {
                        desc = query;
                    }
                    var pinattr = passedData.pinattr;
                    var pincolor = passedData.pincolor;
                    var symbolcolor = passedData.symbolcolor;
                    var iconFilePath = passedData.iconFilePath;
                    bubbleSelectedMetric[desc] = passedData.bubbleSelectedMetric;
                    altViewMode = passedData.altViewMode;
                    if (passedData.selectedMetrics != null) {
                        selectedMetrics = passedData.selectedMetrics;
                    }
                    if (passedData.tooltipOnHover != null) {
                        tooltipOnHover = passedData.tooltipOnHover;
                    }
                    if (passedData.popupOnClick != null) {
                        popupOnClick = passedData.popupOnClick;
                    }

                    var loadingDiv = $('<div class="gisMapLoadingDiv"></div>');

                    if ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length > 0) {
                        loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').last());
                    }
                    else {
                        loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_map'));
                    }

                    loadingDiv.css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length * loadingDiv.height())) + "px");
                    loadingDiv.css("left", ($('#<?= $_REQUEST['name_w'] ?>_div').width() - loadingDiv.width()) + "px");

                    if (desc == query) {
                        var loadingText = $('<p class="gisMapLoadingDivTextPar">adding to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                        var loadOkText = $('<p class="gisMapLoadingDivTextPar"> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                        var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');
                    } else {
                        var loadingText = $('<p class="gisMapLoadingDivTextPar">adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                        var loadOkText = $('<p class="gisMapLoadingDivTextPar"><b>' + desc.toLowerCase() + '</b> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                        var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');
                    }

                    loadingDiv.css("background", color1);
                    loadingDiv.css("background", "-webkit-linear-gradient(left top, " + color1 + ", " + color2 + ")");
                    loadingDiv.css("background", "-o-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                    loadingDiv.css("background", "-moz-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                    loadingDiv.css("background", "linear-gradient(to bottom right, " + color1 + ", " + color2 + ")");

                    loadingDiv.show();

                    loadingDiv.append(loadingText);
                    loadingDiv.css("opacity", 1);

                    var parHeight = loadingText.height();
                    var parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                    loadingText.css("margin-top", parMarginTop + "px");

                    var re1 = '(selection)';	// Word 1
                    var re2 = '(=)';	// Any Single Character 1
                    var re3 = '([+-]?\\d*\\.\\d+)(?![-+0-9\\.])';	// Float 1
                    var re4 = '(;|%3B)';	// Any Single Character 2
                    var re5 = '([+-]?\\d*\\.\\d+)(?![-+0-9\\.])';	// Float 2
                    var re6 = '(;|%3B)?';	// Any Single Character 3
                    var re7 = '([+-]?\\d*\\.\\d+)?(?![-+0-9\\.])?';	// Float 3
                    var re8 = '(;|%3B)?';	// Any Single Character 4
                    var re9 = '([+-]?\\d*\\.\\d+)?(?![-+0-9\\.])?';	// Float 4

                    var pattern = new RegExp(re1 + re2 + re3 + re4 + re5 + re6 + re7 + re8 + re9, ["i"]);

                    if (queryType === "Default") {
                        if (passedData.query.includes("datamanager/api/v1/poidata/")) {     // DA GESTIRE
                            if (passedData.desc != "My POI") {
                                myPOIId = passedData.query.split("datamanager/api/v1/poidata/")[1];
                                apiUrl = "../controllers/myPOIProxy.php";
                                dataForApi = myPOIId;
                                query = passedData.query;
                            } else {
                                apiUrl = "../controllers/myPOIProxy.php";
                                dataForApi = "All";
                                query = passedData.query;
                            }
                        } else if (passedData.query.includes("/iot/") && !passedData.query.includes("/api/v1/")) {  // DA GESTIRE
                            query = "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + passedData.query + "&format=json";
                        } else {
                            if (passedData.query.includes("iot-search")) {
                                var lastPartQuery = passedData.query.split("selection=")[1];
                                var newSplit = lastPartQuery.split('&');
                                var lastPartString = "";
                                if (newSplit.length >= 2) {
                                    var lastPart = newSplit.slice(1);
                                    lastPartString = lastPart.join('&');
                                } else {
                                    lastPartString = newSplit;
                                }
                                query = "<?= $superServiceMapProxy; ?>api/v1/iot-search/?selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng + "&" + lastPartString;
                            } else {
                                if (pattern.test(passedData.query)) {
                                    //console.log("Service Map selection substitution");
                                    query = passedData.query.replace(pattern, "selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng);
                                } else {
                                    //console.log("Service Map selection addition");
                                    query = passedData.query + "&selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng;
                                }
                                if (altViewMode == "Bubble" || altViewMode == "CustomPin" || altViewMode == "DynamicCustomPin" || altViewMode == "BimShape" || altViewMode == "BimShapePopup") {
                                    query = query + "&valueName=" + bubbleSelectedMetric[desc];
                                }
                                query = "<?= $superServiceMapProxy ?>api/v1?" + query.split('?')[1];
                            }
                        }
                        if (!query.includes("&maxResults")) {
                            if (!query.includes("&queryId")) {
                                query = query + "&maxResults=0";
                            }
                        }
                    } else if (queryType === "Sensor") {
                        if (event.query != null) {
                            query = "<?= $superServiceMapProxy ?>" + event.query;
                        } else if (query != null) {
                            query = "<?= $superServiceMapProxy ?>" + encodeServiceUri(query);
                        }
                        if (query.includes("&fromTime=")) {
                            if (altViewMode == "Bubble" || altViewMode == "CustomPin" || altViewMode == "DynamicCustomPin") {
                                query = query.split("&fromTime=")[0] + "&valueName=" + bubbleSelectedMetric[desc];
                            }
                        } else {
                            query = query + bubbleSelectedMetric[desc];
                        }
                    } else if (queryType === "MyPOI") {
                        if (passedData.desc != "My POI") {
                            myPOIId = passedData.query.split("datamanager/api/v1/poidata/")[1];
                            apiUrl = "../controllers/myPOIProxy.php";
                            dataForApi = myPOIId;
                            query = passedData.query;
                        } else {
                            apiUrl = "../controllers/myPOIProxy.php";
                            dataForApi = "All";
                            query = passedData.query;
                        }
                    } else {
                        query = passedData.query;
                    }

                    if (passedData.targets && passedData.targets !== "") {
                        targets = passedData.targets.split(",");
                    }
                    else {
                        targets = [];
                    }

                    if (queryType != "MyPOI" && !passedData.query.includes("datamanager/api/v1/poidata/")) {
                        apiUrl = query + "&geometry=true&fullCount=false";
                    }

                    //    if (queryType === "Sensor" && query.includes("%2525")) {
                    if (query.includes("%2525") && !query.includes("%252525")) {
                        let queryPart1 = query.split("/resource/")[0];
                        let queryPart2 = (query.split("/resource/")[1]).split("&format=")[0];
                        let queryPart3 = query.split("&format=")[1];
                        if (queryPart3 != undefined) {
                            apiUrl = queryPart1 + "/resource/" + encodeURI(queryPart2) + "&format=" + queryPart3;
                        } else {
                            apiUrl = queryPart1 + "/resource/" + encodeURI(queryPart2);
                        }
                    }

                    $.ajax({
                        //    url: query + "&geometry=true&fullCount=false",
                        url: apiUrl,
                        type: "GET",
                        data: {
                            myPOIId: dataForApi

                        },
                        async: true,
                        timeout: 0,
                        dataType: 'json',
                        success: function (geoJsonData) {
                            var fatherGeoJsonNode = {};

                            if (queryType === "Default") {
                                if (passedData.query.includes("datamanager/api/v1/poidata/")) {
                                    fatherGeoJsonNode.features = [];
                                    if (passedData.desc != "My POI") {
                                        fatherGeoJsonNode.features[0] = geoJsonData;
                                    } else {
                                        fatherGeoJsonNode.features = geoJsonData;
                                    }
                                    fatherGeoJsonNode.type = "FeatureCollection";
                                }
                                else {
                                    var countObjKeys = 0;
                                    var objContainer = {};
                                    if (geoJsonData.hasOwnProperty("features")) {
                                        fatherGeoJsonNode = geoJsonData;
                                    } else {
                                        Object.keys(geoJsonData).forEach(function (key) {
                                            if (countObjKeys == 0) {
                                                if (geoJsonData.hasOwnProperty(key)) {
                                                    fatherGeoJsonNode = geoJsonData[key];
                                                }
                                            } else {
                                                if (geoJsonData.hasOwnProperty(key)) {
                                                    if (geoJsonData[key].features) {
                                                        fatherGeoJsonNode.features = fatherGeoJsonNode.features.concat(geoJsonData[key].features);
                                                    }
                                                }
                                            }
                                            countObjKeys++;
                                        });
                                    }
                                    /*    if (geoJsonData.hasOwnProperty("BusStops")) {
                                            fatherGeoJsonNode = geoJsonData.BusStops;
                                        } else {
                                            if (geoJsonData.hasOwnProperty("SensorSites")) {
                                                fatherGeoJsonNode = geoJsonData.SensorSites;
                                            } else {
                                                if (geoJsonData.hasOwnProperty("Service")) {
                                                    fatherGeoJsonNode = geoJsonData.Service;
                                                } else {
                                                    fatherGeoJsonNode = geoJsonData.Services;
                                                }
                                            }
                                        }*/
                                }
                            }
                            else if (queryType === "MyPOI") {
                                fatherGeoJsonNode.features = [];
                                if (passedData.desc != "My POI") {
                                    fatherGeoJsonNode.features[0] = geoJsonData;
                                } else {
                                    fatherGeoJsonNode.features = geoJsonData;
                                }
                                fatherGeoJsonNode.type = "FeatureCollection";
                            }
                            else {
                                if (geoJsonData.hasOwnProperty("BusStop")) {
                                    fatherGeoJsonNode = geoJsonData.BusStop;
                                }
                                else {
                                    if (geoJsonData.hasOwnProperty("Sensor")) {
                                        fatherGeoJsonNode = geoJsonData.Sensor;
                                    }
                                    else {
                                        if (geoJsonData.hasOwnProperty("Service")) {
                                            fatherGeoJsonNode = geoJsonData.Service;
                                        }
                                        else {
                                            fatherGeoJsonNode = geoJsonData.Services;
                                        }
                                    }
                                }
                                //   fatherGeoJsonNode.features[0].properties.realtime = {};
                                //    if (geoJsonData.hasOwnProperty("realtime") && bubbleSelectedMetric[desc] != '') {     // Commenta x POT. MOD. CONV. addSelectorPin
                                if (geoJsonData.hasOwnProperty("realtime")) {  // Attiva x POT. MOD. CONV. addSelectorPin
                                    var dataObj = {};
                                    if (fatherGeoJsonNode.features[0].properties.realtimeAttributes.hasOwnProperty(bubbleSelectedMetric[desc])) {
                                        fatherGeoJsonNode.features[0].properties[bubbleSelectedMetric[desc]] = geoJsonData.realtime.results.bindings[0][bubbleSelectedMetric[desc]].value;
                                        if (isNaN(parseFloat(fatherGeoJsonNode.features[0].properties[bubbleSelectedMetric[desc]]))) {
                                            fatherGeoJsonNode.features.splice(0, 1);
                                        } else {
                                            if (fatherGeoJsonNode.features[0].properties[bubbleSelectedMetric[desc]] > maxValue) {
                                                maxValue = fatherGeoJsonNode.features[0].properties[bubbleSelectedMetric[desc]];
                                            }
                                            if (geoJsonData.realtime.results.bindings[0].hasOwnProperty("measuredTime")) {
                                                fatherGeoJsonNode.features[0].properties.measuredTime = geoJsonData.realtime.results.bindings[0].measuredTime.value;
                                            } else {
                                                fatherGeoJsonNode.features[0].properties.measuredTime = null;
                                            }

                                            dataObj.lat = fatherGeoJsonNode.features[0].geometry.coordinates[1];
                                            dataObj.lng = fatherGeoJsonNode.features[0].geometry.coordinates[0];
                                            dataObj.eventType = "selectorEvent";
                                            dataObj.desc = desc;
                                            dataObj.query = passedData.query;
                                            dataObj.targets = passedData.targets;
                                            dataObj.eventGenerator = passedData.eventGenerator;
                                            dataObj.color1 = passedData.color1;
                                            dataObj.color2 = passedData.color2;
                                            dataObj.queryType = passedData.queryType;
                                            dataObj.display = passedData.display;
                                            dataObj.iconTextMode = passedData.iconTextMode;

                                            //    map.eventsOnMap.push(dataObj);
                                            delete fatherGeoJsonNode.features[0].properties.distance;
                                            delete fatherGeoJsonNode.features[0].properties.typeLabel;
                                            delete fatherGeoJsonNode.features[0].properties.tipo;
                                            delete fatherGeoJsonNode.features[0].properties.photoThumbs;
                                            //   delete fatherGeoJsonNode.features[0].properties.serviceUri;
                                            delete fatherGeoJsonNode.features[0].properties.serviceType;
                                            delete fatherGeoJsonNode.features[0].properties.lastValue;
                                            delete fatherGeoJsonNode.features[0].properties.multimedia;
                                            delete fatherGeoJsonNode.features[0].properties.hasGeometry;
                                            delete fatherGeoJsonNode.features[0].properties.municipality;
                                            delete fatherGeoJsonNode.features[0].properties.address;
                                            delete fatherGeoJsonNode.features[0].properties.organization;
                                            //    delete fatherGeoJsonNode.features[0].properties.realtimeAttributes;
                                            delete fatherGeoJsonNode.features[0].properties.linkDBpedia;
                                            delete fatherGeoJsonNode.features[0].properties.avgStars;
                                            delete fatherGeoJsonNode.features[0].properties.starsCount;
                                            delete fatherGeoJsonNode.features[0].properties.comments;
                                            delete fatherGeoJsonNode.features[0].properties.photos;
                                            delete fatherGeoJsonNode.features[0].properties.photoOrigs;
                                            delete fatherGeoJsonNode.features[0].properties.wktGeometry;
                                            delete fatherGeoJsonNode.features[0].properties.description;
                                            delete fatherGeoJsonNode.features[0].properties.description2;
                                            delete fatherGeoJsonNode.features[0].properties.description;
                                            delete fatherGeoJsonNode.features[0].properties.civic;
                                            delete fatherGeoJsonNode.features[0].properties.cap;
                                            delete fatherGeoJsonNode.features[0].properties.email;
                                            delete fatherGeoJsonNode.features[0].properties.note;
                                            delete fatherGeoJsonNode.features[0].properties.city;
                                            delete fatherGeoJsonNode.features[0].properties.province;
                                            delete fatherGeoJsonNode.features[0].properties.website;
                                            delete fatherGeoJsonNode.features[0].properties.phone;
                                            delete fatherGeoJsonNode.features[0].properties.fax;
                                        }
                                    } else {
                                        fatherGeoJsonNode.features[0].properties[bubbleSelectedMetric[desc]] = 0;
                                        //  fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = null;
                                        fatherGeoJsonNode.features.splice(0, 1);
                                    }
                                }
                            }

                            var maxValue = 0;

                            //  if (bubbleSelectedMetric[desc] != '') {     // Comment x POT. MOD. CONV. addSelectorPin
                            //     if (fatherGeoJsonNode.features.length == 1 && geoJsonData.realtime.results.bindings[0][bubbleSelectedMetric[desc]]) {

                            //     console.log("Lenght of SMart CIty API Response for Event '" + passedData.desc + "': " + fatherGeoJsonNode.features.length);
                            //     } else {
                            var i = 0;
                            // for (var i = 0; i < fatherGeoJsonNode.features.length; i++) {
                            while (i < fatherGeoJsonNode.features.length) {
                                var dataObj = {};

                                if (altViewMode != "Bubble") {
                                    fatherGeoJsonNode.features[i].properties.targetWidgets = targets;
                                    fatherGeoJsonNode.features[i].properties.color1 = color1;
                                    fatherGeoJsonNode.features[i].properties.color2 = color2;
                                    fatherGeoJsonNode.features[i].properties.pinattr = passedData.pinattr;
                                    fatherGeoJsonNode.features[i].properties.pincolor = passedData.pincolor;
                                    fatherGeoJsonNode.features[i].properties.symbolcolor = passedData.symbolcolor;
                                    fatherGeoJsonNode.features[i].properties.iconFilePath = passedData.iconFilePath;
                                    fatherGeoJsonNode.features[i].properties.altViewMode = passedData.altViewMode;
                                    if (fatherGeoJsonNode.features[i].properties.lastValue == null && geoJsonData.hasOwnProperty("realtime")) {  // Attiva x POT. MOD. CONV. addSelectorPin
                                        if (fatherGeoJsonNode.features[0].properties.realtimeAttributes.hasOwnProperty(bubbleSelectedMetric[desc])) {
                                            var key = bubbleSelectedMetric[desc];
                                            var obj = {};
                                            if (geoJsonData.realtime != null && geoJsonData.realtime.results != null) {
                                                obj[key] = geoJsonData.realtime.results.bindings[0][bubbleSelectedMetric[desc]].value;
                                                fatherGeoJsonNode.features[0].properties["lastValue"] = obj;
                                            }
                                        }
                                    }
                                }

                                var valueObj = {};
                                if (fatherGeoJsonNode.features[i].properties.lastValue != null) {
                                    if (fatherGeoJsonNode.features[i].properties.lastValue.hasOwnProperty(bubbleSelectedMetric[desc])) {
                                        fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = fatherGeoJsonNode.features[i].properties.lastValue[bubbleSelectedMetric[desc]];
                                        fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]].replace(/"/g, "");
                                        if (isNaN(parseFloat(fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]]))) {
                                            if (altViewMode != "CustomPin" && altViewMode != "DynamicCustomPin") {
                                                fatherGeoJsonNode.features.splice(i, 1);
                                                continue;
                                            }
                                        } else {
                                            if (fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] > maxValue) {
                                                maxValue = fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]];
                                            }
                                        }
                                    } else {
                                        fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = 0;
                                        //  fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = null;
                                        fatherGeoJsonNode.features.splice(i, 1);
                                        continue;
                                    }
                                } else {
                                    if (fatherGeoJsonNode.features[i].properties.values != null) {
                                        if (fatherGeoJsonNode.features[i].properties.values.hasOwnProperty(bubbleSelectedMetric[desc])) {
                                            fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = fatherGeoJsonNode.features[i].properties.values[bubbleSelectedMetric[desc]];
                                            //fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]].replace(/"/g, "");
                                            if (isNaN(parseFloat(fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]]))) {
                                                if (altViewMode != "CustomPin" && altViewMode != "DynamicCustomPin") {
                                                    fatherGeoJsonNode.features.splice(i, 1);
                                                    continue;
                                                }
                                            } else {
                                                if (fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] > maxValue) {
                                                    maxValue = fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]];
                                                }
                                            }
                                        } else {
                                            fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = 0;
                                            //  fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = null;
                                            fatherGeoJsonNode.features.splice(i, 1);
                                            continue;
                                        }
                                    } else {
                                        fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = 0;
                                        //  fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[desc]] = null;
                                        fatherGeoJsonNode.features.splice(i, 1);
                                        continue;
                                    }
                                }

                                if (fatherGeoJsonNode.features[i].properties.lastValue != null) {
                                    if (fatherGeoJsonNode.features[i].properties.lastValue.hasOwnProperty("measuredTime")) {
                                        fatherGeoJsonNode.features[i].properties.measuredTime = fatherGeoJsonNode.features[i].properties.lastValue["measuredTime"];
                                    } else {
                                        fatherGeoJsonNode.features[i].properties.measuredTime = null;
                                    }
                                } else if (fatherGeoJsonNode.features[i].properties.values != null) {
                                    if (fatherGeoJsonNode.features[i].properties.values.hasOwnProperty("measuredTime")) {
                                        fatherGeoJsonNode.features[i].properties.measuredTime = fatherGeoJsonNode.features[i].properties.values["measuredTime"];
                                    } else if (fatherGeoJsonNode.features[i].properties.values.hasOwnProperty("dateObserved")) {
                                        fatherGeoJsonNode.features[i].properties.measuredTime = fatherGeoJsonNode.features[i].properties.values["dateObserved"];
                                    } else {
                                        fatherGeoJsonNode.features[i].properties.measuredTime = null;
                                    }
                                }

                                dataObj.lat = fatherGeoJsonNode.features[i].geometry.coordinates[1];
                                dataObj.lng = fatherGeoJsonNode.features[i].geometry.coordinates[0];
                                dataObj.eventType = "selectorEvent";
                                dataObj.desc = desc;
                                dataObj.query = passedData.query;
                                dataObj.targets = passedData.targets;
                                dataObj.eventGenerator = passedData.eventGenerator;
                                dataObj.color1 = passedData.color1;
                                dataObj.color2 = passedData.color2;
                                dataObj.queryType = passedData.queryType;
                                dataObj.display = passedData.display;
                                dataObj.iconTextMode = passedData.iconTextMode;

                                //    map.eventsOnMap.push(dataObj);
                                if (altViewMode == "Bubble") {
                                    delete fatherGeoJsonNode.features[i].properties.distance;
                                    delete fatherGeoJsonNode.features[i].properties.typeLabel;
                                    delete fatherGeoJsonNode.features[i].properties.tipo;
                                    delete fatherGeoJsonNode.features[i].properties.photoThumbs;
                                    delete fatherGeoJsonNode.features[i].properties.serviceUri;
                                    delete fatherGeoJsonNode.features[i].properties.serviceType;
                                    delete fatherGeoJsonNode.features[i].properties.lastValue;
                                    delete fatherGeoJsonNode.features[i].properties.multimedia;
                                    delete fatherGeoJsonNode.features[i].properties.hasGeometry;
                                }
                                i++;
                            }
                            //     }

                            map.eventsOnMap.push(dataObj);
                            //  console.log("Number of Devices with Matched Attributes for Event '" + passedData.desc + "': " + fatherGeoJsonNode.features.length);
                            if (altViewMode != "Bubble") {

                                countSvgCnt = 0;
                                currentCustomSvgLayer = desc;
                                // Aggiornare totalSvgCnt con la length di fatherJsonNode
                                totalSvgCnt = fatherGeoJsonNode.features.length;

                                //    if (!gisLayersOnMap.hasOwnProperty(desc) && (display !== 'geometries')) {
                                gisLayersOnMap[desc] = L.geoJSON(fatherGeoJsonNode, {
                                    pointToLayer: gisPrepareCustomMarker,
                                    onEachFeature: onEachFeatureSpiderify
                                    //   }).addTo(map.defaultMapRef);
                                });
                                //    }

                                loadingDiv.empty();
                                loadingDiv.append(loadOkText);

                                parHeight = loadOkText.height();
                                parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                loadOkText.css("margin-top", parMarginTop + "px");

                                setTimeout(function () {
                                    loadingDiv.css("opacity", 0);
                                    setTimeout(function () {
                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function () {
                                            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                        });
                                        loadingDiv.remove();
                                    }, 350);
                                }, 1000);

                                if (eventGenerator) {
                                    eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                                    eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("font-weight", "bold");
                                    eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("color", eventGenerator.attr("data-activeFontColor"));
                                    if (eventGenerator.parents("div.gisMapPtrContainer").find('a.gisPinLink').attr("data-symbolMode") === 'auto') {
                                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").html("near_me");
                                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("color", "white");
                                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("text-shadow", "2px 2px 4px black");
                                    } else {
                                        //Evidenziazione che gli eventi di questa query sono su mappa in caso di icona custom
                                        eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").show();
                                        eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").css("height", "100%");
                                    }

                                    eventGenerator.show();
                                }

                                var wkt = null;

                                if (display !== 'pins') {
                                    stopGeometryAjax[desc] = false;
                                    gisGeometryTankForFullscreen[desc] = {
                                        capacity: fatherGeoJsonNode.features.length,
                                        shown: false,
                                        tank: [],
                                        lastConsumedIndex: 0
                                    };

                                    for (var i = 0; i < fatherGeoJsonNode.features.length; i++) {
                                        if (fatherGeoJsonNode.features[i].properties.hasOwnProperty('hasGeometry') && fatherGeoJsonNode.features[i].properties.hasOwnProperty('serviceUri')) {
                                            if (fatherGeoJsonNode.features[i].properties.hasGeometry === true) {
                                                //gisGeometryServiceUriToShowFullscreen[event.desc].push(fatherGeoJsonNode.features[i].properties.serviceUri);

                                                $.ajax({
                                                    url: "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + fatherGeoJsonNode.features[i].properties.serviceUri,
                                                    type: "GET",
                                                    data: {},
                                                    async: true,
                                                    timeout: 0,
                                                    dataType: 'json',
                                                    success: function (geometryGeoJson) {
                                                        if (!stopGeometryAjax[desc]) {
                                                            // Creazione nuova istanza del parser Wkt
                                                            wkt = new Wkt.Wkt();

                                                            // Lettura del WKT dalla risposta
                                                            wkt.read(geometryGeoJson.Service.features[0].properties.wktGeometry, null);

                                                            var ciclePathFeature = [
                                                                {
                                                                    type: "Feature",
                                                                    properties: geometryGeoJson.Service.features[0].properties,
                                                                    geometry: wkt.toJson()
                                                                }
                                                            ];

                                                            if (!gisGeometryLayersOnMap.hasOwnProperty(desc)) {
                                                                gisGeometryLayersOnMap[desc] = [];
                                                            }

                                                            // CORTI - Pane
                                                            map.defaultMapRef.createPane('ciclePathFeature');
                                                            map.defaultMapRef.getPane('ciclePathFeature').style.zIndex = 420;

                                                            gisGeometryLayersOnMap[desc].push(L.geoJSON(ciclePathFeature, { pane: 'ciclePathFeature' }).addTo(map.defaultMapRef));
                                                            gisGeometryTankForFullscreen[desc].tank.push(ciclePathFeature);
                                                        }
                                                    },
                                                    error: function (geometryErrorData) {
                                                        console.log("Ko");
                                                        console.log(JSON.stringify(geometryErrorData));
                                                    }
                                                });
                                            }
                                        }
                                    }
                                }

                            } else {

                                bubbles[desc] = {};
                                map.defaultMapRef.createPane('bubblePane');
                                map.defaultMapRef.getPane('bubblePane').style.zIndex = 415;
                                if (fatherGeoJsonNode.features.length > 0) {
                                    bubbles[desc] = L.bubbleLayer(fatherGeoJsonNode, {
                                        property: bubbleSelectedMetric[desc],
                                        legend: false,
                                        max_radius: 25,
                                        //    scale: 'YlGnBu',
                                        //    scale: [passedData.color1, '#ffffff'],
                                        //    scale: ['#ffffff', passedData.color1],
                                        //    scale: passedData.color1,
                                        //    pane: 'bubblePane',
                                        style: {
                                            fillColor: passedData.color1,
                                            weight: 0.3,
                                            pane: 'bubblePane'
                                        },
                                        tooltip: true
                                    });

                                    /*   if (isNaN(bubbles.options.style.radius)) {
                                           bubbles.options.style.radius = 10;
                                       }*/

                                    bubbles[desc].addTo(map.defaultMapRef);

                                    loadingDiv.empty();
                                    loadingDiv.append(loadOkText);

                                    parHeight = loadOkText.height();
                                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                    loadOkText.css("margin-top", parMarginTop + "px");

                                    setTimeout(function () {
                                        loadingDiv.css("opacity", 0);
                                        setTimeout(function () {
                                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function () {
                                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                            });
                                            loadingDiv.remove();
                                        }, 350);
                                    }, 1000);

                                    if (eventGenerator) {
                                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                                        eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("font-weight", "bold");
                                        eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("color", eventGenerator.attr("data-activeFontColor"));
                                        if (eventGenerator.parents("div.gisMapPtrContainer").find('a.gisPinLink').attr("data-symbolMode") === 'auto') {
                                            eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").html("near_me");
                                            eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("color", "white");
                                            eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("text-shadow", "2px 2px 4px black");
                                        } else {
                                            //Evidenziazione che gli eventi di questa query sono su mappa in caso di icona custom
                                            eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").show();
                                            eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").css("height", "100%");
                                        }

                                        eventGenerator.show();
                                    }
                                } else {
                                    var loadNoBubbleMetricsText = $('<p class="gisMapLoadingDivTextPar">No Metrics Selected or Data Not Available for Charts<br><i class="fa fa-close" style="font-size: 30px"></i></p>');
                                    loadingDiv.empty();
                                    loadingDiv.append(loadNoBubbleMetricsText);

                                    parHeight = loadNoBubbleMetricsText.height();
                                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                    loadNoBubbleMetricsText.css("margin-top", parMarginTop + "px");
                                    setTimeout(function () {
                                        loadingDiv.css("opacity", 0);
                                        setTimeout(function () {
                                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function () {
                                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                            });
                                            loadingDiv.remove();
                                        }, 350);
                                    }, 1000);

                                    if (eventGenerator) {
                                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").show();

                                        setTimeout(function () {
                                            eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").hide();
                                            eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").attr("data-onMap", "false");
                                            eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").show();
                                        }, 1500);
                                    }

                                }
                            }
                        },
                        error: function (errorData) {
                            gisLayersOnMap[event.desc] = "loadError";

                            loadingDiv.empty();
                            loadingDiv.append(loadKoText);

                            parHeight = loadKoText.height();
                            parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                            loadKoText.css("margin-top", parMarginTop + "px");

                            setTimeout(function () {
                                loadingDiv.css("opacity", 0);
                                setTimeout(function () {
                                    loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                        $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                    });
                                    loadingDiv.remove();
                                }, 350);
                            }, 1000);

                            eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                            eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").show();

                            setTimeout(function () {
                                eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").hide();
                                eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").attr("data-onMap", "false");
                                eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").show();
                            }, 1500);

                            console.log("Error in getting GeoJSON from ServiceMap");
                            console.log(JSON.stringify(errorData));
                        }
                    });
                }

                if (addMode === 'additive') {
                    addSelectorEventToMap();
                }

                if (addMode === 'exclusive') {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType !== 'selectorEvent') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;
                            break;
                        }
                    }
                    //Remove WidgetAlarm active pins
                    $.event.trigger({
                        type: "removeAlarmPin",
                    });
                    //Remove WidgetEvacuationPlans active pins
                    $.event.trigger({
                        type: "removeEvacuationPlanPin",
                    });
                    //Remove WidgetEvents active pins
                    $.event.trigger({
                        type: "removeEventFIPin",
                    });
                    //Remove WidgetResources active pins
                    $.event.trigger({
                        type: "removeResourcePin",
                    });
                    //Remove WidgetOperatorEvents active pins
                    $.event.trigger({
                        type: "removeOperatorEventPin",
                    });
                    //Remove WidgetTrafficEvents active pins
                    $.event.trigger({
                        type: "removeTrafficEventPin",
                    });
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                        maxZoom: leafletMaxZoom,
                        maxNativeZoom: leafletNativeMaxZoom
                    }).addTo(map.defaultMapRef);

                    addSelectorEventToMap();
                }

                //  resizeMapView(map.defaultMapRef);
            }

        });

        $(document).on('addSelectorPin', function (event) {

            if (event.target === map.mapName) {
                if (lastPopup !== null) {
                    lastPopup.closePopup();
                }

                function addSelectorEventToMap() {
                    var passedData = event.passedData;

                    var mapBounds = map.defaultMapRef.getBounds();
                    var query = passedData.query;
                    var targets = passedData.targets;
                    var eventGenerator = passedData.eventGenerator;
                    var color1 = passedData.color1;
                    var color2 = passedData.color2;
                    var queryType = passedData.queryType;
                    var desc = passedData.desc;
                    var display = passedData.display;
                    if (desc == "") {
                        desc = query;
                    }
                    var pinattr = passedData.pinattr;
                    var pincolor = passedData.pincolor;
                    var symbolcolor = passedData.symbolcolor;
                    var iconFilePath = passedData.iconFilePath;
                    if (passedData.selectedMetrics != null) {
                        selectedMetrics = passedData.selectedMetrics;
                    }
                    if (passedData.tooltipOnHover != null) {
                        tooltipOnHover = passedData.tooltipOnHover;
                    }
                    if (passedData.popupOnClick != null) {
                        popupOnClick = passedData.popupOnClick;
                    }

                    var loadingDiv = $('<div class="gisMapLoadingDiv"></div>');

                    if ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length > 0) {
                        loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').last());
                    }
                    else {
                        loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_map'));
                    }

                    loadingDiv.css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length * loadingDiv.height())) + "px");
                    loadingDiv.css("left", ($('#<?= $_REQUEST['name_w'] ?>_div').width() - loadingDiv.width()) + "px");

                    if (desc == query) {
                        var loadingText = $('<p class="gisMapLoadingDivTextPar">adding to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                        var loadOkText = $('<p class="gisMapLoadingDivTextPar"> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                        var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');
                    } else {
                        var loadingText = $('<p class="gisMapLoadingDivTextPar">adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                        var loadOkText = $('<p class="gisMapLoadingDivTextPar"><b>' + desc.toLowerCase() + '</b> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                        var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');
                    }

                    loadingDiv.css("background", color1);
                    loadingDiv.css("background", "-webkit-linear-gradient(left top, " + color1 + ", " + color2 + ")");
                    loadingDiv.css("background", "-o-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                    loadingDiv.css("background", "-moz-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                    loadingDiv.css("background", "linear-gradient(to bottom right, " + color1 + ", " + color2 + ")");

                    loadingDiv.show();

                    loadingDiv.append(loadingText);
                    loadingDiv.css("opacity", 1);

                    var parHeight = loadingText.height();
                    var parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                    loadingText.css("margin-top", parMarginTop + "px");

                    var re1 = '(selection)';	// Word 1
                    var re2 = '(=)';	// Any Single Character 1
                    var re3 = '([+-]?\\d*\\.\\d+)(?![-+0-9\\.])';	// Float 1
                    var re4 = '(;|%3B)';	// Any Single Character 2
                    var re5 = '([+-]?\\d*\\.\\d+)(?![-+0-9\\.])';	// Float 2
                    var re6 = '(;|%3B)?';	// Any Single Character 3
                    var re7 = '([+-]?\\d*\\.\\d+)?(?![-+0-9\\.])?';	// Float 3
                    var re8 = '(;|%3B)?';	// Any Single Character 4
                    var re9 = '([+-]?\\d*\\.\\d+)?(?![-+0-9\\.])?';	// Float 4

                    var pattern = new RegExp(re1 + re2 + re3 + re4 + re5 + re6 + re7 + re8 + re9, ["i"]);

                    /*   if (queryType === "Default") {
                           if (pattern.test(query)) {
                               query = query.replace(pattern, "selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng);
                           }
                           else {
                               query = query + "&selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng;
                           }
                       }

                       if (targets !== "") {
                           targets = targets.split(",");
                       }
                       else {
                           targets = [];
                       }*/

                    if (queryType === "Default") {
                        if (passedData.query.includes("datamanager/api/v1/poidata/")) {
                            if (passedData.desc != "My POI") {
                                myPOIId = passedData.query.split("datamanager/api/v1/poidata/")[1];
                                apiUrl = "../controllers/myPOIProxy.php";
                                dataForApi = myPOIId;
                                query = passedData.query;
                            } else {
                                apiUrl = "../controllers/myPOIProxy.php";
                                dataForApi = "All";
                                query = passedData.query;
                            }
                        } else if (passedData.query.includes("/iot/") && !passedData.query.includes("/api/v1/")) {
                            query = "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + passedData.query + "&format=json";
                        } else {
                            if (passedData.query.includes("iot-search")) {
                                var lastPartQuery = passedData.query.split("selection=")[1];
                                var newSplit = lastPartQuery.split('&');
                                var lastPartString = "";
                                if (newSplit.length >= 2) {
                                    var lastPart = newSplit.slice(1);
                                    lastPartString = lastPart.join('&');
                                } else {
                                    lastPartString = newSplit;
                                }
                                query = "<?= $superServiceMapProxy; ?>api/v1/iot-search/?selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng + "&" + lastPartString;
                            } else {
                                if (pattern.test(passedData.query)) {
                                    //console.log("Service Map selection substitution");
                                    query = passedData.query.replace(pattern, "selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng);
                                } else {
                                    //console.log("Service Map selection addition");
                                    query = passedData.query + "&selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng;
                                }
                                query = "<?= $superServiceMapProxy ?>api/v1?" + query.split('?')[1];
                            }
                        }
                        if (!query.includes("&maxResults")) {
                            if (!query.includes("&queryId")) {
                                query = query + "&maxResults=0";
                            }
                        }
                    } else if (queryType === "Sensor") {
                        if (event.query != null) {
                            query = "<?= $superServiceMapProxy ?>" + event.query;
                        } else if (query != null) {
                            query = "<?= $superServiceMapProxy ?>" + encodeServiceUri(query);
                        }
                    } else if (queryType === "MyPOI") {
                        if (passedData.desc != "My POI") {
                            myPOIId = passedData.query.split("datamanager/api/v1/poidata/")[1];
                            apiUrl = "../controllers/myPOIProxy.php";
                            dataForApi = myPOIId;
                            query = passedData.query;
                        } else {
                            apiUrl = "../controllers/myPOIProxy.php";
                            dataForApi = "All";
                            query = passedData.query;
                        }
                    } else {
                        query = passedData.query;
                    }

                    if (passedData.targets && passedData.targets !== "") {
                        targets = passedData.targets.split(",");
                    }
                    else {
                        targets = [];
                    }

                    if (queryType != "MyPOI" && !passedData.query.includes("datamanager/api/v1/poidata/")) {
                        apiUrl = query + "&geometry=true&fullCount=false";
                    }

                    //    if (queryType === "Sensor" && query.includes("%2525")) {
                    if (query.includes("%2525") && !query.includes("%252525")) {
                        let queryPart1 = query.split("/resource/")[0];
                        let queryPart2 = (query.split("/resource/")[1]).split("&format=")[0];
                        let queryPart3 = query.split("&format=")[1];
                        if (queryPart3 != undefined) {
                            apiUrl = queryPart1 + "/resource/" + encodeURI(queryPart2) + "&format=" + queryPart3;
                        } else {
                            apiUrl = queryPart1 + "/resource/" + encodeURI(queryPart2);
                        }
                    }

                    /*     if (passedData.query.includes("&model=")) {
                             apiUrl = apiUrl + "&model=" + passedData.desc;
                         }   */
                    console.log('dataForApi:');
                    console.log(dataForApi);
                    $.ajax({
                        //    url: query + "&geometry=true&fullCount=false",
                        url: apiUrl,
                        type: "GET",
                        data: {
                            myPOIId: dataForApi
                        },
                        async: true,
                        timeout: 0,
                        dataType: 'json',
                        success: function (geoJsonData) {
                            var fatherGeoJsonNode = {};
                            /*    if (queryType === "Default") {
                                    if (geoJsonData.hasOwnProperty("BusStops")) {
                                        fatherGeoJsonNode = geoJsonData.BusStops;
                                    }
                                    else {
                                        if (geoJsonData.hasOwnProperty("SensorSites")) {
                                            fatherGeoJsonNode = geoJsonData.SensorSites;
                                        }
                                        else {
                                            fatherGeoJsonNode = geoJsonData.Services;
                                        }
                                    }
                                }
                                else {
                                    if (geoJsonData.hasOwnProperty("BusStop")) {
                                        fatherGeoJsonNode = geoJsonData.BusStop;
                                    }
                                    else {
                                        if (geoJsonData.hasOwnProperty("Sensor")) {
                                            fatherGeoJsonNode = geoJsonData.Sensor;
                                        }
                                        else {
                                            if (geoJsonData.hasOwnProperty("Service")) {
                                                fatherGeoJsonNode = geoJsonData.Service;
                                            }
                                            else {
                                                fatherGeoJsonNode = geoJsonData.Services;
                                            }
                                        }
                                    }
                                }*/

                            if (queryType === "Default") {
                                if (passedData.query.includes("datamanager/api/v1/poidata/")) {
                                    fatherGeoJsonNode.features = [];
                                    if (passedData.desc != "My POI") {
                                        fatherGeoJsonNode.features[0] = geoJsonData;
                                    } else {
                                        fatherGeoJsonNode.features = geoJsonData;
                                    }
                                    fatherGeoJsonNode.type = "FeatureCollection";
                                }
                                else {
                                    var countObjKeys = 0;
                                    var objContainer = {};
                                    if (geoJsonData.hasOwnProperty("features")) {
                                        fatherGeoJsonNode = geoJsonData;
                                    } else {
                                        Object.keys(geoJsonData).forEach(function (key) {
                                            if (countObjKeys == 0) {
                                                if (geoJsonData.hasOwnProperty(key)) {
                                                    fatherGeoJsonNode = geoJsonData[key];
                                                }
                                            } else {
                                                if (geoJsonData.hasOwnProperty(key)) {
                                                    if (geoJsonData[key].features) {
                                                        fatherGeoJsonNode.features = fatherGeoJsonNode.features.concat(geoJsonData[key].features);
                                                    }
                                                }
                                            }
                                            countObjKeys++;
                                        });
                                    }
                                    /*    if (geoJsonData.hasOwnProperty("BusStops")) {
                                            fatherGeoJsonNode = geoJsonData.BusStops;
                                        } else {
                                            if (geoJsonData.hasOwnProperty("SensorSites")) {
                                                fatherGeoJsonNode = geoJsonData.SensorSites;
                                            } else {
                                                if (geoJsonData.hasOwnProperty("Service")) {
                                                    fatherGeoJsonNode = geoJsonData.Service;
                                                } else {
                                                    fatherGeoJsonNode = geoJsonData.Services;
                                                }
                                            }
                                        }*/
                                }
                            }
                            else if (queryType === "MyPOI") {
                                fatherGeoJsonNode.features = [];
                                if (passedData.desc != "My POI") {
                                    fatherGeoJsonNode.features[0] = geoJsonData;
                                } else {
                                    fatherGeoJsonNode.features = geoJsonData;
                                }
                                fatherGeoJsonNode.type = "FeatureCollection";
                            }
                            else {
                                /*   var countObjKeys = 0;
                                   var objContainer = {};
                                   Object.keys(geoJsonData).forEach(function (key) {
                                       if (countObjKeys == 0) {
                                           if (geoJsonData.hasOwnProperty(key)) {
                                               fatherGeoJsonNode = geoJsonData[key];
                                           }
                                       } else {
                                           if (geoJsonData.hasOwnProperty(key)) {
                                               fatherGeoJsonNode.features = fatherGeoJsonNode.features.concat(geoJsonData[key].features);
                                           }
                                       }
                                       countObjKeys++;
                                   });*/
                                if (geoJsonData.hasOwnProperty("BusStop")) {
                                    fatherGeoJsonNode = geoJsonData.BusStop;
                                }
                                else {
                                    if (geoJsonData.hasOwnProperty("Sensor")) {
                                        fatherGeoJsonNode = geoJsonData.Sensor;
                                    }
                                    else {
                                        if (geoJsonData.hasOwnProperty("Service")) {
                                            fatherGeoJsonNode = geoJsonData.Service;
                                        }
                                        else {
                                            fatherGeoJsonNode = geoJsonData.Services;
                                        }
                                    }
                                }
                            }

                            console.log(geoJsonData);
                            for (var i = 0; i < fatherGeoJsonNode.features.length; i++) {

                                var dataObj = {};
                                if (fatherGeoJsonNode.features[i].properties.serviceType == null) {
                                    if (fatherGeoJsonNode.features[i].properties.nature != null && fatherGeoJsonNode.features[i].properties.subnature != null) {
                                        fatherGeoJsonNode.features[i].properties.serviceType = fatherGeoJsonNode.features[i].properties.nature + "_" + fatherGeoJsonNode.features[i].properties.subnature;
                                    }
                                }
                                fatherGeoJsonNode.features[i].properties.targetWidgets = targets;
                                fatherGeoJsonNode.features[i].properties.color1 = color1;
                                fatherGeoJsonNode.features[i].properties.color2 = color2;
                                fatherGeoJsonNode.features[i].properties.pinattr = passedData.pinattr;
                                fatherGeoJsonNode.features[i].properties.pincolor = passedData.pincolor;
                                fatherGeoJsonNode.features[i].properties.symbolcolor = passedData.symbolcolor;
                                fatherGeoJsonNode.features[i].properties.iconFilePath = passedData.iconFilePath;
                                //    fatherGeoJsonNode.features[i].properties.altViewMode = passedData.altViewMode;

                                dataObj.lat = fatherGeoJsonNode.features[i].geometry.coordinates[1];
                                dataObj.lng = fatherGeoJsonNode.features[i].geometry.coordinates[0];
                                dataObj.eventType = "selectorEvent";
                                dataObj.desc = desc;
                                dataObj.query = passedData.query;
                                dataObj.targets = passedData.targets;
                                dataObj.eventGenerator = passedData.eventGenerator;
                                dataObj.color1 = passedData.color1;
                                dataObj.color2 = passedData.color2;
                                dataObj.queryType = passedData.queryType;
                                dataObj.display = passedData.display;
                                dataObj.iconTextMode = passedData.iconTextMode;

                                //    map.eventsOnMap.push(dataObj);
                            }

                            map.eventsOnMap.push(dataObj);

                            if (!gisLayersOnMap.hasOwnProperty(desc) && (display !== 'geometries')) {
                                gisLayersOnMap[desc] = L.geoJSON(fatherGeoJsonNode, {
                                    pointToLayer: gisPrepareCustomMarker,
                                    onEachFeature: onEachFeatureSpiderify
                                }).addTo(map.defaultMapRef);
                                //    oms.addMarker(gisLayersOnMap[desc]._layers);

                                // CORTI - setta markers nella mappa 3D
                                //                                        gisLayersOnMap[desc] = L.geoJSON(fatherGeoJsonNode, {
                                //                                            pointToLayer: gisPrepareCustomMarker,
                                //                                            onEachFeature: onEachFeature
                                //                                        }).addTo(map.default3DMapRef);
                                if (passedData.fromSURI) {
                                    map.defaultMapRef.setView([fatherGeoJsonNode.features[0].geometry.coordinates[1], fatherGeoJsonNode.features[0].geometry.coordinates[0]], map.defaultMapRef.getZoom());
                                }

                            }

                            loadingDiv.empty();
                            loadingDiv.append(loadOkText);

                            parHeight = loadOkText.height();
                            parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                            loadOkText.css("margin-top", parMarginTop + "px");

                            setTimeout(function () {
                                loadingDiv.css("opacity", 0);
                                setTimeout(function () {
                                    loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function () {
                                        $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                    });
                                    loadingDiv.remove();
                                }, 350);
                            }, 1000);

                            if (eventGenerator) {
                                eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                                eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("font-weight", "bold");
                                eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("color", eventGenerator.attr("data-activeFontColor"));
                                if (eventGenerator.parents("div.gisMapPtrContainer").find('a.gisPinLink').attr("data-symbolMode") === 'auto') {
                                    eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").html("near_me");
                                    eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("color", "white");
                                    eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("text-shadow", "2px 2px 4px black");
                                } else {
                                    //Evidenziazione che gli eventi di questa query sono su mappa in caso di icona custom
                                    eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").show();
                                    eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").css("height", "100%");
                                }

                                eventGenerator.show();
                            }

                            var wkt = null;

                            if (display !== 'pins') {
                                stopGeometryAjax[desc] = false;
                                gisGeometryTankForFullscreen[desc] = {
                                    capacity: fatherGeoJsonNode.features.length,
                                    shown: false,
                                    tank: [],
                                    lastConsumedIndex: 0
                                };

                                for (var i = 0; i < fatherGeoJsonNode.features.length; i++) {
                                    if (fatherGeoJsonNode.features[i].properties.hasOwnProperty('hasGeometry') && fatherGeoJsonNode.features[i].properties.hasOwnProperty('serviceUri')) {
                                        if (fatherGeoJsonNode.features[i].properties.hasGeometry === true) {
                                            //gisGeometryServiceUriToShowFullscreen[event.desc].push(fatherGeoJsonNode.features[i].properties.serviceUri);

                                            $.ajax({
                                                url: "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + fatherGeoJsonNode.features[i].properties.serviceUri,
                                                type: "GET",
                                                data: {},
                                                async: true,
                                                timeout: 0,
                                                dataType: 'json',
                                                success: function (geometryGeoJson) {
                                                    if (!stopGeometryAjax[desc]) {
                                                        // Creazione nuova istanza del parser Wkt
                                                        wkt = new Wkt.Wkt();

                                                        // Lettura del WKT dalla risposta
                                                        wkt.read(geometryGeoJson.Service.features[0].properties.wktGeometry, null);

                                                        var ciclePathFeature = [
                                                            {
                                                                type: "Feature",
                                                                properties: geometryGeoJson.Service.features[0].properties,
                                                                geometry: wkt.toJson()
                                                            }
                                                        ];

                                                        if (!gisGeometryLayersOnMap.hasOwnProperty(desc)) {
                                                            gisGeometryLayersOnMap[desc] = [];
                                                        }

                                                        // CORTI - Pane
                                                        map.defaultMapRef.createPane('ciclePathFeature');
                                                        map.defaultMapRef.getPane('ciclePathFeature').style.zIndex = 420;

                                                        gisGeometryLayersOnMap[desc].push(L.geoJSON(ciclePathFeature, { pane: 'ciclePathFeature' }).addTo(map.defaultMapRef));
                                                        gisGeometryTankForFullscreen[desc].tank.push(ciclePathFeature);
                                                    }
                                                },
                                                error: function (geometryErrorData) {
                                                    console.log("Ko");
                                                    console.log(JSON.stringify(geometryErrorData));
                                                }
                                            });
                                        }
                                    }
                                }
                            }
                        },
                        error: function (errorData) {
                            gisLayersOnMap[event.desc] = "loadError";

                            loadingDiv.empty();
                            loadingDiv.append(loadKoText);

                            parHeight = loadKoText.height();
                            parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                            loadKoText.css("margin-top", parMarginTop + "px");

                            setTimeout(function () {
                                loadingDiv.css("opacity", 0);
                                setTimeout(function () {
                                    loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                        $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                    });
                                    loadingDiv.remove();
                                }, 350);
                            }, 1000);

                            if (eventGenerator) {
                                eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                                eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").show();

                                setTimeout(function () {
                                    eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").hide();
                                    eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").attr("data-onMap", "false");
                                    eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").show();
                                }, 1500);
                            }

                            console.log("Error in getting GeoJSON from ServiceMap");
                            console.log(JSON.stringify(errorData));
                        }
                    });
                }

                if (addMode === 'additive') {
                    addSelectorEventToMap();
                }

                if (addMode === 'exclusive') {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType !== 'selectorEvent') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;
                            break;
                        }
                    }
                    //Remove WidgetAlarm active pins
                    $.event.trigger({
                        type: "removeAlarmPin",
                    });
                    //Remove WidgetEvacuationPlans active pins
                    $.event.trigger({
                        type: "removeEvacuationPlanPin",
                    });
                    //Remove WidgetEvents active pins
                    $.event.trigger({
                        type: "removeEventFIPin",
                    });
                    //Remove WidgetResources active pins
                    $.event.trigger({
                        type: "removeResourcePin",
                    });
                    //Remove WidgetOperatorEvents active pins
                    $.event.trigger({
                        type: "removeOperatorEventPin",
                    });
                    //Remove WidgetTrafficEvents active pins
                    $.event.trigger({
                        type: "removeTrafficEventPin",
                    });
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                        maxZoom: leafletMaxZoom,
                        maxNativeZoom: leafletNativeMaxZoom
                    }).addTo(map.defaultMapRef);

                    addSelectorEventToMap();
                }

                //  resizeMapView(map.defaultMapRef);
            }
        });
        $(document).on('addEventFI', function (event) {
            if (event.target === map.mapName) {
                function addEventFIToMap() {
                    let passedData = event.passedData;

                    for (let j = 0; j < passedData.length; j++) {

                        let lat = passedData[j].lat;
                        let lng = passedData[j].lng;
                        let categoryIT = passedData[j].categoryIT;

                        let name = passedData[j].name;
                        if (name.includes('?')) {
                            name = name.replace(/\?/g, "'");
                        }

                        let place = passedData[j].place;
                        if (place.includes('?')) {
                            place = place.replace(/\?/g, "'");
                        }

                        let startDate = passedData[j].startDate;
                        let endDate = passedData[j].endDate;
                        let startTime = passedData[j].startTime;
                        let freeEvent = passedData[j].freeEvent;
                        let address = passedData[j].address;
                        if (address.includes('?')) {
                            address = address.replace(/\?/g, "'");
                        }

                        let civic = passedData[j].civic;
                        let price = passedData[j].price;
                        let phone = passedData[j].phone;
                        let descriptionIT = passedData[j].descriptionIT;
                        if (descriptionIT.includes('?')) {
                            descriptionIT = descriptionIT.replace(/\?/g, "'");
                        }

                        let website = passedData[j].website;
                        let colorClass = passedData[j].colorClass;
                        let mapIconName = passedData[j].mapIconName;

                        let mapPinImg = '../img/eventsIcons/' + mapIconName + '.png';

                        let pinIcon = new L.DivIcon({
                            className: null,
                            html: '<img src="' + mapPinImg + '" class="leafletPin" />',
                            iconAnchor: [18, 36]
                        });

                        let markerLocation = new L.LatLng(lat, lng);
                        let marker = new L.Marker(markerLocation, { icon: pinIcon });
                        passedData[j].marker = marker;

                        //Creazione del popup per il pin appena creato
                        let popupText = '<h3 class="' + colorClass + ' recreativeEventMapTitle">' + name + '</h3>';
                        popupText += '<div class="recreativeEventMapBtnContainer"><button class="recreativeEventMapDetailsBtn recreativeEventMapBtn ' + colorClass + ' recreativeEventMapBtnActive" type="button">Details</button><button class="recreativeEventMapDescriptionBtn recreativeEventMapBtn ' + colorClass + '" type="button">Description</button><button class="recreativeEventMapTimingBtn recreativeEventMapBtn ' + colorClass + '" type="button">Timing</button><button class="recreativeEventMapContactsBtn recreativeEventMapBtn ' + colorClass + '" type="button">Contacts</button></div>';

                        popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDetailsContainer">';
                        if ((place !== 'undefined') || (address !== 'undefined')) {
                            if (categoryIT !== 'undefined') {
                                popupText += '<b>Category: </b>' + categoryIT;
                            }

                            if (place !== 'undefined') {
                                popupText += '<br/>';
                                popupText += '<b>Location: </b>' + place;
                            }

                            if (address !== 'undefined') {
                                popupText += '<br/>';
                                popupText += '<b>Address: </b>' + address;
                                if (civic !== 'undefined') {
                                    popupText += ' ' + civic;
                                }
                            }

                            if (freeEvent !== 'undefined') {
                                popupText += '<br/>';
                                if ((freeEvent !== 'yes') && (freeEvent !== 'YES') && (freeEvent !== 'Yes')) {
                                    if (price !== 'undefined') {
                                        popupText += '<b>Price (€) : </b>' + price + "<br>";
                                    }
                                    else {
                                        popupText += '<b>Price (€) : </b>N/A<br>';
                                    }
                                }
                                else {
                                    popupText += '<b>Free event: </b>' + freeEvent + '<br>';
                                }
                            }
                        }
                        else {
                            popupText += 'No further details available';
                        }
                        popupText += '</div>';

                        popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDescContainer">';
                        if (descriptionIT !== 'undefined') {
                            popupText += descriptionIT;
                        }
                        else {
                            popupText += 'No description available';
                        }
                        popupText += '</div>';

                        popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapTimingContainer">';
                        if ((startDate !== 'undefined') || (endDate !== 'undefined') || (startTime !== 'undefined')) {
                            popupText += '<b>From: </b>';
                            if (startDate !== 'undefined') {
                                popupText += startDate;
                            }
                            else {
                                popupText += 'N/A';
                            }
                            popupText += '<br/>';

                            popupText += '<b>To: </b>';
                            if (endDate !== 'undefined') {
                                popupText += endDate;
                            }
                            else {
                                popupText += 'N/A';
                            }
                            popupText += '<br/>';

                            if (startTime !== 'undefined') {
                                popupText += '<b>Times: </b>' + startTime + '<br/>';
                            }
                            else {
                                popupText += '<b>Times: </b>N/A<br/>';
                            }

                        }
                        else {
                            popupText += 'No timings info available';
                        }
                        popupText += '</div>';

                        popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapContactsContainer">';
                        if ((phone !== 'undefined') || (website !== 'undefined')) {
                            if (phone !== 'undefined') {
                                popupText += '<b>Phone: </b>' + phone + '<br/>';
                            }
                            else {
                                popupText += '<b>Phone: </b>N/A<br/>';
                            }

                            if (website !== 'undefined') {
                                if (website.includes('http') || website.includes('https')) {
                                    popupText += '<b><a href="' + website + '" target="_blank">Website</a></b><br>';
                                }
                                else {
                                    popupText += '<b><a href="' + website + '" target="_blank">Website</a></b><br>';
                                }
                            }
                            else {
                                popupText += '<b>Website: </b>N/A';
                            }
                        }
                        else {
                            popupText += 'No contacts info available';
                        }
                        popupText += '</div>';

                        map.defaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [-5, -40], maxWidth: 300 });

                        lastPopup.on('popupopen', function () {
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDetailsBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDetailsBtn').click(function () {
                                $('#' + widgetName + '_map div.recreativeEventMapDataContainer').hide();
                                $('#' + widgetName + '_map div.recreativeEventMapDetailsContainer').show();
                                $('#' + widgetName + '_map button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDescriptionBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapDescriptionBtn').click(function () {
                                $('#' + widgetName + '_map div.recreativeEventMapDataContainer').hide();
                                $('#' + widgetName + '_map div.recreativeEventMapDescContainer').show();
                                $('#' + widgetName + '_map button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTimingBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapTimingBtn').click(function () {
                                $('#' + widgetName + '_map div.recreativeEventMapDataContainer').hide();
                                $('#' + widgetName + '_map div.recreativeEventMapTimingContainer').show();
                                $('#' + widgetName + '_map button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_map button.recreativeEventMapContactsBtn').click(function () {
                                $('#' + widgetName + '_map div.recreativeEventMapDataContainer').hide();
                                $('#' + widgetName + '_map div.recreativeEventMapContactsContainer').show();
                                $('#' + widgetName + '_map button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });
                        });

                        lastPopup.openPopup();

                        map.eventsOnMap.push(passedData[j]);
                    }
                }

                if (addMode === 'additive') {
                    addEventFIToMap();
                }

                if (addMode === 'exclusive') {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType !== 'eventFI') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;
                            break;
                        }
                    }
                    //Remove WidgetAlarm active pins
                    $.event.trigger({
                        type: "removeAlarmPin",
                    });
                    //Remove WidgetEvacuationPlans active pins
                    $.event.trigger({
                        type: "removeEvacuationPlanPin",
                    });
                    //Remove WidgetSelector active pins
                    $.event.trigger({
                        type: "removeSelectorEventPin",
                    });
                    //Remove WidgetResources active pins
                    $.event.trigger({
                        type: "removeResourcePin",
                    });
                    //Remove WidgetOperatorEvents active pins
                    $.event.trigger({
                        type: "removeOperatorEventPin",
                    });
                    //Remove WidgetTrafficEvents active pins
                    $.event.trigger({
                        type: "removeTrafficEventPin",
                    });
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                        maxZoom: leafletMaxZoom,
                        maxNativeZoom: leafletNativeMaxZoom
                    }).addTo(map.defaultMapRef);

                    addEventFIToMap();
                }

                //console.log(map.eventsOnMap.length);

                //  resizeMapView(map.defaultMapRef);
            }
        });
        $(document).on('addResource', function (event) {
            if (event.target === map.mapName) {
                function addResourceToMap() {
                    let passedData = event.passedData;

                    for (let j = 0; j < passedData.length; j++) {

                        let lat = passedData[j].lat;
                        let lng = passedData[j].lng;
                        let eventType = passedData[j].eventType;
                        let eventName = passedData[j].eventName;
                        let eventStartDate = passedData[j].eventStartDate;
                        let eventStartTime = passedData[j].eventStartTime;

                        mapPinImg = '../img/resourceIcons/metroMap.png';

                        pinIcon = new L.DivIcon({
                            className: null,
                            html: '<img src="' + mapPinImg + '" class="leafletPin" />',
                            iconAnchor: [18, 36]
                        });

                        var markerLocation = new L.LatLng(lat, lng);
                        var marker = new L.Marker(markerLocation, { icon: pinIcon });

                        passedData[j].marker = marker;

                        //Creazione del popup per il pin appena creato
                        var popupText = "<span class='mapPopupTitle'>" + eventName.toUpperCase() + "</span>" +
                            "<span class='mapPopupLine'>" + eventStartDate + " - " + eventStartTime + "</span>";

                        map.defaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [-5, -40] }).openPopup();

                        map.eventsOnMap.push(passedData[j]);

                    }
                }

                if (addMode === 'additive') {
                    addResourceToMap();
                }

                if (addMode === 'exclusive') {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType !== 'resource') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;
                            break;
                        }
                    }
                    //Remove WidgetAlarm active pins
                    $.event.trigger({
                        type: "removeAlarmPin",
                    });
                    //Remove WidgetEvacuationPlans active pins
                    $.event.trigger({
                        type: "removeEvacuationPlanPin",
                    });
                    //Remove WidgetSelector active pins
                    $.event.trigger({
                        type: "removeSelectorEventPin",
                    });
                    //Remove WidgetEvents active pins
                    $.event.trigger({
                        type: "removeEventFIPin",
                    });
                    //Remove WidgetOperatorEvents active pins
                    $.event.trigger({
                        type: "removeOperatorEventPin",
                    });
                    //Remove WidgetTrafficEvents active pins
                    $.event.trigger({
                        type: "removeTrafficEventPin",
                    });
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                        maxZoom: leafletMaxZoom,
                        maxNativeZoom: leafletNativeMaxZoom
                    }).addTo(map.defaultMapRef);

                    addResourceToMap();
                }

                //console.log(map.eventsOnMap.length);

                //   resizeMapView(map.defaultMapRef);
            }
        });
        $(document).on('addOperatorEvent', function (event) {
            if (event.target === map.mapName) {
                function addOperatorEventToMap() {
                    let passedData = event.passedData;

                    for (let j = 0; j < passedData.length; j++) {

                        let lat = passedData[j].lat;
                        let lng = passedData[j].lng;
                        let eventType = passedData[j].eventType;
                        let eventName = passedData[j].eventName;
                        let eventStartDate = passedData[j].eventStartDate;
                        let eventStartTime = passedData[j].eventStartTime;
                        let eventPeopleNumber = parseInt(passedData[j].eventPeopleNumber);
                        let eventOperatorName = passedData[j].eventOperatorName;
                        let eventColor = passedData[j].eventColor;


                        let markerLocation = new L.LatLng(lat, lng);
                        let marker = new L.Marker(markerLocation);
                        passedData[j].marker = marker;

                        //Creazione del popup per il pin appena creato
                        popupText = "<span class='mapPopupTitle'>" + eventColor.toUpperCase() + "</span>" +
                            "<span class='mapPopupLine'>" + eventStartDate + " - " + eventStartTime + "</span>" +
                            //    "<span class='mapPopupLine'>PEOPLE INVOLVED: " + eventPeopleNumber + "</span>" +
                            "<span class='mapPopupLine'>TICKET NUMBER: " + eventPeopleNumber + "</span>" +
                            "<span class='mapPopupLine'>OPERATOR: " + eventOperatorName.toUpperCase() + "</span>";

                        map.defaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [0, 0] }).openPopup();

                        map.eventsOnMap.push(passedData[j]);

                    }
                }

                if (addMode === 'additive') {
                    addOperatorEventToMap();
                }

                if (addMode === 'exclusive') {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType !== 'OperatorEvent') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;
                            break;
                        }
                    }
                    //Remove WidgetAlarm active pins
                    $.event.trigger({
                        type: "removeAlarmPin",
                    });
                    //Remove WidgetEvacuationPlans active pins
                    $.event.trigger({
                        type: "removeEvacuationPlanPin",
                    });
                    //Remove WidgetSelector active pins
                    $.event.trigger({
                        type: "removeSelectorEventPin",
                    });
                    //Remove WidgetEvents active pins
                    $.event.trigger({
                        type: "removeEventFIPin",
                    });
                    //Remove WidgetResources active pins
                    $.event.trigger({
                        type: "removeResourcePin",
                    });
                    //Remove WidgetTrafficEvents active pins
                    $.event.trigger({
                        type: "removeTrafficEventPin",
                    });
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                        maxZoom: leafletMaxZoom,
                        maxNativeZoom: leafletNativeMaxZoom
                    }).addTo(map.defaultMapRef);

                    addOperatorEventToMap();
                }

                //console.log(map.eventsOnMap.length);

                // resizeMapView(map.defaultMapRef);
            }
        });

        $(document).on('addGeoInfoPin', function (event) {
            if (event.target === map.mapName) {
                function addGeoInfoPinToMap() {
                    let passedData = event.passedData;

                    for (let j = 0; j < passedData.length; j++) {

                        let eventType = passedData[j].eventType;
                        let id = passedData[j].id;
                        let lat = passedData[j].lat;
                        let lng = passedData[j].lng;
                        let textHtml = passedData[j].textHtml;

                        let markerLocation = new L.LatLng(lat, lng);
                        let marker = new L.Marker(markerLocation);
                        passedData[j].marker = marker;

                        //Creazione del popup per il pin appena creato
                        popupText = "<span class='mapPopupLine'>" + textHtml + "</span>";

                        map.defaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [0, 0] }).openPopup();

                        map.eventsOnMap.push(passedData[j]);

                    }
                }

                if (addMode === 'additive') {
                    addGeoInfoPinToMap();
                }

                if (addMode === 'exclusive') {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType !== 'GeoInfoPin') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;
                            break;
                        }
                    }
                    //Remove WidgetAlarm active pins
                    $.event.trigger({
                        type: "removeAlarmPin",
                    });
                    //Remove WidgetEvacuationPlans active pins
                    $.event.trigger({
                        type: "removeEvacuationPlanPin",
                    });
                    //Remove WidgetSelector active pins
                    $.event.trigger({
                        type: "removeSelectorEventPin",
                    });
                    //Remove WidgetEvents active pins
                    $.event.trigger({
                        type: "removeEventFIPin",
                    });
                    //Remove WidgetResources active pins
                    $.event.trigger({
                        type: "removeResourcePin",
                    });
                    //Remove WidgetTrafficEvents active pins
                    $.event.trigger({
                        type: "removeTrafficEventPin",
                    });
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                        maxZoom: leafletMaxZoom,
                        maxNativeZoom: leafletNativeMaxZoom
                    }).addTo(map.defaultMapRef);

                    addOperatorEventToMap();
                }

                //console.log(map.eventsOnMap.length);

                // resizeMapView(map.defaultMapRef);
            }
        });

        //####################################################################################################################
        //########################################## Collini #################################################################
        //################################### TRAFFIC SCENARY BUILDER SECTION ################################################
        // - variable, function, classes definition                           ################################################
        // - main progam - SCENARIO BUILDER EVENT TRIGGERED                   ################################################
        // - removeTrafficScenary                                             ################################################
        //####################################################################################################################
        //####################################################################################################################

        //#####################################################################################################
        //#####################################################################################################
        //####################### variable, function, classes definition  #####################################
        //#####################################################################################################
        //#####################################################################################################
        //

        //global variables........
        const SENSOR_API_URL = "https://www.snap4city.org/superservicemap/api/v1/?";
        var lAccessToken = null; // variabile per tenere il mio access token per le richieste                
        var lorganizzazione = '<?= $scenaryEditorDefaultOrganization; ?>';
        var ilbrokerdellorganizzazione = '<?= $scenaryEditorDefaultOrgBroker; ?>';
        var drawerControl = null; // layer di riferimento dell tool per la selezione di disegni su mappa
        var scenaryDrawnItems = null; // layer di riferimento per gli oggetti disengati sulla mappa              
        var scenaryControl = null;  // layer di riferimento per il pannello di controllo dello scenary builder
        var scenaryMarkers = null; // layer di riferimento per i sensori nel poligono disegnato                      
        var scenaryData = new L.geoJSON(); // variabile di riferimento per i metadati e json dello scenario
        var scenarioData = null; // variabile per tenere i dati in json dello scenario considerato per poi restituirlo
        var isStatoAccorpato = false;
        var isSaveFinalSet = false; // mi inizializzo il controllo se il bottone è stato inserito                
        var loadingboxloaded = false; //  mi inizializzo la var per attendere che il grafo sia caricato per salvare lo scenario
        scenaryData.type = "FeatureCollection";
        scenaryData.features = [];
        var datidaisensorichestoconsiderando = []; // variabile di riferimento per i dati dei sensori reali
        var istanzedeisensorichestoconsiderando = []; // variabile di appoggio per tenere le istanze dei dati up della classe ISensori
        var istanzedelgrafochestoconsiderando = []; // variabile di appoggio per tenere i road element identificativi del grafo
        var acData = []; // inizializzo la variabie per contenere il grafo accorpato
        var js20Data = []; // inizializzo la variabile per contenere il js a 20 metri
        ///
        var jsonStreetGraph = '';
        //
        //debugger;
        var scenaryOtherSensors = []; // layer di riferimento per gli altri sensori non traffic.
        //
        var scenarioRestrictions = []; //Array delle restrizioni nei segnmenti.

        var roadElementGraph;
        var restriction_data;
        var otherSensorMarkers = [];

        var currentLoadedScenario = ''; //Device di uno scneario caricato
        var currentLoadedVersion = ''; //Versione di uno scneario caricato
        var currentLoadedStatus = '';
        ///
        var arrayTrafficDensity = [];
        var arrayTrafficSensors = [];

        // nuova var globale per gestire i segmenti con sensori del load dell'accorpato che vanno persi
        var riferimentoSensoriAccorpato = [];
        // nuova var per tenermi il fatherDateObserved che al risalvataggio de'acc non lo consideravamo
        var questofather = "";

        //loadedACC PAramters
        var loadedtmpAcData = '';
        var loadedAcData = '';
        var loadedjs20Data = '';
        var loadtmpRDGraph = '';

        // ENRICO per rimettere i dati nel db quelli giusti al risalvataggio dell'acc
        var loadedAccAC = '';
        var loadedAccRoadGraph = '';
        var loadedAccFilters = '';
        var loadedAccSensors = '';
        var loadedAccRestrictions = '';
        var loadedAccJS20= '';
        //


        


        var saveLoadGraph = []; //Array per salvare lo stato completo di un grafo caricato 

        //############################ UTILS functions #######################################################
        // handleIntersectionsAndSensors(polygonWKT)
        // getPolygonWKTFromScenarioArea(scenarioareaOfInterest)
        // calculateIntersection(point1, point2, point3, point4)
        // calculateIntersections(strade,polygonCoordinates)
        // removeParenthesesFromValues(obj)
        // removeTrattiniFromValues(obj)
        // showNotification(message)

        /////////////////CHECK possible restrictions 
        // richiede libreria proj4.js (https://github.com/proj4js/proj4js)

        function insertMarkerForOtherSensors(sensorSURI) {
            
            const mapname = "<?= $_REQUEST['name_w'] ?>";
            
            var coordsAndType = {};
            coordsAndType.eventGenerator = $(this);
            coordsAndType.desc = "other sensors";
            coordsAndType.query = sensorSURI;
            coordsAndType.color1 = "#ebb113";
            coordsAndType.color2 = "#eb8a13";
            coordsAndType.targets = ""; //<TARGET_TIME_TREND_WIDGET_NAME_(OPTIONAL)>;
            coordsAndType.display = "pins";
            coordsAndType.queryType = "Default";
            coordsAndType.iconTextMode = "text";
            coordsAndType.pinattr = "square";
            coordsAndType.pincolor = "#959595";
            coordsAndType.symbolcolor = "undefined";
            coordsAndType.bubbleSelectedMetric = "";



            // document.getElementsByClassName('gs_w')
            $('body').trigger({
                type: "addSelectorPin",
                target: "Map_9_widgetMap28", //<TARGET_WIDGET_NAME>, 
                passedData: coordsAndType
            });
        }


        function getCartesianFromLatLon(lat, lon) {
            var source = new proj4.Proj('EPSG:4326');    //source coordinates will be in Longitude/Latitude, WGS84
            var dest = new proj4.Proj('EPSG:3785');     //destination coordinates in meters, global spherical mercators projection, see http://spatialreference.org/ref/epsg/3785/
            // transforming point coordinates
            var p = new proj4.Point(lon, lat);   //any object will do as long as it has 'x' and 'y' properties
            //console.log(p);
            var p2 = proj4.transform(source, dest, p);      //do the transformation.  x and y are modified in place
            //console.log(p2);
            return p2;
        }

        function checkPossibleRestrictions(reID, graph, prefix, types) {
            var restrictions = [];
            const keyvalue = prefix + reID;
            const re = graph[keyvalue]; //Object.keys(graph).find(key => graph[key] === keyvalue);  
            const reEndNode = re.nodeB;
            var linkedRE = [];
            var linkedNode = [];
            for (let key in graph) {
                //console.log(key);
                if (key != keyvalue) {	// escludo il RE in esame
                    const sNode = graph[key].nodeA;
                    const type = graph[key].type;
                    if (sNode === reEndNode && types.includes(type)) {
                        linkedRE.push(key);
                        linkedNode.push(sNode);
                    }
                }
            }
            console.log(linkedRE);

            const xyzS = getCartesianFromLatLon(re.nALat, re.nALong);
            const xyzE = getCartesianFromLatLon(re.nBLat, re.nBLong);
            const vx = xyzE.x - xyzS.x;
            const vy = xyzE.y - xyzS.y;
            const nn = Math.sqrt((vx * vx) + (vy * vy));
            const vxn = vx / nn;
            const vyn = vy / nn;

            for (let i = 0; i < linkedRE.length; i++) {
                var key = linkedRE[i];
                var keynode = linkedNode[i];
                console.log(key);

                const xyzS_ = getCartesianFromLatLon(graph[key].nALat, graph[key].nALong);
                const xyzE_ = getCartesianFromLatLon(graph[key].nBLat, graph[key].nBLong);
                const vx_ = xyzE_.x - xyzS_.x;
                const vy_ = xyzE_.y - xyzS_.y;
                const nn_ = Math.sqrt((vx_ * vx_) + (vy_ * vy_));
                const vxn_ = vx_ / nn_;
                const vyn_ = vy_ / nn_;

                const dot = (vxn * vxn_) + (vyn * vyn_);
                const det = (vxn * vyn_) - (vyn * vxn_);
                const angle = Math.atan2(det, dot) * 180 / Math.PI;
                console.log(angle);
                //var angle = Math.acos( dot )*180/Math.PI;
                //console.log(angle);

                if ((-45 <= angle && angle <= 0) || (0 <= angle && angle <= 45)) {
                    restrictions.push({
                        id: key,
                        node: keynode,
                        turn: ['only_straight_on', 'no_straight_on']
                    });
                }
                if (-135 <= angle && angle <= -45) {
                    restrictions.push({
                        id: key,
                        node: keynode,
                        turn: ['only_right_turn', 'no_right_turn']
                    });
                }
                if (45 <= angle && angle <= 135) {
                    restrictions.push({
                        id: key,
                        node: keynode,
                        turn: ['only_left_turn', 'no_left_turn']
                    });
                }

                if ((-180 <= angle && angle <= -135) || (135 <= angle && angle <= 180)) {
                    restrictions.push({
                        id: key,
                        node: keynode,
                        turn: ['no_u_turn']
                    });
                }
            }
            return restrictions;
        }

        ////////END CHECK possible restriction




        // Function to handle road intersections and add sensors to the map
        
        /* function handleIntersectionsAndSensors(polygonWKT) {
            console.log('handleIntersectionsAndSensors polygonWKT');
            const roadIntersections = calculateIntersections(istanzedelgrafochestoconsiderando, polygonWKT.match(/\d+\.\d+\s\d+\.\d+/g).map(coordinateStr => coordinateStr.split(' ').map(Number)));
            roadIntersections.forEach(intersection => {
                const elementoStradaleUri = intersection.elementoStradaleUri;
                const intersectionPoints = intersection.intersectionPoints;
                intersectionPoints.forEach(point => {
                    const lat = point.lat;
                    const lon = point.lon;
                    console.log('ilSensore');
                    const ilSensore = new IlSensore(elementoStradaleUri, [lon, lat], true, '', '');
                    istanzedeisensorichestoconsiderando.push(ilSensore);
                    scenaryMarkers.addLayer(ilSensore.marker);
                });
            });
        } */

        /* function isPointInPolygon(point, polygon) {
            const [px, py] = point;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const [xi, yi] = polygon[i];
                const [xj, yj] = polygon[j];
                
                const intersect = ((yi > py) !== (yj > py)) &&
                                (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        } */


        // algoritmo Winding Number
        function isPointInPolygon(point, polygon) {
            const [px, py] = point;
            let windingNumber = 0;

            for (let i = 0; i < polygon.length; i++) {
                const [x0, y0] = polygon[i];
                const [x1, y1] = polygon[(i + 1) % polygon.length];
                
                if (y0 <= py) {
                    if (y1 > py && isLeft(x0, y0, x1, y1, px, py)) {
                        windingNumber++;
                    }
                } else {
                    if (y1 <= py && !isLeft(x0, y0, x1, y1, px, py)) {
                        windingNumber--;
                    }
                }
            }
            
            return windingNumber !== 0;
        }

        // Funzione che verifica se il punto (px, py) è a sinistra della linea (x0, y0) -> (x1, y1)
        function isLeft(x0, y0, x1, y1, px, py) {
            return ((x1 - x0) * (py - y0) - (y1 - y0) * (px - x0)) > 0;
        }

        // Converti il polygonWKT in un array di coordinate
        function parseWKTPolygon(polygonWKT) {
            const coords = polygonWKT
                .replace('POLYGON((', '')
                .replace('))', '')
                .split(',')
                .map(coord => coord.trim().split(' ').map(Number));
            return coords;
        }

        function associaTTT(tipodistrada, arrayTrafficDensity) {
            let ilTTT = "d_unclassified";
            if (tipodistrada === "primary") {
                ilTTT = "d_primary";
            } else if (tipodistrada === "secondary") {
                ilTTT = "d_secondary";
            } else if (tipodistrada === "tertiary") {
                ilTTT = "d_tertiary";
            } else if (tipodistrada === "residential") {
                ilTTT = "d_residential";
            }

            // Controlla se ilTTT è presente in arrayTrafficDensity
            if (arrayTrafficDensity.includes(ilTTT)) {
                return ilTTT;
            } else {
                return "";  //o "" insomma il Valore di default se ilTTT non è presente in arrayTrafficDensity
            }
        }

        function handleIntersectionsAndSensors(polygonWKT) {
                console.log('handleIntersectionsAndSensors polygonWKT');
                const polygonCoordinates = polygonWKT.match(/\d+\.\d+\s\d+\.\d+/g).map(coordinateStr => coordinateStr.split(' ').map(Number));
                const roadIntersections = calculateIntersections(istanzedelgrafochestoconsiderando, polygonCoordinates);
                
                //const polygonCoords = parseWKTPolygon(polygonWKT);
                var virtualcounter = 0;
                roadIntersections.forEach(intersection => {
                    const elementoStradaleUri = intersection.elementoStradaleUri;
                    let tipo_del_sensore_in_base_alla_strada = intersection.tipo_del_sensore_in_base_alla_strada;
                    let direzione_della_strada_del_sensore = intersection.direzione_della_strada_del_sensore;
                    const intersectionPoints = intersection.intersectionPoints; // c'è la s ma è singolo
                    const startLat = intersection.startlat;
                    const startLong = intersection.startlong;
                    const endLat = intersection.endlat;
                    const endLong = intersection.endlong;

                    const startPoint = [startLong, startLat];
                    const endPoint = [endLong, endLat];

                    // Determina se startPoint è dentro il poligono
                    const isStartInside = isPointInPolygon(startPoint, polygonCoordinates)

                    direction = isStartInside ? "OutFlow" : "InFlow";
                    if( direzione_della_strada_del_sensore != "tratto stradale aperto nella direzione positiva (da giunzione NOD_INI a giunzione NOD_FIN)"){
                        direction = "Bidirectional" ;
                    }
                        
                    
                    intersectionPoints.forEach(point => {
                        const lat = point.lat;
                        const lon = point.lon;
                        //CONTROL
                        //
                        /*var searchingGraph = istanzedelgrafochestoconsiderando.find(obj => obj.segment === elementoStradaleUri);
                        var searchigType = SearchingGraph.type;*/
                        //

                        // codice per gestire il trafficDesity e il trafficSesor assegato di default
                        console.log("ENRICO: arrayTrafficDensity"+ arrayTrafficDensity);
                        
                        let ilTTT = associaTTT(tipo_del_sensore_in_base_alla_strada, arrayTrafficDensity);
                        //
                        
                        const ilSensore = new IlSensore(elementoStradaleUri, [lon, lat], true, ilTTT, '', direction, tipo_del_sensore_in_base_alla_strada,'on',virtualcounter);
                        istanzedeisensorichestoconsiderando.push(ilSensore);
                        scenaryMarkers.addLayer(ilSensore.marker);
                                if (ilSensore.status == 'off'){
                                    ilSensore.turnOff();
                                }else{
                                    ilSensore.turnOn();
                                }
                        //
                        virtualcounter++;
                        //
                    });
                    //db_NEW
                                if(istanzedeisensorichestoconsiderando.length > 0){
                                    //console.log('è maggiore di 0');
                                    roadElementGraph.loadSensors(istanzedeisensorichestoconsiderando);
                                }else{
                                    //console.log('è uguale a 0');
                                }
                    //////////
                });
            }

        // funzione che mi converte il poligono che ho in WKT
        function getPolygonWKTFromScenarioArea(scenarioareaOfInterest) {
            //console.log('getPolygonWKTFromScenarioArea:',scenarioareaOfInterest);
            const coordinates = scenarioareaOfInterest[0].geometry.coordinates[0].map(coordPair => coordPair.join(" ")).join(", ");
            const polygonWKT = `POLYGON ((${coordinates}))`;
            return polygonWKT;
        }


        ///////////BOLOGNA -> Load Scenario ////////
        function loadScenarioSensor(list) {
            console.log('loadScenarioSensor', list);
            for (i = 0; i < list.length; i++) {
                var suri = list[i];
                /////
                $.ajax({
                    url: "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + suri,
                    type: "GET",
                    data: {},
                    async: true,
                    timeout: 0,
                    dataType: 'json',
                    success: function (data) {
                        //geometryGeoJson
                        //console.log(data.Service.features[0]);
                        if (data.Service !== undefined) {
                            if (data.Service.features !== undefined) {
                                var geometry = data.Service.features[0].geometry;
                                var properties = data.Service.features[0].properties;
                                /////////
                                var newMarker = gisPrepareCustomMarker(data.Service.features[0], { "lng": geometry.coordinates[0], "lat": geometry.coordinates[1] });
                                map.defaultMapRef.addLayer(newMarker);
                                oms.addMarker(newMarker);
                                otherSensorMarkers.push(newMarker);
                            }
                        }
                        ///////////                                  
                    },
                    error: function (geometryErrorData) {
                        console.log("Ko");
                        console.log(JSON.stringify(geometryErrorData));
                    }
                });
            }
            //////////

        }
        ///////////END Load Scenario //////////

        // funzione che mi calcola l'intersezione tra due punti che in realtà sono i primi del perimetro del polygon wkt 
        // e gli altri due sono del road element...  mammamia però funziona ;)
        function calculateIntersection(point1, point2, point3, point4) {
            const x1 = point1.lon;
            const y1 = point1.lat;
            const x2 = point2.lon;
            const y2 = point2.lat;
            const x3 = point3[0];
            const y3 = point3[1];
            const x4 = point4[0];
            const y4 = point4[1];
            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                const lon = x1 + ua * (x2 - x1);
                const lat = y1 + ua * (y2 - y1);
                return { lat, lon }; // ritorna l'intersezione
            }
            return null; // Nessuna intersezione
        }

        // e questo era solo l'inizio ecco la funzione per calcolare le intersezioni...
        // Funzione per calcolare l'intersezione tra una strada e il poligono

        function calculateIntersections(strade, polygonCoordinates) {
            const intersections = [];
            for (const strada of strade) {
                // tipo di strada 
                let tipo_del_sensore_in_base_alla_strada = strada['type'];
                let direzione_della_strada_del_sensore = strada['dir'];
                const startlat = strada['nALat'];
                const startlong = strada['nALong'];
                const endlat = strada['nBLat'];
                const endlong = strada['nBLong'];
                const elementostradale = strada['segment'];
                // Creazione di una LineString per rappresentare la strada
                const roadCoordinates = [
                    { lon: startlong, lat: startlat },
                    { lon: endlong, lat: endlat }
                ];
                // Controllo delle intersezioni tra la strada e il perimetro del poligono
                const intersectionPoints = [];
                for (let i = 0; i < roadCoordinates.length - 1; i++) {
                    const point1 = roadCoordinates[i];
                    const point2 = roadCoordinates[i + 1];
                    for (let j = 0; j < polygonCoordinates.length - 1; j++) {
                        const polygonPoint1 = polygonCoordinates[j];
                        const polygonPoint2 = polygonCoordinates[j + 1];
                        const intersection = calculateIntersection(point1, point2, polygonPoint1, polygonPoint2);
                        if (intersection) {
                            intersectionPoints.push(intersection);
                        }
                    }
                }
                if (intersectionPoints.length > 0) {
                    intersections.push({
                        elementoStradaleUri: elementostradale,
                        tipo_del_sensore_in_base_alla_strada: tipo_del_sensore_in_base_alla_strada,
                        direzione_della_strada_del_sensore: direzione_della_strada_del_sensore,
                        intersectionPoints: intersectionPoints,
                        startlat: startlat,
                        startlong: startlong,
                        endlat: endlat,
                        endlong: endlong
                    });
                }
            }
            return intersections;
        }


        // Function to remove parentheses from values
        function removeParenthesesFromValues(obj) {
            if (typeof obj !== "object" || obj === null) {
                return obj;
            }
            if (Array.isArray(obj)) {
                return obj.map(removeParenthesesFromValues);
            }
            const newObj = {};
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    const value = obj[key];
                    if (typeof value === "string") {
                        newObj[key] = value.replace(/[()]/g, ""); // Remove parentheses from strings
                    } else {
                        newObj[key] = removeParenthesesFromValues(value);
                    }
                }
            }
            return newObj;
        }

        // Function to remove parentheses from values
        function removeTrattiniFromValues(obj) {
            if (typeof obj !== "object" || obj === null) {
                return obj;
            }
            if (Array.isArray(obj)) {
                return obj.map(removeTrattiniFromValues);
            }
            const newObj = {};
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    const value = obj[key];
                    if (typeof value === "string") {
                        newObj[key] = value.replace(/-/g, ""); // Remove parentheses from strings
                    } else {
                        newObj[key] = removeTrattiniFromValues(value);
                    }
                }
            }
            return newObj;
        }

        // funciton to handle the visualization of the notifications of the scenario-builder menu
        function showNotification(message) {
            const notification = document.getElementById("notification");
            const notificationMessage = document.getElementById("notification-message");
            // Imposta il messaggio della notifica
            notificationMessage.innerText = message;
            // Mostra la notifica
            notification.style.display = "block";
            notification.style.width = '220px';
            // Nasconde la notifica dopo 5 secondi (5000 millisecondi)
            setTimeout(() => {
                notification.style.display = "none";
            }, 15000);
        }

        async function changeScenarioTypeToLoad(selectedId) { 
            // Ottieni l'ID del radio button selezionato
            //var selectedId = $(this).attr("id");
            console.log('CHANGE 02');
            console.log('change: ' + selectedId);

            // Determina il tipo di scenario in base all'ID
            var scenarioType;
            if (selectedId === "acc-type-init") {

                document.getElementById("scenario-init-list").disabled = true;
                document.getElementById("scenario-version-list").disabled = true;

                scenarioType = "init";
                // Nascondi la lista degli scenari se il tipo non è "ACC"
                $(".scenario-list-row").hide();
                document.getElementById("scenario-init-row").style.display = "block";
                $(".scenario-tdm-row").hide();
                var initScenarios0 = await getScenarios(scenarioType);
                // //console.log('initScenarios',initScenarios);
                var scenarioInitList = $("#scenario-init-list");

                // var searchInput = $("#search-scenario-init");
                // searchInput.on("input", function () {
                //     var searchTerm = $(this).val().toLowerCase();
                //     filterScenarios(initScenarios, searchTerm);
                // });
                var initScenarios = [...new Set(initScenarios0)];
                scenarioInitList.empty();
                initScenarios.sort();
                initScenarios.forEach(scenario => {
                    var optionValue = scenario.replace("deviceName", "");
                    //var optionText = optionValue + " -> " + scenario;
                    var optionText = optionValue;
                    var listItem = $("<option>").val(scenario).text(optionText);
                    scenarioInitList.append(listItem);
                });
                await getScenarioDates($('#scenario-init-list').val(), $('#scenario-version-list'), 'init');

                document.getElementById("scenario-init-list").disabled = false;
                document.getElementById("scenario-version-list").disabled = false;

            } else if (selectedId === "acc-type-acc") {

                document.getElementById("scenario-list").disabled = true;
                document.getElementById("acc-list").disabled = true;

                scenarioType = "acc";
                // Mostra la lista degli scenari solo se il tipo è "ACC"
                $(".scenario-list-row").show();
                document.getElementById("scenario-init-row").style.display = "none";
                $(".scenario-tdm-row").hide();
                var accScenarios0 = await getScenarios(scenarioType);
                var scenarioList = $("#scenario-list");
                scenarioList.empty(); // Pulisci eventuali opzioni preesistenti
                var accScenarios = [...new Set(accScenarios0)];
                accScenarios.sort();
                accScenarios.forEach(scenario => {
                    var scenarioName = scenario.replace("deviceName", "");
                    var option = $("<option>").val(scenario).text(scenarioName);
                    scenarioList.append(option);
                });
                await getScenarioDates($('#scenario-list').val(), $('#acc-list'), 'acc');

                document.getElementById("scenario-list").disabled = false;
                document.getElementById("acc-list").disabled = false;
                
            } 
            // else if (selectedId === "acc-type-tdm") {

            //     scenarioType = "tfr";
            //     $(".scenario-list-row").hide();
            //     $("#scenario-init-row").hide();
            //     $(".scenario-tdm-row").show();

            //     var tdmScenarios0 = await getScenarios(scenarioType);
            //     //console.log(tdmScenarios);
            //     var scenarioTDMList = $("#scenario-tdm-list");
            //     /*
            //     var searchInputTDM = $("#search-scenario-tdm");
            //     searchInputTDM.on("input", function () {
            //         var searchTermTDM = $(this).val().toLowerCase();
            //         filterScenariosTDM(tdmScenarios, searchTermTDM);
            //     });*/

            //     scenarioTDMList.empty();
            //     var tdmScenarios = [...new Set(tdmScenarios0)];
            //     tdmScenarios.sort();
            //     tdmScenarios.forEach(scenario => {

            //         var optionValue = scenario.replace("deviceName", "");
            //         var optionText = optionValue + " -> " + ilbrokerdellorganizzazione + "_" + lorganizzazione + "_" + scenario;
            //         var listItem = $("<option>").val(scenario).text(optionValue);
            //         scenarioTDMList.append(listItem);
            //     });
            //     getScenarioDates($('#scenario-tdm-list').val(), $('#tdm-list'), 'tdm');
            //     //  pulisciTutto();
            //     // function filterScenariosTDM(scenarios, searchTerm) {
            //     //     var scenarioTDMList = $("#scenario-tdm-list");
            //     //     scenarioTDMList.empty();

            //     //     scenarios.forEach(scenario => {
            //     //         if (scenario.toLowerCase().includes(searchTerm) || scenario.toLowerCase().includes('acc')) {
            //     //             var optionValue = scenario.replace("deviceName", "");
            //     //             var optionText = optionValue + " -> " + ilbrokerdellorganizzazione + "_" + lorganizzazione + "_" + scenario;
            //     //             var listItem = $("<option>").val(scenario).text(optionText);
            //     //             scenarioTDMList.append(listItem);
            //     //         }
            //     //     });
            //     // }
            // }

            if (scenarioType) {
                console.log("Scenario type selected: " + scenarioType);
                // Esegui qui le azioni specifiche in base al tipo di scenario
            } else {
                console.error("Errore nel determinare il tipo di scenario.");
            }
        }

        // funzione per pulire tutte le cose relative al caso accorpato
        function pulisciTutto() {

            console.log('>>> START CLEANING <<<');

            $('#road_types').prop('disabled', true);
            
            restriction_data = [];            
            saveLoadGraph = [];

            $('#selectAllRoad').prop("checked", false);
            $('#SelectNoRoad').prop("checked", false);
            var roadcheckboxes = document.querySelectorAll('.checkRoadType');
            var selectedRoadTypes = [];
            roadcheckboxes.forEach( (checkbox) => {                
                if(!checkbox.checked){
                    checkbox.checked = true;
                }
                selectedRoadTypes.push(checkbox.value);
            });
            if(roadElementGraph){
                roadElementGraph.filterTypes = selectedRoadTypes;
            }
            
            if (document.getElementById('filter-list') !== null) {
                if (!$('#filter-list').is(':hidden')) {
                    $('#filter-list').hide();
                    $("#road_types").css('background-color', '');
                    $("#road_types").css('color', 'black');
                }
            }

            if( !($('#showStreetGraph').is(':checked') ) ){
                $('#showStreetGraph').prop('checked', true)
            }

            if( !($('#showTrafficSensors').is(':checked') ) ){
                $('#showTrafficSensors').prop('checked', true)
            }

            var buttonToRemove = document.getElementById("scenario-save-finale1");
            //console.log('Pulisci Tutto!');
            if (istanzedeisensorichestoconsiderando.length > 0){
                istanzedeisensorichestoconsiderando.forEach(function (sersor) {
                            sersor.delete();
                    });
            }
            //
            if(roadElementGraph){
                roadElementGraph.clearSegments();
                roadElementGraph.clearNodes();
                roadElementGraph.reset();
                roadElementGraph.mode = 'drag';
                roadElementGraph = undefined;
                $("#line_create").css('background-color', '');
                $("#line_create").css('color', 'black');
                $("#line_drag").css('background-color', '#3E64A6');
                $("#line_drag").css('color', 'white');
                $("#line_split").css('background-color', '');
                $("#line_split").css('color', 'black');
                $("#line_delete").css('background-color', '');
                $("#line_delete").css('color', 'black');
            }
            if (scenaryData.features.length >= 0) {
                //console.log('scenaryData features ', scenaryData.features.length);
                // Rimuovi i layer dei disegni
                for (const layerId in scenaryDrawnItems._layers) {
                    scenaryDrawnItems.removeLayer(scenaryDrawnItems._layers[layerId]);
                }
                scenaryData.features = []; // reinizializzo questa variabile
                // Rimuovi i marker associati
                for (const layerId in scenaryMarkers._layers) {
                    const marker = scenaryMarkers._layers[layerId];
                    scenaryMarkers.removeLayer(marker);
                }
                // Rimuovi il vecchio grafo
                for (const layerId in scenaryGrafo._layers) {
                    const grafo = scenaryGrafo._layers[layerId];
                    scenaryGrafo.removeLayer(grafo);
                }
                //

                //
                datidaisensorichestoconsiderando = []; // reinizializzo questa variabile
                istanzedeisensorichestoconsiderando = []; // reinizializzo questa variabile
                istanzedelgrafochestoconsiderando = []; // reinizializzo questa variabile
            }

            for (let i=0; i < otherSensorMarkers.length; i++){
                map.defaultMapRef.removeLayer(otherSensorMarkers[i]);
            }
            otherSensorMarkers = [];

            $("#scenario-name").val("");
            $("#scenario-location").val("");
            $("#scenario-description").val("");
            $("#scenario-startDatetime").val("");
            $("#scenario-modality").val("generic");
            $("#scenario-modality").val("sensors");
            $("#scenario-referenceKB").val("");
            $("#scenario-endDatetime").val("");
            scenaryData = new L.geoJSON();
            scenaryData.type = "FeatureCollection";
            scenaryData.features = [];
            currentLoadedScenario = '';
            currentLoadedStatus = '';
            //
            loadedtmpAcData = '';
            loadedAcData = '';
            loadedjs20Data = '';
            loadtmpRDGraph = '';

            // ENRICO svuoto questi valori del db per il risalvataggio dell'acc
            loadedAccAC = '';
            loadedAccRoadGraph = '';
            loadedAccFilters = '';
            loadedAccSensors = '';
            loadedAccRestrictions = '';
            loadedAccJS20= '';
            //

            

            if($('#currentStatusEdit').val() == 'view'){
                $('input[name="scenario-type"][value="init"]').prop('checked', true).trigger('change');
            }
            //
            //$('#scenario-version-list').empty();
            //$('#acc-list').empty();
            //$('#scenario-check-tdm').empty();

            /*if (buttonToRemove) {
                buttonToRemove.remove();
                isSaveFinalSet = false; // Imposta la variabile a false per indicare che il bottone è stato rimosso
            }
            //rimuovi anche l'AC se è rimasto da uno scenario precedente
            if (scenaryData.features.length >= 0) {
                // Rimuovi i layer dei disegni
                for (const layerId in scenaryDrawnItems._layers) {
                    scenaryDrawnItems.removeLayer(scenaryDrawnItems._layers[layerId]);
                }
                scenaryData.features = []; // reinizializzo questa variabile
                // Rimuovi i marker associati
                for (const layerId in scenaryMarkers._layers) {
                    const marker = scenaryMarkers._layers[layerId];
                    scenaryMarkers.removeLayer(marker);
                }
                // Rimuovi il vecchio grafo
                for (const layerId in scenaryGrafo._layers) {
                    const grafo = scenaryGrafo._layers[layerId];
                    scenaryGrafo.removeLayer(grafo);
                }
                datidaisensorichestoconsiderando = []; // reinizializzo questa variabile
                istanzedeisensorichestoconsiderando = []; // reinizializzo questa variabile
                istanzedelgrafochestoconsiderando = []; // reinizializzo questa variabile
            }*/

            console.log('>>> DONE CLEANING <<<');
        }

        //############################## API and SPARQL functionsss #########################################
        // getLAccessToken()
        //getScenarios(currentStatus)
        // getLeAltreUserInfo()
        // buildSensorAPIURL(polygonWKT)
        // buildSparqlQueryURL(polygonWKT) //road graph
        // buildSparqlQueryURLsvolte(polygonWKT)
        // fetchTrafficSensorData(sensorURL)
        // fetchSparqlDataSvolte(sparqlQuery)
        // fetchSparqlData(sparqlQuery) // grafo strade
        // readFromDevice(lAccessToken, deviceName)
        // createDevice(lAccessToken, deviceName, polygon, ilcentroide)
        // sendDataINIT(lAccessToken, deviceName, scenario_data)
        // sendDataACC(lAccessToken, deviceName, js20Data,acData,svolte) 

        function dragPopup(elmnt, elementaDraggable = null) {
            var pos1 = 0,
                pos2 = 0,
                pos3 = 0,
                pos4 = 0;
            if (elementaDraggable != null) {
                // if present, the header is where you move the DIV from:
                elementaDraggable.onmousedown = dragMouseDown;
                //elementaDraggable.bind('touchstart', e => {e.preventDefault(); dragMouseDown(e)});
            } else {
                // otherwise, move the DIV from anywhere inside the DIV:
                elmnt.onmousedown = dragMouseDown;
                //elmnt.bind('touchstart', e => {e.preventDefault(); dragMouseDown(e)});
            }

            function dragMouseDown(e) {
                e = e || window.event;
                if (e.clientX) {
                    e.preventDefault();
                } else {
                    e.clientX = e.originalEvent.targetTouches[0].clientX;
                    e.clientY = e.originalEvent.targetTouches[0].clientY;
                }
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.addEventListener('touchend', closeDragElement);
                document.onmousemove = elementDrag;
                document.addEventListener('touchmove', elementDrag);
                // document.ontouchmove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;
                if (e.clientX && e.clientY) {
                    e.preventDefault();
                } else {
                    e.clientX = e.targetTouches[0].clientX;
                    e.clientY = e.targetTouches[0].clientY;
                }
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;


                const y = elmnt.offsetTop - pos2;
                const x = elmnt.offsetLeft - pos1;
                //popupCoord = viewport.unproject([x, y]);
                elmnt.style.top = y + "px";
                elmnt.style.left = x + "px";
                //elmnt.left = x;
                //reloadPopupDiv();
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.ontouchend = null;
                document.onmousemove = null;
                document.ontouchmove = null;

                document.removeEventListener('touchend', closeDragElement);
                document.removeEventListener('touchmove', elementDrag);
            }
        }

        //function to get the access token
        async function getLAccessToken() {
            if ("<?= $_SESSION['refreshToken'] ?>" != null && "<?= $_SESSION['refreshToken'] ?>" != "") {
                        //OLD

                       /* const result = await $.ajax({
                            url: "../controllers/getAccessToken.php",
                            data: {
                                refresh_token: "<?= $_SESSION['refreshToken'] ?>"
            },
            type: "GET",
                async: true,
                    dataType: 'json',
                        success: function (dataSso) {
                            lAccessToken = dataSso.accessToken;
                            return lAccessToken;
                        },
            error: function (errorData) {
                console.log("Error in AJAX request for access token.");
            }
        });*/

        //NEW
        let result;
        try {
            result = await $.ajax({
                url: "../controllers/getAccessToken.php",
                data: {
                    refresh_token: "<?= $_SESSION['refreshToken'] ?>"
                },
                type: "GET"
            });
            //console.log('result',result);
            return result;

        } catch (error) {
            console.error('Error: ', error);
        }

    }
                }
    
    async function getScenarioDates(selectedOption, targetlist, mode) {

        targetlist[0].disabled = true;
        //var selectedOption = $(this).val();
        console.log("Selected option: " + selectedOption);
        var suri = "<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + selectedOption;
        var url = "<?= $endprocessloader; ?>" + `getOneSpecific.php?suri=${suri}&accessToken=${lAccessToken}`;
        targetlist.empty();

        var listScen = await getLAccessToken();
        if (listScen != undefined) {
            var listScen1 = JSON.parse(listScen);
            if (listScen1.accessToken) {
                lAccessToken = listScen1.accessToken;
            }
        }

        $.ajax({
            type: 'GET',
            url: url,
            dataType: "json",
            data: { 'accessToken': lAccessToken },
            contentType: 'application/json; charset=utf-8',
            headers: { 'Authorization': `Bearer ${lAccessToken}` },
            async: false,
            success: function (data) {
                console.log(data);
                // scenario-version-list
                var obj = (data);
                for (var i = 0; i < obj.length; i++) {
                    var acc1 = JSON.parse(obj[i].data);

                    var dt = obj[i].dateObserved; // datetime from DB in GTM/UTC
                    var localeDT = new Date(dt.replace(" ", "T") + "Z"); //.toLocaleString(); //.replaceAll('/','-').replace(',',''); // datetime converted to local timezone
                    var year = localeDT.getFullYear();
                    var month = String(localeDT.getMonth() + 1).padStart(2, '0'); // Months are 0-based
                    var day = String(localeDT.getDate()).padStart(2, '0');
                    var hours = String(localeDT.getHours()).padStart(2, '0');
                    var minutes = String(localeDT.getMinutes()).padStart(2, '0');
                    var seconds = String(localeDT.getSeconds()).padStart(2, '0'); 
                    var localeDTstring = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;

                    if ( ((acc1.AC) || (acc1.grandidati.AC)) && mode=='acc' ) { // get dates of scenarios in ACC
                        targetlist.append(`<option value='` + obj[i].data + `'>` + localeDTstring + `</option>`);
                    } else if ( !((acc1.AC) || (acc1.grandidati.AC)) && mode=='init' ){                        
                        targetlist.append(`<option value='` + obj[i].data + `'>` + localeDTstring + `</option>`);
                    }
                }
                targetlist[0].disabled = false;
            }
        });
    }

    // funzione per prendere gli scenari presenti creati dall'utente 
    async function getScenarios(currentStatus) { // currentStatus è init acc o tdm
        console.log('Get List of scenarios');
        var listScen = await getLAccessToken();
        if (listScen != undefined) {
            var listScen1 = JSON.parse(listScen);
            if (listScen1.accessToken) {
                lAccessToken = listScen1.accessToken;
            }
            console.log('listScen1', listScen1);
        }

        const header = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "Authorization": `Bearer ${lAccessToken}`
        };
        try {
            var url = "<?= $mainsuperservicemap; ?>" + "/iot-search/?selection=43.769;11.25&maxDists=1000&model=TFRS-Model&maxResults=1000"; 
            if (currentStatus == 'All'){
                url = "<?= $mainsuperservicemap; ?>" + "/iot-search/time-range/?selection=43.7756;11.2490&maxDists=1000&model=TFRS-Model&maxResults=1000&aggregate=false&fromTime=2023-07-02T00:00:00";;
            }  else{
                url = "<?= $mainsuperservicemap; ?>" + "/iot-search/time-range/?selection=43.7756;11.2490&maxDists=1000&model=TFRS-Model&valueFilters=status:"+currentStatus+"&maxResults=1000&aggregate=false&fromTime=2023-07-02T00:00:00";
            }   
            const response = await fetch(url, { // oppure metti urlencoded
                method: "GET",
                headers: header
            });
            if (!response.ok) {
                throw new Error(`Error fetching sensor data: ${response.status}`);
            }
            const jsonResponse = await response.json();
            console.log(jsonResponse);
            // Extract deviceName values from the features array 
            var deviceNames;
            if(currentStatus !== 'All'){                           
                deviceNames = jsonResponse.features.filter(feature => feature.properties.values.status === currentStatus).map(feature => feature.properties.deviceName);
            }else{
                deviceNames = jsonResponse.features.filter(feature => feature.properties.values.status).map(feature => feature.properties.deviceName);
            }
            //
            deviceNames.sort(function(a, b) {
                            return a.toLowerCase().localeCompare(b.toLowerCase());
                        });
            //
            return deviceNames;
        } catch (error) {
            console.error("Oops: Something Else", error);
        }
        //return ["ACC Scenario 1", "ACC Scenario 2", "ACC Scenario 3"];
    }

    //function to get the organization and broker name
    async function getLeAltreUserInfo() {
        if ("<?= $_SESSION['refreshToken'] ?>" != null && "<?= $_SESSION['refreshToken'] ?>" != "") {
            const result = await $.ajax({
                url: "../controllers/getOrganizationParameters.php?action=getAllParameters",
                data: {
                    refresh_token: "<?= $_SESSION['refreshToken'] ?>"
                },
                type: "GET",
                async: true,
                dataType: 'json',
                success: function (dataSso) {
                    lorganizzazione = dataSso.orgName;
                    ilbrokerdellorganizzazione = dataSso.orgBroker;
                },
                error: function (errorData) {
                    console.log("Error in AJAX request for organization parameters token.");
                }
            });
            return result;
        }
    }

    //funzione che mi serve per creare l'api per prendere i dati dai sensori reali all'interno di un poligono WKT
    function buildSensorAPIURL(polygonWKT) {
        const params = new URLSearchParams({
            selection: `wkt:${polygonWKT}`,
            categories: "SensorSite",
            maxResults: 100, // la puoi modificare per ora lascio 100
            lang: "it",
            geometry: false,
            format: "json",
            realtime: true
        });
        return SENSOR_API_URL + params.toString();
    }

                // funzione che mi serve per creare l'api per prendere il grafo strade all'interno di un poligono WKT
                /*function buildSparqlQueryURL(polygonWKT){
                    const sparqlEndpoint = "https://www.disit.org/smosm/sparql?format=json&default-graph-uri=&format=application%2Fsparql-results%2Bjson&timeout=0&debug=on&query=PREFIX+km4c%3A+%3Chttp%3A%2F%2Fwww.disit.org%2Fkm4city%2Fschema%23%3EPREFIX+rdf%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%3EPREFIX+rdfs%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2000%2F01%2Frdf-schema%23%3EPREFIX+rdfsn%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23%3EPREFIX+dct%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E";                     
                    //const sparqlEndpoint = "<?= $sparqlURI; ?>" + "sparql ? format = json &default -graph - uri=& format=application % 2Fsparql - results % 2Bjson & timeout=0 & debug=on & query=PREFIX + km4c % 3A +% 3Chttp % 3A % 2F % 2Fwww.disit.org % 2Fkm4city % 2Fschema % 23 % 3EPREFIX + rdf % 3A +% 3Chttp % 3A % 2F % 2Fwww.w3.org % 2F1999 % 2F02 % 2F22 - rdf - syntax - ns % 23 % 3EPREFIX + rdfs % 3A +% 3Chttp % 3A % 2F % 2Fwww.w3.org % 2F2000 % 2F01 % 2Frdf - schema % 23 % 3EPREFIX + rdfsn % 3A +% 3Chttp % 3A % 2F % 2Fwww.w3.org % 2F2003 % 2F01 % 2Fgeo % 2Fwgs84_pos % 23 % 3EPREFIX + dct % 3A +% 3Chttp % 3A % 2F % 2Fpurl.org % 2Fdc % 2Fterms % 2F % 3E"; 
    // Sostituisci con l'endpoint SPARQL corretto            
    //const query = `SELECT ?strada ?elementostradale ?highwaytype ?startlat ?startlong ?endlat ?endlong ?compositiontipo ?operatingstatus ?latrafficDir ?lalunghezza ?startnode ?endnode ?elementtype (IF(bound(?quante), ?quante, 1) as ?quante) WHERE { ?strada a km4c:Road. ?strada km4c:inMunicipalityOf ?municip. ?municip foaf:name "Firenze". ?strada km4c:containsElement ?elementostradale. ?elementostradale km4c:endsAtNode ?endnode. ?elementostradale km4c:startsAtNode ?startnode. ?elementostradale km4c:elementType ?elementtype. ?elementostradale km4c:highwayType ?highwaytype. FILTER (?highwaytype IN ("primary", "tertiary", "residential", "unclassified")) ?elementostradale km4c:composition ?compositiontipo. ?elementostradale km4c:operatingStatus ?operatingstatus. ?elementostradale km4c:trafficDir ?latrafficDir. ?elementostradale km4c:length ?lalunghezza. ?startnode rdfsn:lat ?startlat. ?startnode rdfsn:long ?startlong. ?startnode geo:geometry ?p. ?elementostradale km4c:endsAtNode ?endnode. ?endnode rdfsn:lat ?endlat. ?endnode rdfsn:long ?endlong. OPTIONAL{ ?strada km4c:lanes ?lanes. ?lanes km4c:lanesCount ?numerolanes. ?numerolanes km4c:undesignated ?quante. } FILTER ( bif:st_intersects ( bif:st_geomfromtext ('${polygonWKT}'),  bif:st_geomfromtext(CONCAT("MULTIPOINT(", STR(?startlong), " ", STR(?startlat), ",", STR(?endlong), " ", STR(?endlat), ")")) ) ) } LIMIT 16000`;
    //NEW
    const query = `SELECT ?status ?strada ?elementostradale ?roadElmSpeedLimit ?roadMaxSpeed ?highwaytype (xsd:string(?startlat) as ?startlat) (xsd:string(?startlong) as ?startlong) (xsd:string(?endlat) as ?endlat) (xsd:string(?endlong) as ?endlong) ?compositiontipo ?operatingstatus ?latrafficDir ?lalunghezza ?startnode ?endnode ?elementtype (IF(bound(?quante), ?quante, 1) as ?quante) WHERE { ?strada a km4c:Road. ?strada km4c:inMunicipalityOf ?municip. ?municip foaf:name "Firenze". ?strada km4c:containsElement ?elementostradale. ?elementostradale km4c:endsAtNode ?endnode.  OPTIONAL{?elementostradale km4c:speedLimit ?roadElmSpeedLimit.} ?elementostradale km4c:startsAtNode ?startnode. ?elementostradale km4c:elementType ?elementtype. ?elementostradale km4c:highwayType ?highwaytype. FILTER (?highwaytype IN ("primary", "tertiary", "residential", "unclassified")) ?elementostradale km4c:composition ?compositiontipo. ?elementostradale km4c:operatingStatus ?operatingstatus. ?elementostradale km4c:trafficDir ?latrafficDir. ?elementostradale km4c:length ?lalunghezza. ?startnode rdfsn:lat ?startlat. ?startnode rdfsn:long ?startlong. ?startnode geo:geometry ?p. ?elementostradale km4c:endsAtNode ?endnode. ?endnode rdfsn:lat ?endlat. ?endnode rdfsn:long ?endlong. OPTIONAL{ ?strada km4c:lanes ?lanes. ?lanes km4c:lanesCount ?numerolanes. ?numerolanes km4c:undesignated ?quante.} FILTER ( bif:st_intersects ( bif:st_geomfromtext ('${polygonWKT}'),  bif:st_geomfromtext(CONCAT("MULTIPOINT(", STR(?startlong), " ", STR(?startlat), ",", STR(?endlong), " ", STR(?endlat), ")")) ) ) } LIMIT 16000`;
    return sparqlEndpoint + query;
                }*/

    function buildSparqlQueryURLottimizzata(maxX, maxY, minX, minY) {
        //const sparqlEndpoint = "https://www.disit.org/smosm/sparql?format=json&default-graph-uri=&format=application%2Fsparql-results%2Bjson&timeout=0&debug=on&query=PREFIX+km4c%3A+%3Chttp%3A%2F%2Fwww.disit.org%2Fkm4city%2Fschema%23%3EPREFIX+rdf%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%3EPREFIX+rdfs%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2000%2F01%2Frdf-schema%23%3EPREFIX+rdfsn%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23%3EPREFIX+dct%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E";                     
        //const sparqlEndpoint = "<?= $sparqlURI; ?>" + "sparql?format=json&default-graph-uri=&format=application%2Fsparql-results%2Bjson&timeout=0&debug=on&query=PREFIX+km4c%3A+%3Chttp%3A%2F%2Fwww.disit.org%2Fkm4city%2Fschema%23%3EPREFIX+rdf%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%3EPREFIX+rdfs%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2000%2F01%2Frdf-schema%23%3EPREFIX+rdfsn%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23%3EPREFIX+dct%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E"; 

        // query per KB su 235
        const sparqlEndpoint = "<?= $sparqlURI; ?>" + "sparql?format=json&default-graph-uri=&format=application%2Fsparql-results%2Bjson&timeout=0&query=PREFIX+km4c%3A+%3Chttp%3A%2F%2Fwww.disit.org%2Fkm4city%2Fschema%23%3EPREFIX+rdf%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%3EPREFIX+rdfs%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2000%2F01%2Frdf-schema%23%3EPREFIX+rdfsn%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23%3EPREFIX+dct%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E";


        // Sostituisci con l'endpoint SPARQL corretto
        //http://www.w3.org/1999/02/22-rdf-syntax-ns#>PREFIX            
        //const query = `SELECT ?strada ?elementostradale ?highwaytype ?startlat ?startlong ?endlat ?endlong ?compositiontipo ?operatingstatus ?latrafficDir ?lalunghezza ?startnode ?endnode ?elementtype (IF(bound(?quante), ?quante, 1) as ?quante) WHERE { ?strada a km4c:Road. ?strada km4c:inMunicipalityOf ?municip. ?municip foaf:name "Firenze". ?strada km4c:containsElement ?elementostradale. ?elementostradale km4c:endsAtNode ?endnode. ?elementostradale km4c:startsAtNode ?startnode. ?elementostradale km4c:elementType ?elementtype. ?elementostradale km4c:highwayType ?highwaytype. ?elementostradale km4c:composition ?compositiontipo. ?elementostradale km4c:operatingStatus ?operatingstatus. ?elementostradale km4c:trafficDir ?latrafficDir. ?elementostradale km4c:length ?lalunghezza. ?startnode rdfsn:lat ?startlat. ?startnode rdfsn:long ?startlong. ?startnode geo:geometry ?p. ?elementostradale km4c:endsAtNode ?endnode. ?endnode rdfsn:lat ?endlat. ?endnode rdfsn:long ?endlong. OPTIONAL{ ?strada km4c:lanes ?lanes. ?lanes km4c:lanesCount ?numerolanes. ?numerolanes km4c:undesignated ?quante. } FILTER ((?startlat >= ${minY} && ?startlat <= ${maxY} && ?startlong >= ${minX} && ?startlong <= ${maxX}) ||(?endlat >= ${minY} && ?endlat <= ${maxY} && ?endlong >= ${minX} && ?endlong <= ${maxX}) ) } LIMIT 16000`;
        //const query = `SELECT ?strada ?elementostradale ?highwaytype ?startlat ?startlong ?endlat ?endlong ?compositiontipo ?operatingstatus ?latrafficDir ?lalunghezza ?startnode ?endnode ?elementtype (IF(bound(?quante), ?quante, 1) as ?quante) WHERE { ?strada a km4c:Road. ?strada km4c:inMunicipalityOf ?municip. ?municip foaf:name "Firenze". ?strada km4c:containsElement ?elementostradale. ?elementostradale km4c:endsAtNode ?endnode. ?elementostradale km4c:startsAtNode ?startnode. ?elementostradale km4c:elementType ?elementtype. ?elementostradale km4c:highwayType ?highwaytype. ?elementostradale km4c:composition ?compositiontipo. ?elementostradale km4c:operatingStatus ?operatingstatus. ?elementostradale km4c:trafficDir ?latrafficDir. ?elementostradale km4c:length ?lalunghezza. ?startnode rdfsn:lat ?startlat. ?startnode rdfsn:long ?startlong. ?startnode geo:geometry ?p. ?elementostradale km4c:endsAtNode ?endnode. ?endnode rdfsn:lat ?endlat. ?endnode rdfsn:long ?endlong. OPTIONAL{ ?strada km4c:lanes ?lanes. ?lanes km4c:lanesCount ?numerolanes. ?numerolanes km4c:undesignated ?quante. } FILTER ( (?startlat > ${minX} %26%26 ?startlat < ${maxX} %26%26 ?startlong > ${minY} %26%26 ?startlong < ${maxY}) || (?endlat > ${minX} %26%26 ?endlat < ${maxX} %26%26 ?endlong > ${minY} %26%26 ?endlong < ${maxY}) )} LIMIT 16000`;
        //NEW
        //const query = `SELECT ?status ?strada ?elementostradale ?roadElmSpeedLimit ?roadMaxSpeed ?highwaytype (xsd:string(?startlat) as ?startlat) (xsd:string(?startlong) as ?startlong) (xsd:string(?endlat) as ?endlat) (xsd:string(?endlong) as ?endlong) ?compositiontipo ?operatingstatus ?latrafficDir ?lalunghezza ?startnode ?endnode ?elementtype (IF(bound(?quante), ?quante, 1) as ?quante) WHERE { ?strada a km4c:Road. ?strada km4c:inMunicipalityOf ?municip. ?municip foaf:name "Firenze". ?strada km4c:containsElement ?elementostradale. ?elementostradale km4c:endsAtNode ?endnode.  OPTIONAL{?elementostradale km4c:speedLimit ?roadElmSpeedLimit.} ?elementostradale km4c:startsAtNode ?startnode. ?elementostradale km4c:elementType ?elementtype. ?elementostradale km4c:highwayType|km4c:railwayType ?highwaytype. ?elementostradale km4c:composition ?compositiontipo. ?elementostradale km4c:operatingStatus ?operatingstatus. ?elementostradale km4c:trafficDir ?latrafficDir. ?elementostradale km4c:length ?lalunghezza. ?startnode rdfsn:lat ?startlat. ?startnode rdfsn:long ?startlong. ?startnode geo:geometry ?p. ?elementostradale km4c:endsAtNode ?endnode. ?endnode rdfsn:lat ?endlat. ?endnode rdfsn:long ?endlong. OPTIONAL{ ?strada km4c:lanes ?lanes. ?lanes km4c:lanesCount ?numerolanes. ?numerolanes km4c:undesignated ?quante.} FILTER ( (?startlat %3E ${minX} %26%26 ?startlat %3C ${maxX} %26%26 ?startlong %3E ${minY} %26%26 ?startlong %3C ${maxY}) || (?endlat %3E ${minX} %26%26 ?endlat %3C ${maxX} %26%26 ?endlong %3E ${minY} %26%26 ?endlong %3C ${maxY}) )} LIMIT 16000`;
        // questa ha funzionato -> const query = `SELECT ?status ?strada ?elementostradale (IF(bound(?roadElmSpeedLimit), ?roadElmSpeedLimit, "50") as ?roadElmSpeedLimit) ?roadMaxSpeed ?highwaytype (xsd:string(?startlat) as ?startlat) (xsd:string(?startlong) as ?startlong) (xsd:string(?endlat) as ?endlat) (xsd:string(?endlong) as ?endlong) ?compositiontipo ?operatingstatus ?latrafficDir ?lalunghezza ?startnode ?endnode ?elementtype (IF(bound(?quante), ?quante, 1) as ?quante) WHERE { ?strada a km4c:Road. ?strada km4c:inMunicipalityOf ?municip. ?municip foaf:name "Firenze". ?strada km4c:containsElement ?elementostradale. ?elementostradale km4c:endsAtNode ?endnode.  OPTIONAL{?elementostradale km4c:speedLimit ?roadElmSpeedLimit.} ?elementostradale km4c:startsAtNode ?startnode. ?elementostradale km4c:elementType ?elementtype. ?elementostradale km4c:highwayType|km4c:railwayType ?highwaytype. ?elementostradale km4c:composition ?compositiontipo. ?elementostradale km4c:operatingStatus ?operatingstatus. ?elementostradale km4c:trafficDir ?latrafficDir. ?elementostradale km4c:length ?lalunghezza. ?startnode rdfsn:lat ?startlat. ?startnode rdfsn:long ?startlong. ?startnode geo:geometry ?p. ?elementostradale km4c:endsAtNode ?endnode. ?endnode rdfsn:lat ?endlat. ?endnode rdfsn:long ?endlong. OPTIONAL{ ?strada km4c:lanes ?lanes. ?lanes km4c:lanesCount ?numerolanes. ?numerolanes km4c:undesignated ?quante.} FILTER ( (?startlat %3E ${minX} %26%26 ?startlat %3C ${maxX} %26%26 ?startlong %3E ${minY} %26%26 ?startlong %3C ${maxY}) || (?endlat %3E ${minX} %26%26 ?endlat %3C ${maxX} %26%26 ?endlong %3E ${minY} %26%26 ?endlong %3C ${maxY}) )} LIMIT 16000`;
        const query = `SELECT ?status ?strada ?elementostradale (IF(bound(?roadElmSpeedLimit), ?roadElmSpeedLimit, "50") as ?roadElmSpeedLimit) ?roadMaxSpeed ?highwaytype (xsd:string(?startlat) as ?startlat) (xsd:string(?startlong) as ?startlong) (xsd:string(?endlat) as ?endlat) (xsd:string(?endlong) as ?endlong) ?compositiontipo ?operatingstatus ?latrafficDir ?lalunghezza ?startnode ?endnode ?elementtype (IF(bound(?quante), ?quante, 1) as ?quante) WHERE { ?strada a km4c:Road. ?strada km4c:containsElement ?elementostradale. ?elementostradale km4c:endsAtNode ?endnode.  OPTIONAL{?elementostradale km4c:speedLimit ?roadElmSpeedLimit.} ?elementostradale km4c:startsAtNode ?startnode. ?elementostradale km4c:elementType ?elementtype. ?elementostradale km4c:highwayType|km4c:railwayType ?highwaytype. ?elementostradale km4c:composition ?compositiontipo. ?elementostradale km4c:operatingStatus ?operatingstatus. ?elementostradale km4c:trafficDir ?latrafficDir. ?elementostradale km4c:length ?lalunghezza. ?startnode rdfsn:lat ?startlat. ?startnode rdfsn:long ?startlong. ?startnode geo:geometry ?p. ?elementostradale km4c:endsAtNode ?endnode. ?endnode rdfsn:lat ?endlat. ?endnode rdfsn:long ?endlong. OPTIONAL{ ?strada km4c:lanes ?lanes. ?lanes km4c:lanesCount ?numerolanes. ?numerolanes km4c:undesignated ?quante.} FILTER ( (?startlat %3E ${minX} %26%26 ?startlat %3C ${maxX} %26%26 ?startlong %3E ${minY} %26%26 ?startlong %3C ${maxY}) || (?endlat %3E ${minX} %26%26 ?endlat %3C ${maxX} %26%26 ?endlong %3E ${minY} %26%26 ?endlong %3C ${maxY}) )}`; // LIMIT 100000`;
        return sparqlEndpoint + query;
    }

    // funzione che mi serve per creare l'api per prendere dalla KB le info sulle svolte
    function buildSparqlQueryURLsvolte(polygonWKT) {
        const sparqlEndpoint = "<?= $sparqlURI; ?>" + "sparql?format=json&default-graph-uri=&format=application%2Fsparql-results%2Bjson&timeout=0&debug=on&query=PREFIX+km4c%3A+%3Chttp%3A%2F%2Fwww.disit.org%2Fkm4city%2Fschema%23%3EPREFIX+rdf%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%3EPREFIX+rdfs%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2000%2F01%2Frdf-schema%23%3EPREFIX+rdfsn%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23%3EPREFIX+dct%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E";
        //const sparqlEndpoint =  "https://www.disit.org/smosm/sparql?format=json&default-graph-uri=&format=application%2Fsparql-results%2Bjson&timeout=0&debug=on&query=PREFIX+km4c%3A+%3Chttp%3A%2F%2Fwww.disit.org%2Fkm4city%2Fschema%23%3EPREFIX+rdf%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%3EPREFIX+rdfs%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2000%2F01%2Frdf-schema%23%3EPREFIX+rdfsn%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23%3EPREFIX+dct%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E";  
        // Sostituisci con l'endpoint SPARQL corretto            
        const query = `SELECT ?node_id as ?node ?where_id as ?from ?toward_id as ?to ?restriction WHERE {?r a km4c:TurnRestriction; km4c:node ?node; km4c:where ?where; km4c:toward ?toward; km4c:restriction ?restriction. ?node dct:identifier ?node_id. ?where dct:identifier ?where_id. ?toward dct:identifier ?toward_id. ?node geo:geometry ?p. FILTER ( bif:st_intersects ( bif:st_geomfromtext ('${polygonWKT}'), ?p ) ) }`; // LIMIT 100000`;
        return sparqlEndpoint + query;
    }

    // Function to fetch traffic sensor data
    /* async function fetchTrafficSensorData(sensorURL) {
        try {
            const response = await fetch(sensorURL);
            if (!response.ok) {
                throw new Error(`Error fetching sensor data: ${response.status}`);
            }
            const chesensorData = await response.json();
            const sensorFeatures = chesensorData.SensorSites.features;
            const sensorInfo = sensorFeatures.map(feature => ({
                serviceUri: feature.properties.serviceUri,
                coordinates: feature.geometry.coordinates,
                considerato: true
            }));
            datidaisensorichestoconsiderando = sensorInfo;
            datidaisensorichestoconsiderando.forEach(sensorInfo => {
                const ilSensore = new IlSensore(sensorInfo.serviceUri, sensorInfo.coordinates);
                istanzedeisensorichestoconsiderando.push(ilSensore);
                scenaryMarkers.addLayer(ilSensore.marker);
            });
        } catch (error) {
            console.error("Error fetching sensor data:", error);
        }
    } */

    async function fetchTrafficSensorData(sensorURL) {
        try {
            const response = await fetch(sensorURL);
            if (!response.ok) {
                throw new Error(`Error fetching sensor data: ${response.status}`);
            }
            const chesensorData = await response.json();
            const sensorFeatures = chesensorData.SensorSites.features;
            const sensorInfo = sensorFeatures.map(feature => ({
                serviceUri: feature.properties.serviceUri,
                coordinates: feature.geometry.coordinates,
                considerato: true,
                name: feature.properties.name
            }));
            datidaisensorichestoconsiderando = sensorInfo;
            datidaisensorichestoconsiderando.forEach(sensorInfo => {
                console.log('debug sensor',sensorInfo);
                const ilSensore = new IlSensore(sensorInfo.serviceUri, sensorInfo.coordinates, false, "",sensorInfo.name,"","","",sensorInfo.serviceUri);
                istanzedeisensorichestoconsiderando.push(ilSensore);
                scenaryMarkers.addLayer(ilSensore.marker);
            });
        } catch (error) {
            console.error("Error fetching sensor data:", error);
        }
    }


    // Function to fetch SPARQL data
    async function fetchSparqlDataSvolte(sparqlQuery) {
        try {
            const response = await fetch(sparqlQuery);
            if (!response.ok) {
                throw new Error(`Error fetching SPARQL data: ${response.status}`);
            } else {
                return response.json();
            }
        } catch (error) {
            console.error("Error fetching SPARQL data:", error);
        }
    }


    function isPointInsidePolygon(point, polygon) {
        const [x, y] = point;
        let isInside = false;
        let j = polygon.length - 1;

        for (let i = 0; i < polygon.length; i++) {
            if ((polygon[i][1] < y && polygon[j][1] >= y || polygon[j][1] < y && polygon[i][1] >= y) &&
                (polygon[i][0] <= x || polygon[j][0] <= x)) {
                if (polygon[i][0] + (y - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) * (polygon[j][0] - polygon[i][0]) < x) {
                    isInside = !isInside;
                }
            }
            j = i;
        }

        return isInside;
    }

    // Function to fetch SPARQL data
    //
    async function fetchSparqlData(sparqlQuery, svoltesparqlquery, wkt, existentRoadGraph = null, existentRessvolte = null, modality = 'create') {
        // //console.log('DATA:', sparqlQuery);
        // //console.log('existentRoadGraph:', existentRoadGraph);
        // //const allowedHighwayTypes = ["primary", "secondary", "residential","pedestrian", "tertiary", "residential", "unclassified"];
        // //
        // if (existentRessvolte) {
        //     ressvolte = existentRessvolte;
        // }
        // //var restrinctions_list = '';      
        // var restrinctions_list = ressvolte.then((result) => {
        //     let jsonString = JSON.stringify(result);
        //     restrinctions_list = jsonString;
        // }).catch((error) => {
        //     console.error(error);
        // });

        
        // //console.log(restrinctions_list); 
        // //
        // //const allowedHighwayTypes = ["primary", "tertiary", "residential", "unclassified"];              
        
        $('#road_types').prop('disabled', true);
        $('#view_mod').prop('disabled', true);
        $('#edit_lines').prop('disabled', true);
        
        try {
            if(modality == 'create'){

                restriction_data = [];
                saveLoadGraph = [];

                // get road graph from KB
                const response = await fetch(sparqlQuery);
                console.log('responsE', response);
                if (!response.ok) {
                    throw new Error(`Error fetching SPARQL data: ${response.status}`);
                }
                const data = await response.json();
                const stradeFeatures = data.results.bindings;

                // get restrictions
                const responseRes = await fetch(svoltesparqlquery);
                if (!responseRes.ok) {
                    throw new Error(`Error fetching SPARQL Restriction data: ${responseRes.status}`);
                } 
                const dataRes = await responseRes.json();
                restrinctions_list = JSON.stringify(dataRes);

                // setup road infos
                var stradeInfo = stradeFeatures.map(feature => (
                {
                    road: feature.strada.value,
                    segment: feature.elementostradale.value,
                    type: feature.highwaytype.value,
                    nALat: parseFloat(feature.startlat.value),
                    nALong: parseFloat(feature.startlong.value),
                    nBLat: parseFloat(feature.endlat.value),
                    nBLong: parseFloat(feature.endlong.value),
                    dir: feature.latrafficDir.value,
                    length: parseFloat(feature.lalunghezza.value),
                    nodeA: feature.startnode.value,
                    nodeB: feature.endnode.value,
                    lanes: feature.quante.value,
                    roadElmSpeedLimit: feature.roadElmSpeedLimit ? parseFloat(feature.roadElmSpeedLimit.value) : null,
                    elemType: feature.elementtype.value,
                    operatingstatus: feature.operatingstatus.value
                    //status: feature.status.value,
                }));

                // FILTRA strade su base WKT
                var stradeInfoClean = [];
                const arrayWKT = [];
                const tmp = wkt.split('((')[1].split('))')[0].split(', ');
                for (wi = 0; wi < tmp.length; wi++) {
                    arrayWKT.push(
                        [
                            parseFloat(tmp[wi].split(' ')[1]),
                            parseFloat(tmp[wi].split(' ')[0])
                        ]
                    );
                }
                for (si = 0; si < stradeInfo.length; si++) {
                    roadInfo = stradeInfo[si];
                    if (isPointInsidePolygon([roadInfo.nALat, roadInfo.nALong], arrayWKT) || isPointInsidePolygon([roadInfo.nBLat, roadInfo.nBLong], arrayWKT)) {
                        stradeInfoClean.push(roadInfo);
                    }
                }
                stradeInfo = stradeInfoClean;


                var array_restrinction = JSON.parse(restrinctions_list);
                restriction_data = array_restrinction.results.bindings;
                //console.log('stradeInfo: '+stradeInfo.length);
                //
                if (jsonStreetGraph == '') {
                    jsonStreetGraph = stradeInfo;
                }
                istanzedelgrafochestoconsiderando = [];
                var istanzeJson = $('#jsonIstanze').text();
                if ((istanzeJson !== "") && (istanzeJson !== undefined)) {
                    istanzeJson = JSON.parse(istanzeJson);
                    //console.log('jsonIstanze');
                    //console.log('CONSIDERA jsonIstanze');
                    jsonStreetGraph = istanzeJson;
                } else {
                    //istanzedelgrafochestoconsiderando = [];
                    jsonStreetGraph = stradeInfo;
                    //console.log('Non CONSIDERA jsonIstanze');
                }
                //
                //console.log('jsonStreetGraph:');
                //console.log(jsonStreetGraph);
                //
                //stradeInfo.forEach(strada => {
                var checkedValues = $('.checkRoadType:checked').map(function () {
                    return this.value;
                }).get();
                console.log('checkedValues in KB class', checkedValues);
                console.log('checkedValues Length in KB class', checkedValues.length);
                ///BOLOGNA -COLLINI -> CREAZIONE GRAFO STRADE
                jsonStreetGraph.forEach(strada => {
                    //AGGIORNAMENTO DEL JSON DEI ROAD GRAPH
                    //Controllo Sulle CheckedVlues
                    istanzedelgrafochestoconsiderando.push(strada);
                    //

                });
            }
            /// FINE BOLOGNA-COLLINI
            var currentStatusEdit = $('#currentStatusEdit').val();
            ///ADREANI
            // Convert JSON object to a string

            //Check on filters
            //roadElementGraph.filterTypes;
            ///////
            $('.leaflet-popup-content-wrapper').addClass('draggable');
            ///////
            if (!roadElementGraph) {
                console.log('roadElementGraph.filterTypes 0', checkedValues);
                //console.log('istanzedeisensorichestoconsiderando 0',istanzedeisensorichestoconsiderando);

                roadElementGraph = new KBRoadEditor(map.defaultMapRef, existentRoadGraph ? existentRoadGraph : istanzedelgrafochestoconsiderando, istanzedeisensorichestoconsiderando, restriction_data, (strada) => {
                    // segment. ci sono i dati
                    console.log('istanzedelgrafochestoconsiderando', istanzedelgrafochestoconsiderando);
                    // segment.line e la poliline da appenderre il popup
                    //var descrStrada = ('<div style="padding: 5%; width: 450px;"><input type="text" id="segment" value="'+strada.segment+'" style="display: none"/><textarea id="stradajson" style="display:none">'+strada+'</textarea><span><b>Category Street: </b></span>'+strada.type+'<br /><span><b>Nr.Lanes: </b>'+strada.lanes+'</span><br /><b>Speed Limit (km/h): </b></span>'+strada.roadElmSpeedLimit+'<br /><span><span><b>Direction: </b></span>'+strada.dir+'<br /><span><b>Restrictions: </b></span><br /><span></div>');
                    ////////POPUPS BOLOGNA

                    var segmentNameToShow = '';
                    if(strada.realSegment){
                        segmentNameToShow = strada.realSegment;
                    } else {
                        segmentNameToShow = strada.segment;
                    }

                    var jsonObject = {
                        road: strada.road,
                        segment: strada.segment,
                        type: strada.type,
                        nALat: strada.nALat,
                        nALong: strada.nALong,
                        nBLat: strada.nBLat,
                        nBLong: strada.nBLong,
                        dir: strada.dir,
                        length: strada.length,
                        nodeA: strada.nodeA,
                        nodeB: strada.nodeB,
                        lanes: strada.lanes,
                        roadElmSpeedLimit: strada.roadElmSpeedLimit,
                        elemType: strada.elemType,
                        operatingstatus: strada.operatingstatus,
                        turn: strada.turn
                    }

                    var strada_weight = '';
                    if(strada.weight){
                        strada_weight = strada.weight;
                    }
                    console.log('strada_weight: ',strada_weight);
                    console.log('strada.lanes;', strada.lanes);


                    var stradajson = JSON.stringify(jsonObject);
                    console.log(stradajson);

                    var parts = (strada.nodeB).split('/');
                    var nodeName = parts[parts.length - 1];
                    var restriction_span = '';
                    var status = strada.operatingstatus;
                    var toRestriction = '';
                    var fromRestriction = '';
                    var nodeRestriction = '';
                    //console.log(restriction_data);
                    var restriction_array = [];


                    //console.log('strada.restriction',strada.restriction);
                    //
                    var indices = [];
                    //
                    // if (!strada.restriction || strada.restriction.length == 0) {
                    // strada.restriction = [];
                    restriction_data.forEach((element, index) => {
                        const fromRE = 'http://www.disit.org/km4city/resource/' + element.from.value;
                        const toRE = 'http://www.disit.org/km4city/resource/' + element.to.value;
                        if(strada.segment == fromRE){ // pass if segmet is the "from" of a restriction
                            const nodeFounded = roadElementGraph.checkConnectionByID(toRE, strada.segment);
                            if (nodeFounded) {
                                indices.push(index);
                            }
                        }
                    });
                    //console.log('indices',indices);
                    if (indices.length > 0) {
                        indices.forEach((element, index) => {
                            restriction_span = restriction_data[element].restriction.value;
                            toRestriction = restriction_data[element].to.value;
                            nodeRestriction = restriction_data[element].node.value;
                            fromRestriction = restriction_data[element].from.value;
                            //color_dir = 'green';
                            //console.log(restriction_data[index]);
                            restriction_array.push(restriction_data[element]);
                            ///////////
                        });
                    } else {
                        restriction_span = 'Not defined';
                    }
                    // } else {
                    //     console.log('restriction', strada.restriction);
                    //     //
                    //     if (strada.restriction.length > 0) {
                    //         //console.log('Resctriction');
                    //         if (strada.restriction[0].to) {
                    //             //
                    //             let arraysegmentTo = (strada.restriction[0].to).split('/');
                    //             arraysegmentTo = arraysegmentTo[arraysegmentTo.length - 2] + '/' + arraysegmentTo[arraysegmentTo.length - 1];
                    //             //
                    //             toRestriction = arraysegmentTo;
                    //         }
                    //         if (strada.restriction[0].from) {
                    //             //
                    //             let arraysegmentFrom = (strada.restriction[0].from).split('/');
                    //             arraysegmentFrom = arraysegmentFrom[arraysegmentFrom.length - 2] + '/' + arraysegmentFrom[arraysegmentFrom.length - 1];
                    //             //
                    //             fromRestriction = arraysegmentFrom;
                    //         }
                    //         if (strada.restriction[0].node) {
                    //             //
                    //             let arraysegmentNode = (strada.restriction[0].node).split('/');
                    //             arraysegmentNode = arraysegmentNode[arraysegmentNode.length - 1];
                    //             //arraysegmentNode = arraysegmentNode[arraysegmentNode.length-2]+'/'+arraysegmentNode[arraysegmentNode.length-1];
                    //             //
                    //             nodeRestriction = arraysegmentNode;
                    //         }
                    //         if (strada.restriction[0].restriction) {
                    //             //console.log('restriction',strada.restriction[0].restriction);
                    //             restriction_span = strada.restriction[0].restriction;
                    //         }
                    //     }
                    //     //
                    // }


                    if (restriction_span !== 'Not defined') {
                        if (restriction_array.length > 0) {
                            //var restriction_json = JSON.stringify(restriction_array);
                            var selectedRestriction = restriction_array[0]; // [restriction_array.length - 1];
                            //console.log('selectedRestrition', selectedRestrition);

                            selectedRestriction = {
                                node: "http://www.disit.org/km4city/resource/" + selectedRestriction.node.value || selectedRestriction.node,
                                to: "http://www.disit.org/km4city/resource/" + selectedRestriction.to.value || selectedRestriction.to,
                                from: "http://www.disit.org/km4city/resource/" + selectedRestriction.from.value || selectedRestriction.from,
                            };
                            roadElementGraph.selectRestrictionColor(selectedRestriction);
                        }
                    }

                    ////////////
                    const prefix = "";
                    const graph2 = roadElementGraph.segments;
                    const types = roadElementGraph.filterTypes; // <= VERIFICA
                    const reID = strada.segment;
                    //console.log('reID:',reID);
                    console.log('types', types);
                    console.dir(graph2);
                    //console.log('types',types);
                    const posRestrictions_check = checkPossibleRestrictions(reID, graph2, prefix, types);
                    const posRestrictions = JSON.stringify(posRestrictions_check);
                    // console.log('posRestrictions',posRestrictions);
                    /*if (posRestrictions.length > 0){
                        for(var x=0; x<posRestrictions.length; x++){
                            console.log(posRestrictions[x].id);     
                        }
                     }*/
                    //////// 
                    ////////////////
                    //roadElementGraph.filterTypes = selectedRoadTypes;

                    //console.log(restriction_span);
                    if (status !== 'in esercizio') {
                        color_dir = '#FFFFFF';
                    }
                    //
                    //strada.restriction = restriction_span;
                    //
                    //console.log('restriction_span:'+restriction_span);
                    var dir = strada.dir;
                    if (strada.dir == 'tratto stradale aperto nella direzione positiva (da giunzione NOD_INI a giunzione NOD_FIN)') {
                        dir = 'Positive Direction';
                    } else if (strada.dir == 'tratto stradale aperto in entrambe le direzioni (default)') {
                        dir = 'Bidirection';
                    } else if (strada.dir == 'tratto stradale aperto nella direzione negativa (da giunzione NOD_FIN a giunzione NOD_INI)') {
                        dir = 'Negative Direction';
                    } else {
                        dir = 'Closed';
                    }
                    var segmentID= (strada.segment).split('/resource/')[1];
                    // collini probabilmente anche qui centra il giusto mettere l'opzione notOptimzabe ma va visto meglio... per ora lo lascio tanto il codice è replicato solo 6 volte...
                    // OK QUESTA IN VIEW HA MENO ENTRIES QUINDI PROB NON è QUELLA GIUSTA.. LA LASCIO LO STESSO PER ORA
                    //descrStrada = ('<div id="headerDraggable" >Road:' + segmentID + '</div><div id="segmentLabel_view" style="padding:5%;width:400px"><input type="text" id="segment" value="' + strada.segment + '" style="display:none"><textarea id="stradajson" style="display:none">' + stradajson + '</textarea><table><tbody><tr><td><b>Category Street:</b></td><td>' + strada.type + '</td></tr><tr><td><b>Nr.Lanes:</b></td><td>' + strada.lanes + '</td></tr><tr><td><b>Speed Limit (km/h):</b></td><td>' + strada.roadElmSpeedLimit + '</td></tr><tr><td><b>Weight:</b></td><td>' + strada_weight + '</td></tr><tr><td><b>Direction:</b></td><td>' + dir + '</td></tr><tr><td><b>Restrictions:</b></td><td>' + restriction_span + '</td></tr></tbody></table></div>');
            
                    
                    var width_popup = 450;
                    
                    if (roadElementGraph.mode !== 'view') { // POPUP CONSTRUCTION WHEN IN EDIT

                        var directions = '<select  id="updateDir" class="form-select" aria-label="Default select example" value="' + strada.dir + '"><option value="tratto stradale aperto nella direzione positiva (da giunzione NOD_INI a giunzione NOD_FIN)">Positive direction</option><option value="tratto stradale aperto in entrambe le direzioni (default)">Bidirection</option><option value="tratto stradale aperto nella direzione negativa (da giunzione NOD_FIN a giunzione NOD_INI)">Negative Direction</option><option value="tratto stradale chiuso in entrambe le direzioni">Closed</option></select>';
                        var categoryStreets = '<select id="updateType" value="' + strada.type + '" class="form-select" aria-label="Default select example"><option value="footway">footway</option><option value="primary">primary</option><option value="tertiary">tertiary</option><option value="residential">residential</option><option value="unclassified">unclassified</option></select>';
                        directions = directions.replace('<option value="' + strada.dir + '">', '<option value="' + strada.dir + '" selected>');
                        categoryStreets = categoryStreets.replace('<option value="' + strada.type + '">', '<option value="' + strada.type + '" selected>');

                        let arraysegment = (strada.segment).split('/');
                        let segmentId = arraysegment[arraysegment.length - 2] + '/' + arraysegment[arraysegment.length - 1];

                        var segmentID = '';
                        var baseURL = '';
                        if(segmentNameToShow == strada.segment){
                            segmentID= (strada.segment).split('/resource/')[1];
                            baseURL = (strada.segment).split(segmentID)[0];
                        } else {
                            segmentID= segmentNameToShow;
                            baseURL = "";
                        }
                        //EDITABLE//
                        descrStrada = `
                        <div id="headerDraggable">Road:</div>
                        <div id="segmentLabel_edit" style="padding: 5%; width: 400px;">   
                            <input type="text" id="segment" value="`+ strada.segment + `" style="display: none"/>
                            <textarea id="stradajson" style="display:none">'+stradajson+'</textarea>
                                <table>
                                    <tbody>
                                        <tr>
                                            <td><b>Baseurl: </b></td>
                                            <td>`+baseURL+ `</td>
                                        </tr>
                                        <tr>
                                            <td><b>SegmentID: </b></td>
                                            <td>` + segmentID + `</td>
                                        </tr>
                                        <tr>
                                        <td><b>Category Street: </b></td>
                                        <td>
                                            <select id="updateType" value="`+ strada.type + `" class="form-select" aria-label="Default select example">
                                                <option value="abandoned">abandoned</option>
                                                <option value="bridleway">bridleway</option>
                                                <option value="bus_guideway">bus_guideway</option>
                                                <option value="bus_stop">bus_stop</option>
                                                <option value="construction">construction</option>
                                                <option value="corridor">corridor</option>
                                                <option value="crossing">crossing</option>
                                                <option value="cycleway">cycleway</option>
                                                <option value="disused">disused</option>
                                                <option value="elevator">elevator</option>
                                                <option value="emergency_access_point">emergency_access_point</option>
                                                <option value="emergency_bay">emergency_bay</option>
                                                <option value="footway">footway</option>
                                                <option value="island">island</option>
                                                <option value="living_street">living_street</option>
                                                <option value="motorway">motorway</option>
                                                <option value="motorway_link">motorway_link</option>
                                                <option value="no">no</option>
                                                <option value="path">path</option>
                                                <option value="pedestrian">pedestrian</option>
                                                <option value="platform">platform</option>
                                                <option value="primary">primary</option>
                                                <option value="primary_link">primary_link</option>
                                                <option value="private">private</option>
                                                <option value="raceway">raceway</option>
                                                <option value="razed">razed</option>
                                                <option value="residential">residential</option>
                                                <option value="rest_area">rest_area</option>
                                                <option value="road">road</option>
                                                <option value="secondary_link">secondary_link</option>
                                                <option value="secondary">secondary</option>
                                                <option value="service">service</option>
                                                <option value="services">services</option>
                                                <option value="steps">steps</option>
                                                <option value="tertiary">tertiary</option>
                                                <option value="tertiary_link">tertiary_link</option>
                                                <option value="track">track</option>
                                                <option value="traffic_island">traffic_island</option>
                                                <option value="tram">tram</option>
                                                <option value="trunk_link">trunk_link</option>
                                                <option value="unclassified">unclassified</option>
                                                <option value="via_ferrata">via_ferrata</option>
                                                <option value="yes">yes</option>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><b>Nr.Lanes: </b></td>
                                        <td><input type="number" id="updateLanes" value="`+ strada.lanes + `" /></td>
                                    </tr>
                                    <tr>
                                        <td><b>Speed Limit (km/h): </b></td>
                                        <td><input type="number" id="updateSpeedLimit" value="`+ strada.roadElmSpeedLimit + `" /></td>
                                    </tr>
                                    <tr>
                                        <td><b>Weight:</b></td><!-- </td> -->
                                        <td><input type="number" id="update_strada_weight" value="`+ strada_weight + `" /></td>
                                        <!-- <td> -->
                                    </tr>
                                    <tr>
                                        <td><b>Direction:</b></td>
                                        <td>
                                            <select  id="updateDir" class="form-select" aria-label="Default select example" value="`+ strada.dir + `">
                                                <option value="tratto stradale aperto nella direzione positiva (da giunzione NOD_INI a giunzione NOD_FIN)">Positive direction</option>
                                                <option value="tratto stradale aperto in entrambe le direzioni (default)">Bidirection</option>
                                                <option value="tratto stradale aperto nella direzione negativa (da giunzione NOD_FIN a giunzione NOD_INI)">Negative Direction</option>
                                                <option value="tratto stradale chiuso in entrambe le direzioni">Closed</option>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><b>Restrictions:  </b></td>
                                        <td>
                                            <select id="updateRestriction" class="form-select" aria-label="Default select example">
                                                <option value="Select or create restriction" selected>Select or create restriction</option>
                                                <option value="Create new AccessRestriction">Create new AccessRestriction</option>
                                                <option value="Create new TurnRestriction">Create new TurnRestriction</option>
                                                <option value="Create new MaxMinRestriction">Create new MaxMinRestriction</option>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr class="restinction_data" style="display: none;">
                                        <td><b>Type:    </b></td>
                                        <td>
                                            <select id="restrictionType">
                                                <option class="turnRestriction" value="only_straight_on">only_straight_on</option>
                                                <option class="turnRestriction" value="no_left_turn">no_left_turn</option>
                                                <option class="turnRestriction" value="no_right_turn">no_right_turn</option>
                                                <option class="turnRestriction" value="only_right_turn">only_right_turn</option>
                                                <option class="turnRestriction" value="no_u_turn">no_u_turn</option>
                                                <option class="turnRestriction" value="only_left_turn">only_left_turn</option>
                                                <option class="turnRestriction" value="no_straight_on">no_straight_on</option>
                                                <option class="turnRestriction" value="no_entry">no_entry</option>
                                                <option class="accessRestriction" value="AccessRestriction">AccessRestriction</option>
                                                <option class="maxMinRestriction" value="MaxMinRestriction">MaxMinRestriction</option>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr class="restinction_data" style="display: none;">
                                        <td><b>From:</b></td>
                                        <td><input id="restrictionFrom" type="text" value="`+ segmentId + `" readonly/></td>
                                    </tr>
                                    <tr class="restinction_data" style="display: none;">
                                        <td><b>To:    </b></td>
                                        <td>
                                            <select id="restrictionTo">
                                                <option value="`+ toRestriction + `">` + toRestriction + `</option>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr class="restinction_data" style="display: none;">
                                        <td><b>Node:    </b></td class="restinction_data" style="display: none;">
                                        <td><input type="text" id="restrictionNode" value="`+ nodeRestriction + `" readonly/></td>
                                    </tr>
                                    <tr class="access_data" style="display: none;">
                                        <td><b>Direction:</b></td>
                                        <td>
                                            <select id="direction_access">
                                                <option value="forward">forward</option>
                                                <option value="backward">backward</option>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr class="access_data" style="display: none;">
                                        <td><b>Access:</b></td>
                                        <td>
                                            <select id="access_access">
                                                <option class="access_select" value="no">no</option>
                                                <option class="access_select" value="yes">yes</option>
                                                <option class="access_select" value="designated">designated</option> 
                                                <option class="access_select" value="use_sidepath">use_sidepath</option> 
                                                <option class="access_select" value="destination">destination</option> 
                                                <option class="access_select" value="private">private</option> 
                                                <option class="access_select" value="permissive">permissive</option> 
                                                <option class="access_select" value="dismount">dismount</option>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr class="access_data" style="display: none;">
                                        <td><b>Who:</b></td>
                                        <td>
                                            <select id="who_access">
                                                <option value="vehicle">vehicle</opton> 
                                                <option value="bicycle">bicycle</opton> 
                                                <option value="foot">foot</opton> 
                                                <option value="motor_vehicle">motor_vehicle</opton> 
                                                <option value="horse">horse</opton> 
                                                <option value="hgv">hgv</opton> 
                                                <option value="psv">psv</opton> 
                                                <option value="bus">bus</opton> 
                                                <option value="hazmat">hazmat</opton> 
                                                <option value="motorcar">motorcar</opton> 
                                                <option value="motorcycle">motorcycle</opton> 
                                                <option value="emergency">emergency</opton> 
                                                <option value="goods">goods</opton> 
                                                <option value="moped">moped</opton> 
                                                <option value="mofa">mofa</opton> 
                                                <option value="tourist_bus">tourist_bus</opton> 
                                                <option value="taxi">taxi</opton> 
                                                <option value="hov">hov</opton> 
                                                <option value="ski">ski</opton> 
                                                <option value="snowmobile">snowmobile</opton> 
                                                <option value="wheelchair">wheelchair</opton>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr class="maxMinRestriction" style="display: none;">
                                        <td><b>What:</b></td>
                                        <td>
                                            <select id="what_minmax">
                                                <option value="maxspeed">maxspeed</option>
                                                <option value="maxweight">maxweight</option>
                                                <option value="maxheight">maxheight</option>
                                                <option value="maxlength">maxlength</option>
                                                <option value="maxwidth">maxwidth</option>
                                                <option value="minspeed">minspeed</option>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr class="maxMinRestriction" style="display: none;">
                                        <td><b>Limit:<b/></td>
                                        <td><input type="number" id="limit_minmax" value="" /></td><!-- </td> -->
                                    </tr>
                                    <tr>
                                        <td><input type="button" id="deleteRestriction" value="Delete resctriction" style="display: none;"/></td>
                                    </tr>
                                    <tr>
                                        <td><b>Not Optimizable: </b></td>
                                        <td>
                                            <input type="checkbox" id="updateNotOptimizable" value="true" ` + (strada.notOptimizable ? 'checked' : '') + ` />
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                            <input type="button" id="updateStreet" value="Update" />
                        </div>`;

                        descrStrada = descrStrada.replace('<option value="' + strada.type + '">' + strada.type + '</option>', '<option value="' + strada.type + '" selected>' + strada.type + '</option>');
                        descrStrada = descrStrada.replace('<option value="' + strada.dir + '">', '<option value="' + strada.dir + '" selected>');
                        
                        //CHECK SUL restriction_span;
                        if (restriction_span != 'Not defined') {
                            //CHANGE DATA

                            console.log(restriction_span);
                            console.log('strada', strada.restriction);
                            if (restriction_span == 'AccessRestriction') {
                                //
                                var who_access = '';
                                var direction_access = '';
                                var access_access = '';
                                //
                                if ((strada.restriction).length > 0) {
                                    var rs = strada.restriction;
                                    for (var i = 0; i < rs.length; i++) {
                                        var rt = rs[i].restriction;
                                        //what_minmax = rs[i].what;            
                                        //limit_minmax = rs[i].limit;
                                        who_access = rs[i].who;
                                        direction_access = rs[i].direction;
                                        access_access = rs[i].access;
                                    }
                                }

                                console.log('who_access:', who_access);
                                console.log('direction_access:', direction_access);
                                console.log('access_access:', access_access);
                                //
                                descrStrada = descrStrada.replace('Select or create restriction</option>', 'Select or create restriction</option><option value="' + restriction_span + '" selected>' + restriction_span + '</option>');
                                //
                                //direction_access
                                descrStrada = descrStrada.replaceAll('<tr class="access_data" style="display: none;">', '<tr class="access_data">');
                                //descrStrada = descrStrada.replace('<select id="who_access">','<select id="who_access" value="'+who_access+'" selected>');
                                //descrStrada = descrStrada.replace('<select id="access_access">','<select id="access_access" value="'+access_access+'" selected>');
                                //descrStrada = descrStrada.replace('<select id="direction_access">','<select id="direction_access" value="'+direction_access+'">');
                                //
                                descrStrada = descrStrada.replace('<option class="access_select" value="' + access_access + '">', '<option class="access_select" value="' + access_access + '" selected>');
                                descrStrada = descrStrada.replace('<option value="' + who_access + '">', '<option value="' + who_access + '" selected>');
                                descrStrada = descrStrada.replace('<option value="' + direction_access + '">', '<option value="' + direction_access + '" selected>');
                                descrStrada = descrStrada.replace('<input type="button" id="deleteRestriction" value="Delete resctriction" style="display: none;"/>', '<input type="button" id="deleteRestriction" value="Delete resctriction" />');
                                //                                             
                            } else if (restriction_span == 'MaxMinRestriction') {
                                descrStrada = descrStrada.replace('Select or create restriction</option>', 'Select or create restriction</option><option value="' + restriction_span + '" selected>' + restriction_span + '</option>');
                                descrStrada = descrStrada.replaceAll('<tr class="maxMinRestriction" style="display: none;">', '<tr class="maxMinRestriction">');
                                //
                                var what_minmax = '';
                                var limit_minmax = '';
                                //
                                if ((strada.restriction).length > 0) {
                                    var rs = strada.restriction;
                                    for (var i = 0; i < rs.length; i++) {
                                        var rt = rs[i].restriction;
                                        what_minmax = rs[i].what;
                                        limit_minmax = rs[i].limit;
                                    }
                                }
                                console.log('what_minmax:', what_minmax);
                                console.log('limit_minmax:', limit_minmax);
                                //
                                descrStrada = descrStrada.replaceAll('<option value="' + what_minmax + '">' + what_minmax + '</option>', '<option value="' + what_minmax + '" selected>' + what_minmax + '</option>');
                                descrStrada = descrStrada.replaceAll('<input type="number" id="limit_minmax" value=""', '<input type="number" id="limit_minmax" value="' + limit_minmax + '"');
                                descrStrada = descrStrada.replace('<input type="button" id="deleteRestriction" value="Delete resctriction" style="display: none;"/>', '<input type="button" id="deleteRestriction" value="Delete resctriction" />');
                                //
                            } else {
                                //ADD VALUES//
                                /**/
                                // console.log('restriction_data', strada.restriction);
                                // if ((strada.restriction).length > 0) {
                                //     var rs = strada.restriction;
                                //     for (var i = 0; i < rs.length; i++) {
                                //         var rt = rs[i].restriction;
                                //         console.log(rt);
                                //         console.log('1) restriction_span:', restriction_span);
                                //         descrStrada = descrStrada.replace('Select or create restriction</option>', 'Select or create restriction</option><option value="' + rt + '" selected>TurnRestriction-' + rt + '</option>');
                                //         descrStrada = descrStrada.replaceAll('<tr class="restinction_data" style="display: none;">', '<tr class="restinction_data">');
                                //         descrStrada = descrStrada.replace('id="restrictionType"', 'id="restrictionType" value="' + rt + '" disabled');
                                //         descrStrada = descrStrada.replace('<option class="turnRestriction" value="' + rt + '">' + rt + '</option>', '<option class="turnRestriction" value="' + rt + '" selected>' + rt + '</option>');

                                //     }
                                //     //descrStrada = descrStrada.replace('id="restrictionType" value="'+rt+'" disabled', 'id="restrictionType" value="'+restriction_span+'" disabled');
                                //     roadElementGraph.selectRestrictionColor(rs[0]);
                                //     descrStrada = descrStrada.replace('<input type="button" id="deleteRestriction" value="Delete resctriction" style="display: none;"/>', '<input type="button" id="deleteRestriction" value="Delete resctriction" />');
                                // }

                                if (indices.length > 0) {
                                    indices.forEach((element, index) => {
                                        restriction_span = restriction_data[element].restriction.value;
                                        //toRestriction = restriction_data[index].to.value;
                                        //nodeRestriction = restriction_data[index].node.value;
                                        //fromRestriction =restriction_data[index].from.value;

                                        // show turn restriction panel
                                        descrStrada = descrStrada.replaceAll('<tr class="restinction_data" style="display: none;">', '<tr class="restinction_data">');
                                        if(index == 0){
                                            descrStrada = descrStrada.replace('Select or create restriction</option>', 'Select or create restriction</option><option value="' + restriction_span + '" selected>TurnRestriction-' + restriction_span + '</option>');
                                            descrStrada = descrStrada.replace('id="restrictionType"', 'id="restrictionType" value="' + restriction_span + '" disabled');
                                            descrStrada = descrStrada.replace('<option class="turnRestriction" value="' + restriction_span + '">' + restriction_span + '</option>', '<option class="turnRestriction" value="' + restriction_span + '" selected>' + restriction_span + '</option>');
                                        } else {
                                            descrStrada = descrStrada.replace('Select or create restriction</option>', 'Select or create restriction</option><option value="' + restriction_span + '">TurnRestriction-' + restriction_span + '</option>');
                                        }
                                        
                                        //restriction_array.push(restriction_data[index]);
                                    });
                                    descrStrada = descrStrada.replace('<input type="button" id="deleteRestriction" value="Delete resctriction" style="display: none;"/>', '<input type="button" id="deleteRestriction" value="Delete resctriction" />');
                                }
                                /* 
                                descrStrada = descrStrada.replace('Select or create restriction</option>','Select or create restriction</option><option value="'+restriction_span+'" selected>TurnRestriction-'+restriction_span+'</option>'); 
                                                  descrStrada = descrStrada.replaceAll('<tr class="restinction_data" style="display: none;">','<tr class="restinction_data">');
                                                 descrStrada = descrStrada.replace('id="restrictionType"', 'id="restrictionType" value="'+restriction_span+'"');
                                                  descrStrada = descrStrada.replace('<option class="turnRestriction" value="'+restriction_span+'">'+restriction_span+'</option>','<option class="turnRestriction" value="'+restriction_span+'" selected>'+restriction_span+'</option>');
                                */
                                ///////////       

                            }

                        }
                        
                        if(strada.errors && strada.errors.length >0){
                            var errorField = '<td style="color:#FF0000">';
                            for(let i = 0; i < strada.errors.length; i++){
                                if(i>0){
                                    errorField = errorField + '</br>';
                                }
                                errorField = errorField + strada.errors[i];                                
                            }
                            errorField = errorField + '</td>';
                            descrStrada = descrStrada.replace('</tbody>', '<tr><td><b style="color:#FF0000">Errors</b></td>'+ errorField +'</tr></tbody>');
                        }
                         
                        //EDITABLE 
                        
                        width_popup = 450;

                    } else { // POPUP CONSTRUCTION WHEN IN VIEW, i.e. NOT (roadElementGraph.mode !== 'view') 

                        var dir = strada.dir;
                        if (strada.dir == 'tratto stradale aperto nella direzione positiva (da giunzione NOD_INI a giunzione NOD_FIN)') {
                            dir = 'Positive Direction';
                        } else if (strada.dir == 'tratto stradale aperto in entrambe le direzioni (default)') {
                            dir = 'Bidirection';
                        } else if (strada.dir == 'tratto stradale aperto nella direzione negativa (da giunzione NOD_FIN a giunzione NOD_INI)') {
                            dir = 'Negative Direction';
                        } else {
                            dir = 'Closed';
                        }
                        width_popup = 400;
                        ////
                        //console.log('restriction_data', strada.restriction);
                        //var indices = strada.restriction;
                        // if (indices.length > 0) {
                        //     indices.forEach((element, index) => {
                        //         restriction_span = element.restriction;
                        //         //
                        //         console.log(element);
                        //         //toRestriction = element.to;
                        //         if (element.to) {
                        //             toRestriction = (element.to).split('/');
                        //             toRestriction = toRestriction[toRestriction.length - 2] + '/' + toRestriction[toRestriction.length - 1];
                        //         }
                        //         //
                        //         //nodeRestriction = element.node;
                        //         if (element.node) {
                        //             nodeRestriction = (element.node).split('/');
                        //             nodeRestriction = nodeRestriction[nodeRestriction.length - 1];
                        //         }
                        //         //
                        //         if (element.from) {
                        //             fromRestriction = (element.from).split('/');
                        //             fromRestriction = fromRestriction[fromRestriction.length - 2] + '/' + fromRestriction[fromRestriction.length - 1];
                        //         }
                        //         //color_dir = 'green';
                        //         //console.log(restriction_data[index]);
                        //         restriction_array.push(element);
                        //         ///////////
                        //     });
                        // }
                        console.log('restriction_array:', restriction_array);

                        var restriction_data_details = '';
                        var segmentID = '';
                        var baseURL = '';
                        if(segmentNameToShow == strada.segment){
                            segmentID= (strada.segment).split('/resource/')[1];
                            baseURL = (strada.segment).split(segmentID)[0];
                        } else {
                            segmentID= segmentNameToShow;
                            baseURL = "";
                        }
                        //descrStrada = ('<div style="padding: 5%; width: 450px;"><input type="text" id="segment" value="'+strada.segment+'" style="display: none"/><textarea id="stradajson" style="display:none">'+stradajson+'</textarea><span><b>Category Street: </b></span>'+strada.type+'<br /><span><b>Nr.Lanes: </b>'+strada.lanes+'</span><br /><b>Speed Limit (km/h): </b></span>'+strada.roadElmSpeedLimit+'<br /><span><span><b>Direction: </b></span>'+dir+'<br /><span><b>Restrictions: </b></span>'+restriction_span+'<br /><span></div>');
                        // collini questa era quella precedente alla modifica per le strade notOptiimizable -> descrStrada = ('<div id="headerDraggable">Road: </div><div id="segmentLabel_view" style="padding:5%;width:400px"><input type="text" id="segment" value="' + strada.segment + '" style="display:none"><textarea id="stradajson" style="display:none">' + stradajson + '</textarea><table><tbody><tr><td><b>BaseUrl:</b></td><td>'+baseURL+'</td></tr><tr><td><b>SegmentID: </b></td><td>' + segmentID + '</td></tr><tr><td><b>Category Street:</b></td><td>' + strada.type + '</td></tr><tr><td><b>Nr.Lanes:</b></td><td>' + strada.lanes + '</td></tr><tr><td><b>Speed Limit (km/h):</b></td><td>' + strada.roadElmSpeedLimit + '</td></tr><tr><td><b>Weight:</b></td><td>' + strada_weight + '</td></tr><tr><td><b>Direction:</b></td><td>' + dir + '</td></tr><tr><td><b>Restrictions:</b></td><td>' + restriction_span + '</td></tr></tbody></table></div>');
                        descrStrada = ('<div id="headerDraggable">Road: </div><div id="segmentLabel_view" style="padding:5%;width:400px"><input type="text" id="segment" value="' + strada.segment + '" style="display:none"><textarea id="stradajson" style="display:none">' + stradajson + '</textarea><table><tbody><tr><td><b>BaseUrl:</b></td><td>'+baseURL+'</td></tr><tr><td><b>SegmentID: </b></td><td>' + segmentID + '</td></tr><tr><td><b>Category Street:</b></td><td>' + strada.type + '</td></tr><tr><td><b>Nr.Lanes:</b></td><td>' + strada.lanes + '</td></tr><tr><td><b>Speed Limit (km/h):</b></td><td>' + strada.roadElmSpeedLimit + '</td></tr><tr><td><b>Weight:</b></td><td>' + strada_weight + '</td></tr><tr><td><b>Direction:</b></td><td>' + dir + '</td></tr><tr><td><b>Restrictions:</b></td><td>' + restriction_span + '</td></tr>'+ '<tr><td><b>Not Optimizable:</b></td><td>' + strada.notOptimizable + '</td></tr>'+ '</tbody></table></div>');

                        
                       

                        if (restriction_span !== 'Not defined') {
                            var string_restriciton = '';
                            var accessRestriction = '';
                            var directionRestriction = '';
                            var whoRestriction = '';
                            var limitRestriction = '';
                            var whatRestriction = '';
                            if (restriction_array.length > 0) {
                                for (var u = 0; u < restriction_array.length; u++) {
                                    if (restriction_array[u].to) {
                                        toRestriction = '<tr><td><b style="margin-left: 1em;">To:</b></td><td>' + restriction_array[u].to.value + '</td></tr>';
                                    }
                                    if (restriction_array[u].node) {
                                        nodeRestriction = '<tr><td><b style="margin-left: 1em;">Node:</b></td><td>' + restriction_array[u].node.value + '</td></tr>';
                                    }
                                    if (restriction_array[u].from) {
                                        fromRestriction = '<tr><td><b style="margin-left: 1em;">From:</b></td><td>' + restriction_array[u].from.value + '</td></tr>';
                                    }
                                    // if (restriction_array[u].access) {
                                    //     accessRestriction = (restriction_array[u].access);
                                    //     accessRestriction = '<tr><td><b>Access:</b></td><td>' + accessRestriction + '</td></tr>';
                                    // }
                                    // if (restriction_array[u].direction) {
                                    //     directionRestriction = (restriction_array[u].direction);
                                    //     directionRestriction = '<tr><td><b>Direction:</b></td><td>' + directionRestriction + '</td></tr>';
                                    // }
                                    // if (restriction_array[u].who) {
                                    //     whoRestriction = (restriction_array[u].who);
                                    //     whoRestriction = '<tr><td><b>Who:</b></td><td>' + whoRestriction + '</td></tr>';
                                    // }
                                    // if (restriction_array[u].what) {
                                    //     whatRestriction = (restriction_array[u].what);
                                    //     whatRestriction = '<tr><td><b>What:</b></td><td>' + whatRestriction + '</td></tr>';
                                    // }
                                    // if (restriction_array[u].limit) {
                                    //     limitRestriction = (restriction_array[u].limit);
                                    //     limitRestriction = '<tr><td><b>Limit:</b></td><td>' + limitRestriction + '</td></tr>';
                                    // }
                                    string_restriciton = string_restriciton + '<tr><td><b>Restriction:</b></td><td>' + restriction_array[u].restriction.value + '</td>' + fromRestriction + toRestriction + nodeRestriction + accessRestriction + directionRestriction + whoRestriction + limitRestriction + whatRestriction;
                                }
                            }
                            descrStrada = descrStrada.replace('<tr><td><b>Restrictions:</b></td><td>' + restriction_span + '</td></tr></tbody></table>', string_restriciton + '</tbody></table>');
                        }

                        if(strada.errors && strada.errors.length >0){
                            var errorField = '<td style="color:#FF0000">';
                            for(let i = 0; i < strada.errors.length; i++){
                                if(i>0){
                                    errorField = errorField + '</br>';
                                }
                                errorField = errorField + strada.errors[i];                                
                            }
                            errorField = errorField + '</td>';
                            descrStrada = descrStrada.replace('</tbody>', '<tr><td><b style="color:#FF0000">Errors</b></td>'+ errorField +'</tr></tbody>');
                        }
                    } // END POPUP CONSTRUCTION (BOTH IN EDIT AND IN VIEW)

                    strada.line.bindPopup(descrStrada, { maxWidth: width_popup });
                    strada.line.openPopup();

                    //headerDraggable
                    dragPopup(document.getElementById('headerDraggable').parentElement.parentElement.parentElement, document.getElementById('headerDraggable'));
                    
                    strada.line.on('popupclose', () => {
                        if(strada.line.getPopup().isOpen()){
                            if(roadElementGraph.selectedRestriction.hasOwnProperty('to')){    
                                const tmpTo = roadElementGraph.selectedRestriction.to;
                                const tmpFrom = roadElementGraph.selectedRestriction.from;
                                // reset segment color
                                roadElementGraph.segments[tmpTo].arrow.setStyle({
                                    color: roadElementGraph.typeColors['default'].color,
                                    fillColor: roadElementGraph.typeColors['default'].color
                                });

                                roadElementGraph.segments[tmpTo].line.setStyle({
                                    color: roadElementGraph.typeColors['default'].color
                                });

                                roadElementGraph.segments[tmpFrom].arrow.setStyle({
                                    color: roadElementGraph.typeColors['default'].color,
                                    fillColor: roadElementGraph.typeColors['default'].color
                                });

                                roadElementGraph.segments[tmpFrom].line.setStyle({
                                    color: roadElementGraph.typeColors['default'].color
                                });

                                roadElementGraph.selectedRestriction = {};
                                
                                //TODO: handle mouseover/mouseout on segment to reset the color in the drawsegment function.
                                //      calling draw solve this issue, but sometimes leave pending copy of the segment not
                                //      removed after clean 
                                // strada.line.off('popupclose');
                                // roadElementGraph.draw();                            
                                // strada.line.on('popupclose');
                            } 
                            // roadElementGraph.clearSegments();
                            // roadElementGraph.clearNodes();
                            // roadElementGraph.draw();
                            console.log('popup chiuso');
                        }
                    });

                    $('#deleteRestriction').click(() => {
                        var restrictionKind = $('#updateRestriction').val();

                        if(restrictionKind === "AccessRestriction"){
                            // TODO 
                        } else if(restrictionKind === "MaxMinRestriction") {
                            // TODO
                        } else { // go in TurnRestriction case
                            var restrictionFrom = $('#restrictionFrom').val();
                            var restrictionTo = $('#restrictionTo').val();
                            var restrictionNode = $('#restrictionNode').val();
                            var index = -1; // Inizializza l'indice a -1 per indicare che non è stato trovato nessun elemento

                            for(let i = 0; i<restriction_data.length; i++){
                                console.log(restriction_data[i]);
                                if( 
                                    restriction_data[i].from.value === restrictionFrom &&
                                    restriction_data[i].to.value === restrictionTo &&
                                    restriction_data[i].node.value === restrictionNode
                                ){
                                    index = i;
                                    break;
                                }
                            }

                            if(index != -1){
                                //strada.line.closePopup(); //fireEvent('popupclose');
                                const tmpID = "http://www.disit.org/km4city/resource/" + restrictionFrom;
                                restriction_data.splice(index, 1);
                                //$('#updateRestriction').val('Select or create restriction').trigger('change');
                                //roadElementGraph.clearSegments();
                                //roadElementGraph.clearNodes();
                                //roadElementGraph.draw();
                                // roadElementGraph.segments[tmpID].line.openPopup();
                                //$('#updateRestriction').val('Select or create restriction').trigger('change');
                                // roadElementGraph.segments[tmpID].line.fire('click');
                                // strada.line.fireEvent('click');
                            } else {
                                console.error("[Error] Restriction to be deleted not found.");
                            }
                        }               
                        
                        roadElementGraph.draw();

                        // // Loop attraverso l'array per cercare l'elemento con "from" uguale al valore desiderato
                        // var data = strada.restriction;
                        // for (var i = 0; i < data.length; i++) {
                        //     if (data[i].from !== undefined) {
                        //         if (data[i].from === restrictionFrom) {
                        //             index = i; // Memorizza l'indice dell'elemento trovato
                        //             break; // Esci dal ciclo una volta trovato l'elemento
                        //         }



                        //     } else if (data[i].restriction === 'MaxMinRestriction') {
                        //         index = i; // Memorizza l'indice dell'elemento trovato
                        //         break; // Esci dal ciclo una volta trovato l'elemento
                        //     }
                        //     else if (data[i].restriction === 'AccessRestriction') {
                        //         index = i; // Memorizza l'indice dell'elemento trovato
                        //         break; // Esci dal ciclo una volta trovato l'elemento
                        //     }
                        //     else {
                        //         //do nothing
                        //     }
                        // }
                        // if (index !== -1) {
                        //     // Se l'elemento è stato trovato, rimuovilo dall'array
                        //     data.splice(index, 1);
                        //     console.log("Elemento rimosso dall'array.");
                        //     console.log('data', data);
                        // } else {
                        //     console.log("Elemento non trovato nell'array.");
                        // }

                        // console.log('strada.restriction: ', strada.restriction);
                        // console.log('restrictionFrom: ', restrictionFrom);
                        // console.log('index: ', index);
                    });

                    $('#updateRestriction').on('change', () => {
                        console.log('posRestrictions 0', posRestrictions);
                        //console.log('restriction_json', restriction_json);
                        /////////////
                        var restrictions = $('#updateRestriction').val();
                        var restrictions_text = $('#restrictionType').text();
                        $('#restrictionType').val(restrictions);
                        //////
                        if ((restrictions != ('Create new AccessRestriction')) && (restrictions != ('Create new MaxMinRestriction')) && (restrictions != ('Select or create restriction'))) {
                            if( restrictions == 'Create new TurnRestriction'){
                                $('.restinction_data').css('display', '');
                                $(".turnRestriction").css('display', '');
                                $(".maxMinRestriction").css('display', 'none');
                                $(".accessRestriction").css('display', 'none');
                                $(".access_data").css('display', 'none');
                                $("#deleteRestriction").css('display', 'none');

                                $('#restrictionType').empty();
                                json_posRestrictions = JSON.parse(posRestrictions)
                                if (json_posRestrictions.length > 0) {
                                    //console.log('restriction_json',restriction_json);
                                    $('#restrictionTo').empty();
                                    for (var x = 0; x < json_posRestrictions.length; x++) {
                                        console.log(json_posRestrictions[x].id);
                                        console.log(json_posRestrictions[x].turn);

                                        var id_to = json_posRestrictions[x].id;
                                        var spitid = id_to.split('/');
                                        var r = spitid.length;
                                        var restrictionTo = spitid[r - 2] + '/' + spitid[r - 1];

                                        var id_node = json_posRestrictions[x].node;
                                        var spitidn = id_node.split('/');
                                        var r = spitidn.length;
                                        var restrictionNode = spitidn[r - 2] + '/' + spitidn[r - 1];

                                        console.log(spitid);
                                        // $('#restrictionTo').append('<option value="' + posRestrictions[x].id + '" order="' + x + '">' + restrictionTo + '</option>');
                                        $('#restrictionTo').append('<option value="' + restrictionTo + '" order="' + x + '">' + restrictionTo + '</option>');

                                        //$(".turnRestriction").css('display', 'none');
                                        //$('#restrictionType').val(json_posRestrictions[x].turn[0]);
                                        var restrictionType = null;
                                        if (x==0){
                                            for (var u = 0; u < json_posRestrictions[x].turn.length; u++) {
                                                var type = json_posRestrictions[x].turn[u];
                                                $('#restrictionType').append('<option class="turnRestriction" value="' + type + '" order="' + u + '">' + type + '</option>');
                                                // $(".turnRestriction[value='" + type + "']").css('display', '');
                                                // if(x==0 && u==0){
                                                //     restrictionType = type;
                                                // }
                                                //$('#restrictionType').val(type);
                                                console.log(type);
                                            }
                                            $('#restrictionType').trigger('change'); 
                                        }


                                        $('#restrictionNode').val(restrictionNode);



                                    }
                                }
                                $('#restrictionTo').trigger('change');
                            } else { // show a different turn restriction

                                // reset segment colors of the previously shown restriction
                                if(roadElementGraph.selectedRestriction.hasOwnProperty('to')){    
                                    const tmpTo = roadElementGraph.selectedRestriction.to;
                                    const tmpFrom = roadElementGraph.selectedRestriction.from;
                                    // reset segment color
                                    roadElementGraph.segments[tmpTo].arrow.setStyle({
                                        color: roadElementGraph.typeColors['default'].color,
                                        fillColor: roadElementGraph.typeColors['default'].color
                                    });

                                    roadElementGraph.segments[tmpTo].line.setStyle({
                                        color: roadElementGraph.typeColors['default'].color
                                    });

                                    roadElementGraph.segments[tmpFrom].arrow.setStyle({
                                        color: roadElementGraph.typeColors['default'].color,
                                        fillColor: roadElementGraph.typeColors['default'].color
                                    });

                                    roadElementGraph.segments[tmpFrom].line.setStyle({
                                        color: roadElementGraph.typeColors['default'].color
                                    });

                                    roadElementGraph.selectedRestriction = {};
                                }

                                // search for the restriction to show
                                var restrictionFrom = document.getElementById('restrictionFrom').value;
                                var restrictionType = restrictions;

                                var restrictionTo = '';
                                var restrictionNode = '';
                                for(let i=0; i<restriction_data.length; i++){
                                    if(
                                        restrictionFrom == restriction_data[i].from.value &&
                                        restrictionType == restriction_data[i].restriction.value
                                    ){
                                        restrictionTo = restriction_data[i].to.value;
                                        restrictionNode = restriction_data[i].node.value;
                                    }
                                }

                                selectedRestriction = {
                                    node: "http://www.disit.org/km4city/resource/" + restrictionNode,
                                    to: "http://www.disit.org/km4city/resource/" + restrictionTo,
                                    from: "http://www.disit.org/km4city/resource/" + restrictionFrom,
                                };

                                // color the segment of the found restriction
                                roadElementGraph.segments[selectedRestriction.to].arrow.setStyle({
                                    color: roadElementGraph.typeColors['restrictionTo'].color,
                                    fillColor: roadElementGraph.typeColors['restrictionTo'].color
                                });

                                roadElementGraph.segments[selectedRestriction.to].line.setStyle({
                                    color: roadElementGraph.typeColors['restrictionTo'].color
                                });

                                roadElementGraph.segments[selectedRestriction.from].arrow.setStyle({
                                    color: roadElementGraph.typeColors['restrictionFrom'].color,
                                    fillColor: roadElementGraph.typeColors['restrictionFrom'].color
                                });

                                roadElementGraph.segments[selectedRestriction.from].line.setStyle({
                                    color: roadElementGraph.typeColors['restrictionFrom'].color
                                });

                                roadElementGraph.selectedRestriction = selectedRestriction;

                                roadElementGraph.segments[roadElementGraph.selectedRestriction.to].line.bringToFront();
                                roadElementGraph.segments[roadElementGraph.selectedRestriction.from].line.bringToFront();
                                roadElementGraph.segments[roadElementGraph.selectedRestriction.to].arrow.bringToFront();
                                roadElementGraph.segments[roadElementGraph.selectedRestriction.from].arrow.bringToFront();

                                roadElementGraph.nodes[roadElementGraph.segments[roadElementGraph.selectedRestriction.to].nodeA].circle.bringToFront();
                                roadElementGraph.nodes[roadElementGraph.segments[roadElementGraph.selectedRestriction.to].nodeB].circle.bringToFront();
                                roadElementGraph.nodes[roadElementGraph.segments[roadElementGraph.selectedRestriction.from].nodeA].circle.bringToFront();
                                roadElementGraph.nodes[roadElementGraph.segments[roadElementGraph.selectedRestriction.from].nodeB].circle.bringToFront();

                                // set values in the panel form
                                $('#restrictionTo').empty();
                                $('#restrictionType').empty();

                                $('#restrictionNode').val(restrictionNode);
                                $('#restrictionTo').append('<option value="' + restrictionTo + '" order="' + x + '">' + restrictionTo + '</option>');
                                $('#restrictionType').append('<option class="turnRestriction" value="' + restrictionType + '" order="' + u + '">' + restrictionType + '</option>');
                            }
                            //
                        } else if (restrictions == 'Create new AccessRestriction') {
                            $('.restinction_data').css('display', 'none');
                            $(".turnRestriction").css('display', 'none');
                            $(".maxMinRestriction").css('display', 'none');
                            $(".accessRestriction").css('display', '');
                            $(".access_data").css('display', '');
                            $("#deleteRestriction").css('display', 'none');
                        } else if (restrictions == 'Create new MaxMinRestriction') {
                            $('.restinction_data').css('display', 'none');
                            $(".turnRestriction").css('display', 'none');
                            $(".maxMinRestriction").css('display', '');
                            $(".accessRestriction").css('display', 'none');
                            $(".access_data").css('display', 'none');
                            $("#deleteRestriction").css('display', 'none');
                        } else if (restrictions == 'Select or create restriction') {
                            $('.restinction_data').css('display', 'none');
                            $(".turnRestriction").css('display', 'none');
                            $(".maxMinRestriction").css('display', 'none');

                            $(".accessRestriction").css('display', 'none');
                            $(".access_data").css('display', 'none');
                            //
                            $('#restrictionFrom').val('');
                            $('#restrictionTo').val('');
                            $('#restrictionNode').val('');
                            $('#restrictionType').val('');
                            $("#deleteRestriction").css('display', 'none');
                            //
                        } else if (restrictions == 'AccessRestriction') {
                            $('.restinction_data').css('display', 'none');
                            $(".turnRestriction").css('display', 'none');
                            $(".maxMinRestriction").css('display', 'none');
                            $(".accessRestriction").css('display', 'none');
                            $(".access_data").css('display', '');
                            $("#deleteRestriction").css('display', 'none');
                        } else {
                            $('.restinction_data').css('display', 'none');
                            $(".turnRestriction").css('display', 'none');
                            $(".maxMinRestriction").css('display', 'none');
                            $(".accessRestriction").css('display', 'none');
                            $(".access_data").css('display', 'none');
                            //
                            $('#restrictionFrom').val('');
                            $('#restrictionTo').val('');
                            $('#restrictionNode').val('');
                            $('#restrictionType').val('');
                            $("#deleteRestriction").css('display', '');
                            //
                        }
                        //////
                    });

                    $('#updateStreet').click(() => {
                        console.log('Click on updateStreet');
                        strada.type = $('#updateType').val();
                        strada.lanes = $('#updateLanes').val();
                        strada.roadElmSpeedLimit = $('#updateSpeedLimit').val();
                        strada.dir = $('#updateDir').val();
                        // collini aggiungo notOptimizable
                        strada.notOptimizable = $('#updateNotOptimizable').prop('checked');                        
                        // roadElementGraph.draw();
                        
                        
                        //segmentSelected = $('#restrictionFrom').val();
                        //RESTRICTIONS////
                        //var restrictionType = $('#restrictionType').val();
                        var restrictionTypeText = $('#updateRestriction').val();
                        //
                        //CHECK update_strada_weight
                        var update_strada_weight = document.getElementById('update_strada_weight');
                        if(update_strada_weight){
                               strada.weight =  $('#update_strada_weight').val();
                        }

                        console.log('restrictionTypeText', restrictionTypeText);

                        // TODO: implement Access and MaxMin restrictions
                        if (restrictionTypeText != 'Select or create restriction') {
                            if (restrictionTypeText == 'Create new TurnRestriction') {
                                restriction_data.push({
                                    from: {
                                        type: "literal",
                                        value: $('#restrictionFrom').val()
                                    },
                                    node: {
                                        type: "literal",
                                        value: $('#restrictionNode').val()
                                    },
                                    to: {
                                        type: "literal", 
                                        value: $('#restrictionTo').val()
                                    },
                                    restriction: {
                                        type: "literal",
                                        value: $('#restrictionType').val()
                                    }
                                });
                                roadElementGraph.selectedRestriction = {
                                    from: 'http://www.disit.org/km4city/resource/' + $('#restrictionFrom').val(),
                                    via: 'http://www.disit.org/km4city/resource/' + $('#restrictionNode').val(),
                                    to: 'http://www.disit.org/km4city/resource/' + $('#restrictionTo').val()
                                }

                                // strada.restriction.push({
                                //     from: 'http://www.disit.org/km4city/resource/' + segmentSelected,
                                //     node: 'http://www.disit.org/km4city/resource/' + $('#restrictionNode').val(),
                                //     to: $('#restrictionTo').val(),
                                //     restriction: restrictionType
                                // });
                                $('#deleteRestriction').css('display', '');
                            } else if (restrictionTypeText == 'Create new AccessRestriction') {
                                alert("Access Restriction not yet implemented");
                                // var direction_access = $('#direction_access').val();
                                // var access_access = $('#access_access').val();
                                // var who_access = $('#who_access').val();
                                // strada.restriction.push({
                                //     direction: direction_access,
                                //     access: access_access,
                                //     who: who_access,
                                //     restriction: 'AccessRestriction'
                                // });
                                // console.log('ACCESS:', strada);
                                //
                                $('#deleteRestriction').css('display', '');
                            } else if (restrictionTypeText == 'Create new MaxMinRestriction') {
                                alert("MaxMin Restriction not yet implemented");
                                // var what_minmax = $('#what_minmax').val();
                                // var limit_minmax = $('#limit_minmax').val();
                                // strada.restriction.push({
                                //     limit: limit_minmax,
                                //     what: what_minmax,
                                //     restriction: 'MaxMinRestriction'
                                // });
                                $('#deleteRestriction').css('display', '');
                            } else {
                                console.log('Not Considered status');
                                $('#deleteRestriction').css('display', 'none');
                            }
                            //

                            //
                        }

                        roadElementGraph.updateSegmentData(strada);
                        roadElementGraph.draw();
                        //roadElementGraph.selectRestrictionColor({}); // TODO WHY???
                        
                        console.log('strada', strada);
                        ///////////DATI RESTRIZIONE////


                    });

                    $('#SelectTo').click(() => {
                        console.log('CLICK TO SELECT A ROAD GRAPH');

                        var restrictionType = $('#restrictionType').val();
                        roadElementGraph.enableRestrictionSelection(strada, (segmentSelected, nodeAttached) => {
                            if (!nodeAttached) {
                                // is not attached, sen
                                console.log('Error selection node');
                                return;
                            }
                            if (!strada.restriction) {
                                strada.restriction = [];
                            }
                            strada.restriction.push({
                                from: strada.segment,
                                node: nodeAttached,
                                to: segmentSelected.segment,
                                restriction: restrictionType
                            });

                            $('#restrictionTo').val(segmentSelected.segment);
                            $('#restrictionNode').val(nodeAttached);
                            //
                            console.log(strada.restriction);
                            roadElementGraph.updateSegmentData(strada);
                            ///
                        });
                        //roadElementGraph.updateSegmentData(strada);
                    });

                    ////////////////////////////////CHANGE RESTRICTION/////////////
                    $('#updateRestriction').change(() => {
                        var restrictionTo = $('#restrictionTo').val();
                        $('#restrictionType').prop('disabled', false);
                        $('#restrictionTo').prop('disabled', false);

                        var updateRestriction = $('#updateRestriction').val();
                        console.log('updateRestriction:', updateRestriction);
                        if (!updateRestriction.includes('new') && !updateRestriction.includes('selected')) {
                            $('#restrictionType').prop('disabled', true);
                            $('#restrictionTo').prop('disabled', true);
                            $('#deleteRestriction').css('display', '');
                            console.log('changing');
                            $('#restrictionType').val(updateRestriction);
                        } else {
                            $('#restrictionType').prop('disabled', false);
                            $('#restrictionTo').prop('disabled', false);
                            $('#deleteRestriction').css('display', 'none');
                        }

                        console.log('restrictionTo', restrictionTo);


                        var listSegments = roadElementGraph.segments;
                        var elementTo = listSegments['http://www.disit.org/km4city/resource/' + restrictionTo];
                        var node = '';
                        if (elementTo !== "" && elementTo != undefined) {
                            var toNodeA = elementTo.nodeA;
                            var toNodeB = elementTo.nodeB;
                            //
                            var fromNodeA = strada.nodeA;
                            var fromNodeB = strada.nodeB;
                            //
                            if (fromNodeA == toNodeB) {
                                node = fromNodeA;
                            }
                            if (fromNodeB == toNodeA) {
                                node = fromNodeB;
                            }
                            //
                            var spitid = node.split('/');
                            var r = spitid.length;
                            var nodeLast = spitid[r - 1];
                            //
                            $('#restrictionNode').val(nodeLast);

                            console.log('elementTo; ', elementTo);

                            // set road colors
                            strada.line.setStyle({color: roadElementGraph.typeColors['restrictionFrom'].color});
                            strada.arrow.setStyle({
                                color: roadElementGraph.typeColors['restrictionFrom'].color, 
                                fillColor: roadElementGraph.typeColors['restrictionFrom'].color
                            });
                            elementTo.line.setStyle({color: roadElementGraph.typeColors['restrictionTo'].color});
                            elementTo.arrow.setStyle({
                                color: roadElementGraph.typeColors['restrictionTo'].color, 
                                fillColor: roadElementGraph.typeColors['restrictionTo'].color
                            });

                            roadElementGraph.selectedRestriction = {
                                from: strada.segment,
                                via: node,
                                to: elementTo.segment
                            };
                        }
                    });

                    ///////////BOLOGNA SELECT TURN RESTRCTION
                    $('#restrictionTo').change(() => {
                        var to = $('#restrictionTo').val();
                        console.log('CHANGE', to);
                        //$(".turnRestriction").css('display', 'none');
                        $('#restrictionType').empty();
                        var actual_value = "http://www.disit.org/km4city/resource/" + $('#restrictionTo').val();

                        const json_posRestrictions = JSON.parse(posRestrictions);
                        for (var z = 0; z < json_posRestrictions.length; z++) {
                            // reset segment color
                            roadElementGraph.segments[json_posRestrictions[z].id].arrow.setStyle({
                                color: roadElementGraph.typeColors['default'].color,
                                fillColor: roadElementGraph.typeColors['default'].color
                            });

                            roadElementGraph.segments[json_posRestrictions[z].id].line.setStyle({
                                color: roadElementGraph.typeColors['default'].color
                            });

                            // update popup infos
                            if (json_posRestrictions[z].id == actual_value) {
                                for (var u = 0; u < json_posRestrictions[z].turn.length; u++) {
                                    var type = json_posRestrictions[z].turn[u];
                                    $('#restrictionType').append('<option class="turnRestriction" value="' + type + '" order="' + u + '">' + type + '</option>');
                                                
                                    // $(".turnRestriction[value='" + type + "']").css('display', '');
                                    // $('#restrictionType').val(type);
                                }
                                $('#restrictionType').trigger('change');
                                $('#restrictionType').prop('disabled', false);
                                $('#restrictionTo').prop('disabled', false);
                            }
                        }
                        var node = '';
                        //console.log(roadElementGraph.segments);
                        var listSegments = roadElementGraph.segments;
                        var elementTo = listSegments["http://www.disit.org/km4city/resource/" + to];
                        if (elementTo !== '') {
                            var toNodeA = elementTo.nodeA;
                            var toNodeB = elementTo.nodeB;
                            //
                            var fromNodeA = strada.nodeA;
                            var fromNodeB = strada.nodeB;
                            //
                            if (fromNodeA == toNodeB) {
                                node = fromNodeA;
                            }
                            if (fromNodeB == toNodeA) {
                                node = fromNodeB;
                            }
                            //
                            console.log('node', node);
                            //
                            var spitid = node.split('/');
                            var r = spitid.length;
                            var nodeLast = spitid[r - 1];
                            //
                            $('#restrictionNode').val(nodeLast);
                        }

                        var restrictionType = $('#restrictionType').val();

                        strada.line.setStyle({color: roadElementGraph.typeColors['restrictionFrom'].color});
                        strada.arrow.setStyle({
                            color: roadElementGraph.typeColors['restrictionFrom'].color, 
                            fillColor: roadElementGraph.typeColors['restrictionFrom'].color
                        });
                        elementTo.line.setStyle({color: roadElementGraph.typeColors['restrictionTo'].color});
                        elementTo.arrow.setStyle({
                            color: roadElementGraph.typeColors['restrictionTo'].color, 
                            fillColor: roadElementGraph.typeColors['restrictionTo'].color
                        });

                        roadElementGraph.selectedRestriction = {
                            from: strada.segment,
                            via: node,
                            to: elementTo.segment
                        };
                    });
                });

                roadElementGraph.addEventListeners();
                if (currentStatusEdit == 'streets') {
                    roadElementGraph.mode = 'drag';
                } else {
                    roadElementGraph.mode = "view";
                }
            } else {
                console.log('roadElementGraph.filterTypes 1', checkedValues);
                roadElementGraph.reset();
                //CHECK SUI VALORI////////////
                /* if (checkedValues.length > 0){
                              roadElementGraph.filterTypes = checkedValues;
                              
                         }*/
                ////////////////
                roadElementGraph.loadGraph(istanzedelgrafochestoconsiderando);
                roadElementGraph.draw();

            }
            $('#jsonIstanze').text('');
            
            ///ADREANI

            var jsonIstanze_content = $('#jsonIstanze').text();
            if ((jsonIstanze_content == "") || (jsonIstanze_content == undefined)) {
                var istanzedelgrafochestoconsiderandoJSON = JSON.stringify(istanzedelgrafochestoconsiderando);
                //$('#jsonIstanze').text(istanzedelgrafochestoconsiderandoJSON);
            }

            //EVENT: CLICK ON POLYLINE




        } catch (error) {
            console.error("Error fetching SPARQL data:", error);
            // $('#road_types').prop('disabled', false);
            $('#view_mod').prop('disabled', false);
            $('#edit_lines').prop('disabled', false);
        }
        if(currentLoadedStatus == 'init'){
            $('#road_types').prop('disabled', false);
        }
        $('#view_mod').prop('disabled', false);
        $('#edit_lines').prop('disabled', false);

    }


    // funzione per leggere i dati da un device
    async function readFromDevice(lAccessToken, deviceName, dateObserved=null) {
        //await getLAccessToken();  
        var listScen = await getLAccessToken();
        if (listScen != undefined) {
            var listScen1 = JSON.parse(listScen);
            if (listScen1.accessToken) {
                lAccessToken = listScen1.accessToken;
            }
            console.log('listScen1', listScen1);
        }
        //
        const header = {
            "Content-Type": "application/json",
            "Accept": "application/x-www-form-urlencoded",
            "Authorization": `Bearer ${lAccessToken}`,
            "Accept-Encoding": "gzip, deflate"
        };
        try {
            //occhio x la prod sisema orion-1....
            //const url = `/superservicemap/api/v1?serviceUri=http://www.disit.org/km4city/resource/iot/orion-1/Organization/${deviceName}&maxResults=10` 
            /*if (lorganizzazione == null){
                lorganizzazione = 'DISIT';
            } 
            
            if (ilbrokerdellorganizzazione == null){
                ilbrokerdellorganizzazione = 'orionUNIFI';
            } */
            var jsonResponse = ''
            if(dateObserved == null){
                const url = "<?= $mainsuperservicemap; ?>" + "?serviceUri=" + "<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + `/${deviceName}&maxResults=10`;
                console.log(url);
                const response = await fetch(url, { // oppure metti urlencoded
                    method: "GET",
                    headers: header
                });
                if (!response.ok) {
                    throw new Error(`Error fetching sensor data: ${response.status}`);
                }
                jsonResponse = await response.json();                
            } else {
                dateObserved = dateObserved.split('.')[0];
                const url = "<?= $mainsuperservicemap; ?>" + "?serviceUri=" + "<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + `/${deviceName}&realtime=true&fromTime=2020-01-01T00:00:00`;
                console.log(url);
                const response = await fetch(url, { // oppure metti urlencoded
                    method: "GET",
                    headers: header
                });
                if (!response.ok) {
                    throw new Error(`Error fetching sensor data: ${response.status}`);
                }
                var res = await response.json();
                var newBindings = [];             
                for (let i = 0; i < res.realtime.results.bindings.length; i++){
                    var dt = res.realtime.results.bindings[i].dateObserved.value;
                    dt = dt.split('.');
                    dt = dt[0];
                    if (dt == dateObserved){
                        newBindings.push(res.realtime.results.bindings[i]);
                    }
                }
                res.realtime.results.bindings = newBindings;
                jsonResponse = res;
            }
            return jsonResponse;
        } catch (error) {
            console.error("Oops: Something Else", error);
        }
    }

    // funzione di Alberto per la creazione del device
    async function createDevice(lAccessToken, deviceName, polygon, ilcentroide) {
        //const gliattributes = '[{"value_name":"areaOfInterest","data_type":"json","value_type":"Geometry","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"roadGraph","data_type":"json","value_type":"Geometry","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"JS20","data_type":"json","value_type":"Geometry","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"AC","data_type":"json","value_type":"Geometry","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"TDMStar","data_type":"json","value_type":"Geometry","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"TFRDevice","data_type":"string","value_type":"URL","editable":"0","value_unit":"SURI","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"status","data_type":"string","value_type":"status","editable":"0","value_unit":"status","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"otherSensors","data_type":"json","value_type":"datastructure","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"trafficSensorList","data_type":"json","value_type":"datastructure","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"dateObserved","data_type":"string","value_type":"timestamp","editable":"0","value_unit":"timestamp","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"name","data_type":"string","value_type":"Identifier","editable":"0","value_unit":"ID","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"description","data_type":"string","value_type":"description","editable":"0","value_unit":"text","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"modality","data_type":"string","value_type":"Identifier","editable":"0","value_unit":"ID","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"referenceKB","data_type":"string","value_type":"URL","editable":"0","value_unit":"SURI","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"sourceData","data_type":"string","value_type":"Identifier","editable":"0","value_unit":"ID","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"startTime","data_type":"string","value_type":"datetime","editable":"0","value_unit":"timestamp","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"endTime","data_type":"string","value_type":"datetime","editable":"0","value_unit":"timestamp","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"location","data_type":"string","value_type":"description","editable":"0","value_unit":"text","healthiness_criteria":"refresh_rate","healthiness_value":"300"},{"value_name":"turn","data_type":"json","value_type":"datastructure","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300"}]';

        //NUOVO
        const gliattributes = '[{"value_name":"fatherDateObserved","data_type":"string","value_type":"datetime","editable":"0","value_unit":"timestamp","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"otherSensors","data_type":"json","value_type":"datastructure","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"location","data_type":"string","value_type":"description","editable":"0","value_unit":"text","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"areaOfInterest","data_type":"json","value_type":"Geometry","editable":"0","value_unit":"text","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"roadGraph","data_type":"json","value_type":"Geometry","editable":"0","value_unit":"text","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"JS20","data_type":"json","value_type":"Geometry","editable":"0","value_unit":"text","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"TDMStar","data_type":"json","value_type":"Geometry","editable":"0","value_unit":"text","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"TFRDevice","data_type":"string","value_type":"URL","editable":"0","value_unit":"SURI","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"status","data_type":"string","value_type":"status","editable":"0","value_unit":"status","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"trafficSensorList","data_type":"json","value_type":"datastructure","editable":"0","value_unit":"complex","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"dateObserved","data_type":"string","value_type":"timestamp","editable":"0","value_unit":"timestamp","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"name","data_type":"string","value_type":"Identifier","editable":"0","value_unit":"ID","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"description","data_type":"string","value_type":"description","editable":"0","value_unit":"text","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"modality","data_type":"string","value_type":"Identifier","editable":"0","value_unit":"ID","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"referenceKB","data_type":"string","value_type":"URL","editable":"0","value_unit":"SURI","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"sourceData","data_type":"string","value_type":"Identifier","editable":"0","value_unit":"ID","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"startTime","data_type":"string","value_type":"datetime","editable":"0","value_unit":"timestamp","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"},{"value_name":"endTime","data_type":"string","value_type":"datetime","editable":"0","value_unit":"timestamp","healthiness_criteria":"refresh_rate","healthiness_value":"300","real_time_flag":"false"}]';

        const [lalongitude, lalatitude] = ilcentroide
        const header = {
            "Content-Type": "application/json",
            "Accept": "application/x-www-form-urlencoded",
            "Authorization": `Bearer ${lAccessToken}`
        };
        try {
            //const urlencoded = `https://iotdirectory.snap4city.org/api/device.php?action=insert&attributes=${encodeURIComponent(gliattributes)}&id=${deviceName}&type=scenario&kind=sensor&contextbroker=orionUNIFI&format=json&model=TFRS-Model&producer=DISIT&latitude=${lalatitude}&longitude=${lalongitude}&visibility=private&frequency=600&token=${lAccessToken}&k1=53bbe5d5-66e1-4cef-ba4f-16084434de48&k2=a9d4454b-bdf9-4481-a065-a23e99360128&edgegateway_type=&edgegateway_uri=&subnature=District&static_attributes=[]&service=&servicePath=&mac=&nodered=false`;
            //occhio abbiamo cambiato il broker e la base url per la prod
            const url = "<?= $baseiotdirectory; ?>" + `?action=insert&attributes=${gliattributes}&id=${deviceName}&type=scenario&kind=sensor&contextbroker=${ilbrokerdellorganizzazione}&format=json&model=TFRS-Model&producer=DISIT&latitude=${lalatitude}&longitude=${lalongitude}&visibility=private&frequency=600&token=${lAccessToken}&k1=53bbe5d5-66e1-4cef-ba4f-16084434de48&k2=a9d4454b-bdf9-4481-a065-a23e99360128&edgegateway_type=&edgegateway_uri=&subnature=District&static_attributes=[]&service=&servicePath=&mac=&nodered=false`;

            const response = await fetch(url, { // oppure metti urlencoded
                method: "POST",
                headers: header
            });
            if (response.ok) { // TODO: better handling of failure cases
                const jsonResponse = await response.json();
                if (jsonResponse.status === 'ok') {
                    //console.log("\nDevice created");
                    return "ok";
                } else {
                    console.log("\nError Device not created!", jsonResponse);
                    return "no";
                }
            } else {
                console.log("\nHTTP Error:", response.status);
                return "no";
            }
        } catch (error) {
            console.error("Oops: Something Else", error);
        }
    }

    // funzione per mandare il road graph al database mysql nel processloader_db -> bigdatadevice
    async function sendDataToDB(suri, idati, dateObserved = "") {
        var listScen = await getLAccessToken();
        if (listScen != undefined) {
            var listScen1 = JSON.parse(listScen);
            if (listScen1.accessToken) {
                lAccessToken = listScen1.accessToken;
            }
            //console.log('listScen1', listScen1);
        }

        //parte controllo dateObserved se passato e se valido
        if (dateObserved === '') {
            // dateObserved = new Date();
            // dateObserved.setHours(dateObserved.getHours() + 2);
            // dateObserved = dateObserved.toISOString().replace('T', ' ').split('.')[0];
            dateObserved = new Date().toISOString(); // this is set in GMT/UTC timezone
        } 
        // else {
        //     try {
        //         let parsedDate = new Date(dateObserved);
        //         parsedDate.setHours(parsedDate.getHours() + 2); // TODO: remove the fixed timezone (what happens when passing from legal to solar hour?)
        //         if (isNaN(parsedDate.getTime())) {
        //             throw new Error('Invalid date format');
        //         }
        //         dateObserved = parsedDate.toISOString().replace('T', ' ').split('.')[0];
        //     } catch (error) {
        //         console.log("dateObserved non è nel formato corretto ('%Y-%m-%d %H:%M:%S')");
        //         console.log("aggiornato all'ora corrente");
        //         dateObserved = new Date().toISOString().replace('T', ' ').split('.')[0];
        //     }
        // }
        dateObserved = dateObserved.replace('T', ' ').split('.')[0];

        const url = "<?= $endprocessloader; ?>" + `postIt.php?suri=${suri}&accessToken=${lAccessToken}&dateObserved=${dateObserved}`;
        const data = {
            grandidati: idati
        };
        const response = await fetch(url, {
            method: 'POST',
            data: { 'accessToken': lAccessToken },
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
        });

        const responseData = await response.json();
        return responseData;
    }

    // funzione get data dal database mysql nel processloader_db -> bigdatadevice filtrando per la suri
    async function getDataFromDB(suri) {
        var listScen = await getLAccessToken();
        if (listScen != undefined) {
            var listScen1 = JSON.parse(listScen);
            if (listScen1.accessToken) {
                lAccessToken = listScen1.accessToken;
            }
            //console.log('listScen1', listScen1);
        }
        const url = "<?= $endprocessloader; ?>" + `getOneSpecific.php?suri=${suri}&accessToken=${lAccessToken}`;
        const response = await fetch(url, {
            method: 'GET',
            data: { 'accessToken': lAccessToken },
            headers: {
                'Content-Type': 'application/json'
            },
        });

        const responseData = await response.json();
        return responseData;
    }

    // funzione di Alberto per l'inserimento dei dati al momento dell'inizializzazione
    async function sendDataINIT(lAccessToken, deviceName, scenario_data, questofather = "") {
        getLAccessToken();
        //console.log("sendDataINITrequest");
        //console.log(lAccessToken);
        const header = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "Authorization": `Bearer ${lAccessToken}`
        };

        const deviceType = "scenario"
        //const url = `https://www.snap4city.org/orionfilter/orionUNIFI/v2/entities/${deviceName}/attrs?elementid=${deviceName}&type=${deviceType}`;
        const url = "<?= $baseorionfilter; ?>" + `${ilbrokerdellorganizzazione}/v2/entities/${deviceName}/attrs?elementid=${deviceName}&type=${deviceType}`;
        const { dateObserved, name, location, description, modality, referenceKB, sourceData, startTime, endTime, organization } = scenario_data.metadata;
        // update prima di salvare i dati nel device del dateObserved

        // Remove parentheses from the values in the JSON object
        var modified_scenario_data_sensors = removeParenthesesFromValues(scenario_data.sensors);
        //
        var shape = [];

        shape = scenario_data.shape;
        console.log(scenario_data.shape);
        if (shape.scenarioareaOfInterest.length > 1) {
            console.log('scenarioareaOfInterest modifed');
            var arr = [];
            arr[0] = scenario_data.shape.scenarioareaOfInterest[0];
            shape['scenarioareaOfInterest'] = arr;
        } else {
            console.log('scenarioareaOfInterest not modifed');
            shape = scenario_data.shape;
        }
        console.log(shape);
        console.log('modified_scenario_data_sensors JSON',modified_scenario_data_sensors);

        //
        if (currentLoadedStatus == ''){
            currentLoadedStatus = "init";
        }

        //var modified_scenario_data_roadGraph = removeParenthesesFromValues(scenario_data.roadGraph);
        const json = JSON.stringify({            
            "dateObserved": { "value": dateObserved, "type": "string" },
            "fatherDateObserved": { "value": "", "type": "string" },
            "name": { "value": name, "type": "string" },
            "location": { "value": location, "type": "string" },
            "description": { "value": description, "type": "string" },
            "modality": { "value": modality, "type": "string" },
            "referenceKB": { "value": referenceKB, "type": "string" },
            "sourceData": { "value": sourceData, "type": "string" },
            "startTime": { "value": startTime, "type": "string" },
            "endTime": { "value": endTime, "type": "string" },
            //"status": { "value": "init", "type": "string" },
            "status": { "value": currentLoadedStatus, "type": "string" },
            // shape sotto
            "areaOfInterest": { "value": shape, "type": "json" },
            "trafficSensorList": { "value": { "modified_scenario_data_sensors": modified_scenario_data_sensors }, "type": "json" },
            "otherSensors": { "value": scenario_data.otherSensors, "type": "json" },
            "roadGraph": { "value": { "schema": "processloader_db", "table": "bigdatafordevice" }, "type": "json" },
            "fatherDateObserved":{"value":questofather,"type":"string"}
        });
        //
        console.log('json', json);
        //
        jsonsolodateobserved = JSON.stringify({
            "dateObserved": { "value": dateObserved, "type": "string" }
        });
        try {
            //console.log("faccio ora la richiesta")
            const response = await fetch(url, {
                method: "PATCH",
                headers: header,
                body: json
            });
            if (!response.ok) {
                //console.log(response)
                throw new Error(`HTTP Error: ${response.status}`);
                showNotification("Error during scenario data updating. Try again later.");
                return "dati_init_no"
            }
            else {
                //console.log("\nSuccessful data entry");
                return "dati_init_si"
            }
        } catch (error) {
            //console.error("Oops: Something Else", error);
            showNotification("Error during scenario data updating. Try again later.");
            return "dati_init_no";
        }
    }

    // funzione di Alberto per l'invio dei dati accorpati
    async function sendDataACC(lAccessToken, deviceName, js20Data, acData, svolte) {
        //await getLAccessToken(); 
        var listScen = await getLAccessToken();
        if (listScen != undefined) {
            var listScen1 = JSON.parse(listScen);
            if (listScen1.accessToken) {
                lAccessToken = listScen1.accessToken;
            }
            console.log('listScen1', listScen1);
        }
        //
        const header = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "Authorization": `bearer ${lAccessToken}`
        };
        const deviceType = "scenario"
        //const url = `https://www.snap4city.org/orionfilter/orionUNIFI/v2/entities/${deviceName}/attrs?elementid=${deviceName}&type=${deviceType}`;
        const url = "<?= $baseorionfilter; ?>" + `${ilbrokerdellorganizzazione}/v2/entities/${deviceName}/attrs?elementid=${deviceName}&type=${deviceType}`;
        // scommenta in prod (forse) dateObserved = new Date().toISOString()
        var date = new Date();
        date.setHours(date.getHours() + 1);
        var dateObserved = date.toISOString();
        // Remove parentheses from the values in the JSON object
        var modified_scenario_data_js20Data = removeParenthesesFromValues(js20Data);
        var modified_scenario_data_acData = removeParenthesesFromValues(acData);
        const json = JSON.stringify({
            "dateObserved": { "value": dateObserved, "type": "string" },
            "status": { "value": "tdm", "type": "string" },
            "JS20": { "value": { "schema": "processloader_db", "table": "bigdatafordevice" }, "type": "json" },
            "TDMStar": { "value": { "schema": "processloader_db", "table": "bigdatafordevice" }, "type": "json" },
            "turn": { "value": svolte, "type": "json" }
        });
        try {
            const response = await fetch(url, {
                method: "PATCH",
                headers: header,
                body: json
            });
            if (!response.ok) {
                //console.log(response)
                throw new Error(`HTTP Error: ${response.status}`);
                return "nobuono"
            }
            else {
                //console.log("\nSuccessful data entry");
                return "tdmok"
            }
        } catch (error) {
            return "nobuono"
            //console.error("Oops: Something Else", error);
        }
    }

    function newMarkerIntersection(coordinates, polygonCoordinates){
        const intersectionPoints = [];

        // Converti le coordinate dei marker in formato {lon, lat}
        const markerLine = [
            { lon: coordinates[0].lng, lat: coordinates[0].lat },
            { lon: coordinates[1].lng, lat: coordinates[1].lat }
        ];

        // Assumi che il primo array di coordinate del poligono sia quello da considerare
        const polygon = polygonCoordinates[0];

        for (let j = 0; j < polygon.length - 1; j++) {
            const polygonPoint1 = { lon: polygon[j][0], lat: polygon[j][1] };
            const polygonPoint2 = { lon: polygon[j + 1][0], lat: polygon[j + 1][1] };

            const intersection = calculateIntersection2(markerLine[0], markerLine[1], polygonPoint1, polygonPoint2);
            if (intersection) {
                intersectionPoints.push(intersection);
            }
        }

        return intersectionPoints;
    }

    function calculateIntersection2(point1, point2, point3, point4) {
        const x1 = point1.lon;
        const y1 = point1.lat;
        const x2 = point2.lon;
        const y2 = point2.lat;
        const x3 = point3.lon;
        const y3 = point3.lat;
        const x4 = point4.lon;
        const y4 = point4.lat;

        const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

        // Controlla se i segmenti sono paralleli
        if (denominator === 0) {
            return null;
        }

        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
        const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
            const lon = x1 + ua * (x2 - x1);
            const lat = y1 + ua * (y2 - y1);
            return { lat, lon };
        }

        return null;
    }

    //################################# Classes #########################################################
    // IlSensore(sensorUri, coordinates,alContorno)
    // °sensorUri
    // °alContorno
    // °considerato
    // °coordinates
    // °icon
    // °marker                      
    // - cambiascelta()
    // - creaMarker()

    // classe IlSensore dello scenario builder che permette di scegliere se considerare o meno il sensore
    class IlSensore {
        //costruttore della classe che prende solo il sensorUri e le coordinate dato che le ho
        //ENRICO Question: ci siamo scordati il campo considered ? l'ho messo nel costruttore ora cerco di capire come mettere il marker
        constructor(
            sensorUri, coordinates, alContorno = false, 
            trafficDensity, trafficSensor, direction = '', 
            tipo_del_sensore_in_base_alla_strada, status, 
            idSensor, considerato=true, assignedRoadElement=null
        ) {
            if (alContorno) {
                this.consideredIcon = L.icon({
                    iconUrl: '../img/gisMapIcons/over/RoadSensor_over.png',
                    iconSize: [32, 32],
                    iconAnchor: [16, 16],
                    popupAnchor: [0, -16]
                });
                this.notConsideredIcon = L.icon({
                    iconUrl: '../img/alarmIcons/alarmMapLow.png',
                    iconSize: [32, 32],
                    iconAnchor: [16, 16],
                    popupAnchor: [0, -16]
                });
                ///
                let default_ttt_values = ["", "d_unclassified" , "d_primary", "d_secondary", "d_tertiary", "d_residential"];

                ///
                if (trafficSensor == ''){ // è un sensore virtuale
                    if (!default_ttt_values.includes(trafficDensity)){ //particolare
                        console.log('Verde1');
                        this.consideredIcon = L.icon({
                            iconUrl: '../img/gisMapIcons/over/RoadSensor-green.png',
                            //iconUrl: '../img/gisMapIcons/over/RoadSensor_over.png',
                            iconSize: [32, 32],
                            iconAnchor: [16, 16],
                            popupAnchor: [0, -16]
                        });
                        this.notConsideredIcon = L.icon({
                            iconUrl: '../img/alarmIcons/alarmMapLow.png',
                            iconSize: [32, 32],
                            iconAnchor: [16, 16],
                            popupAnchor: [0, -16]
                        });
                    }
                }
                // to do: prob aggiornare se modifico metro...
                
                ///
            } else {
                this.consideredIcon = L.icon({
                    iconUrl: '../img/gisMapIcons/RoadSensor.png',
                    iconSize: [32, 32],
                    iconAnchor: [16, 16],
                    popupAnchor: [0, -16]
                });
                this.notConsideredIcon = L.icon({
                    iconUrl: '../img/alarmIcons/alarmMapHigh.png',
                    iconSize: [32, 32],
                    iconAnchor: [16, 16],
                    popupAnchor: [0, -16]
                });
            }
            this.sensorUri = sensorUri;
            this.alContorno = alContorno;
            //
            if((status == undefined)||(status == '')){
                this.status = 'on';
            }else{
                this.status = status;
            }

            if(idSensor == sensorUri){
                this.idSensor = sensorUri;
                this.assignedRoadElement = '';
            }else{
                if(Number.isInteger(idSensor)){
                    this.idSensor = 'virtual_'+idSensor;
                }else{
                    this.idSensor = idSensor;
                } 
                this.assignedRoadElement = sensorUri;
            }

            if(assignedRoadElement != null){
                this.assignedRoadElement = assignedRoadElement;
            }

            
            this.considerato = considerato;
            //
            var checkedValues = $('.checkRoadType:checked').map(function () {
                return this.value;
            }).get();
            //
            console.log('checkedValues',checkedValues);
            console.log('Tipo strada: ',tipo_del_sensore_in_base_alla_strada);
           /* if(checkedValues.includes(tipo_del_sensore_in_base_alla_strada)){
                this.status = 'on';
            }else{
                this.status = 'off';
            }*/
            //
            if((checkedValues.includes(tipo_del_sensore_in_base_alla_strada))&&(status == '')){
                this.status = 'on';
            }
        /*
           if (typeof tipo_del_sensore_in_base_alla_strada === 'undefined') {
                this.status = 'on';
                }*/
            //
            this.trafficDensity = trafficDensity;
            this.trafficSensor = trafficSensor;
            this.direction = direction;
            this.tipo_del_sensore_in_base_alla_strada = tipo_del_sensore_in_base_alla_strada;
            //
            console.log('this.status',this.status,'status',status, 'this.considerato', this.considerato, 'considerato',considerato);
            //
             // di default lo considero
            this.coordinates = coordinates;
            this.icon = this.consideredIcon;
            var currentStatusEdit = $('#currentStatusEdit').val();
            console.log(this.status);

            if(this.status == 'on'){
                    this.marker = this.creaMarker(currentStatusEdit);
            }else if((checkedValues.includes(tipo_del_sensore_in_base_alla_strada))&&(status == undefined)){
                    this.status = 'on';
                    this.marker = this.creaMarker(currentStatusEdit);
            }else{
                this.status = 'off';
                this.marker = this.creaMarker(currentStatusEdit);             
                //nothing
            }

            
            
        }

        updateDate() {
            if ($('#select_ttt').val() != '') {
                this.trafficDensity = $('#select_ttt').val();
                this.trafficSensor = '';
                this.icon = L.icon({
                    iconUrl: '../img/gisMapIcons/over/RoadSensor-green.png',
                    //iconUrl: '../img/gisMapIcons/over/RoadSensor_over.png',
                    iconSize: [32, 32],
                    iconAnchor: [16, 16],
                    popupAnchor: [0, -16]
                });
                this.marker.setIcon(this.icon);
                //$('#current_ttt_text').text(this.trafficDensity);
            }

            if ($('#select_ts').val() != '') {
                this.trafficSensor = $('#select_ts').val();
                this.trafficDensity = '';
                this.icon = L.icon({
                    iconUrl: '../img/gisMapIcons/over/RoadSensor-green.png',
                    //iconUrl: '../img/gisMapIcons/over/RoadSensor_over.png',
                    iconSize: [32, 32],
                    iconAnchor: [16, 16],
                    popupAnchor: [0, -16]
                });
                this.marker.setIcon(this.icon);
                //$('#current_ts_text').text(this.trafficSensor);
            }
            
            let default_ttt_values = ["", "d_unclassified" , "d_primary", "d_secondary", "d_tertiary", "d_residential"];
            
            /* if (($('#select_ts').val() == '') && ($('#select_ttt').val() == '')) {
                this.icon = this.consideredIcon;
                this.marker.setIcon(this.icon);
            }*/
            if (($('#select_ts').val() == '') && !default_ttt_values.includes($('#select_ttt').val())) {
                //this.icon = this.consideredIcon;
                this.marker.setIcon(this.icon);
            }
            //alert('changed values!');
        }

        turnOff(){
            //console.log('filterType');
            //console.log(this);
            this.status = 'off';
            if(this.marker){
            //this.marker.remove();
            this.marker.getElement().classList.add('animationOn');
            }
            // this.marker.add('hidden');
        }

        turnOn(){
            //console.log('filterType');
            //console.log(this);
            this.status = 'on';
            //this.marker = this.creaMarker(currentStatusEdit);
            if(this.marker){ 
                var markerElement = $(this.marker.getElement());
                if (markerElement.hasClass('animationOn')) {
                        // Rimuovi la classe 'animationOn'
                        markerElement.removeClass('animationOn');
                    }
            }
            
        }

        // funzione che modifica se il sensore è considerato o meno per lo scenario di riferimento
        cambiascelta() {
            if (this.considerato) {
                this.considerato = false;
                this.icon = this.notConsideredIcon;
                //this.status = 'off';
            } else {
                this.considerato = true;
                //this.status = 'on';
                //this.icon = this.consideredIcon;
                if ((this.trafficDensity != '') || (this.trafficSensor != '')) {
                    this.icon = this.notConsideredIcon;
                } else {
                    this.icon = this.consideredIcon;
                }
            }
            this.marker.setIcon(this.icon);
            // ci metto la sensorUri del sensore di questo momento
            // ci metto un bottone per scegliere se considerare o meno il sensore
            this.marker.getPopup().setContent(`
                            <p>${this.sensorUri}</p> 
                            <button id="considerOrNotConsiderBtn">${this.considerato ? "Don't Consider" : "Consider"}</button>
                        `);
            this.marker.closePopup();
        }

        moveSensor(coordinates){
            //console.log('moved to: '+coordinates);
            //console.log('polygon Coordinates',scenaryData.features[0].geometry.coordinates);
            
            
            //console.log("ENRICO: intersezione lat: " + newIntersection[0].lat+ "long: " + newIntersection[0].lon);
            //db_new
            try{
                if(this.alContorno == true){
                        let polygon_coordinates = scenaryData.features[0].geometry.coordinates;
                        let newIntersection = newMarkerIntersection(coordinates, polygon_coordinates);
                        this.marker.setLatLng([newIntersection[0].lat, newIntersection[0].lon]);
                        this.coordinates[1] = newIntersection[0].lat;
                        this.coordinates[0] = newIntersection[0].lon;
                }else{
                    ///////////

                    let midpoint = this.getMidpoint(coordinates[0].lat, coordinates[0].lng, coordinates[1].lat, coordinates[1].lng);
                    /////
                    this.marker.setLatLng([midpoint.latitude, midpoint.longitude]);
                    this.coordinates[1] = midpoint.latitude;
                    this.coordinates[0] = midpoint.longitude;
                   
                }
            }catch(error){
                    console.log(error);
            }
            //map.setView([lat, lng], 13);
            //
        }

        toRadians(degrees) {
                        return degrees * Math.PI / 180;
                    }

        toDegrees(radians) {
                return radians * 180 / Math.PI;
        }

        getMidpoint(lat1, lon1, lat2, lon2) {
            // Convert latitude and longitude from degrees to radians
            let lat1Rad = this.toRadians(lat1);
            let lon1Rad = this.toRadians(lon1);
            let lat2Rad = this.toRadians(lat2);
            let lon2Rad = this.toRadians(lon2);

            // Calculate the differences between the coordinates
            let dLon = lon2Rad - lon1Rad;

            // Calculate the midpoint
            let Bx = Math.cos(lat2Rad) * Math.cos(dLon);
            let By = Math.cos(lat2Rad) * Math.sin(dLon);
            let midLat = Math.atan2(Math.sin(lat1Rad) + Math.sin(lat2Rad),
                                    Math.sqrt((Math.cos(lat1Rad) + Bx) * (Math.cos(lat1Rad) + Bx) + By * By));
            let midLon = lon1Rad + Math.atan2(By, Math.cos(lat1Rad) + Bx);

            // Convert the midpoint back to degrees
            midLat = this.toDegrees(midLat);
            midLon = this.toDegrees(midLon);

            return {
                latitude: midLat,
                longitude: midLon
            };
        }

        delete(){
            this.marker.remove();
        }

        // funzione per la creazione del marker in base allo stato considerato o meno del sensore
        creaMarker(currentStatusEdit) {
            //console.log(this);
            //
            if(this.considerato != true){
                this.icon = this.notConsideredIcon;
            }
            //
            const marker = L.marker([this.coordinates[1], this.coordinates[0]], { icon: this.icon });
            //if (this.alContorno){
            //

            // var url2 =  "<?= $mainsuperservicemap; ?>" +"/iot-search/?selection=43.769;11.25&maxDists=1000&model=TTT-model-1&maxResults=1000";
            var ttt_text = `<option value=''>Choose...</option>`;
            var ts_text = `<option value=''>Choose...</option>`;
            //
            arrayTrafficDensity.sort();
            //
            for (var u = 0; u < arrayTrafficDensity.length; u++) {
                ttt_text = ttt_text + (`<option value='` + arrayTrafficDensity[u] + `'>` + arrayTrafficDensity[u] + `</option>`);
            }
            arrayTrafficSensors.sort();
            for (var u = 0; u < arrayTrafficSensors.length; u++) {
                ts_text = ts_text + (`<option value='` + arrayTrafficSensors[u] + `'>` + arrayTrafficSensors[u] + `</option>`);
                //console.log(arrayTrafficSensors[u]);
            }
            //
            $('.leaflet-popup-content').css('width', 'auto');

            //
            var currentStatusEdit = $('#currentStatusEdit').val();
            

            marker.on('popupopen', () => {
                //
                var popup = marker.getPopup();
                var popupElement = popup.getElement();
                //var newContent = popupContent;
                //
                var currentStatusEdit = $('#currentStatusEdit').val();
                console.log('currentStatusEdit', currentStatusEdit);
                
                setTimeout(() => {
                if (currentStatusEdit == 'streets') {
                    // Modifica i contenuti senza invalidare gli eventi
                    $(popupElement).find('#sensorPopup_view').css('display', 'none');
                    $(popupElement).find('#sensorPopup_edit').css('display', 'inline');
                    // Aggiorna i campi di input
                    $(popupElement).find('#select_ttt').val(this.trafficDensity);
                    $(popupElement).find('#select_ts').val(this.trafficSensor);

                } else if (currentStatusEdit == 'view') {
                    $(popupElement).find('#sensorPopup_edit').css('display', 'none');
                    $(popupElement).find('#sensorPopup_view').css('display', 'inline');
                    $(popupElement).find('#current_ttt_text').text(this.trafficDensity);
                    $(popupElement).find('#current_ts_text').text(this.trafficSensor);
                } else {
                    $(popupElement).find('#sensorPopup_edit').css('display', 'none');
                    $(popupElement).find('#sensorPopup_view').css('display', 'inline');
                    $(popupElement).find('#current_ttt_text').text('');
                    $(popupElement).find('#current_ts_text').text('');
                }
                // Forza il rendering del popup per riflettere le modifiche
                popupElement.style.display = 'block';
                //                    
                ////////////
  
                const considerOrNotConsiderBtn = document.getElementById('considerOrNotConsiderBtn');
                considerOrNotConsiderBtn.addEventListener('click', () => {
                    this.cambiascelta();
                });
                ///
                const saveCont = document.getElementById('sensor_save');
                saveCont.addEventListener('click', () => {
                    console.log('UPDATE');
                    this.updateDate();
                });
                ///////CHANGE OPTION////
                $('#select_ttt').change(function () {
                    var selectedValue = $(this).val();
                    console.log('Selected value:', selectedValue);
                    $('#select_ts').val('');
                    // You can perform any action here based on the selected value
                });
                $('#select_ts').change(function () {
                    var selectedValue = $(this).val();
                    console.log('Selected value:', selectedValue);
                    $('#select_ttt').val('');
                    // You can perform any action here based on the selected value
                });
                //////
                $('#change_segment').click(function () {      
                    console.log('CHANGE SEGMENT'); 
                    var idSensorSelected = $('#idSensorSelected').text();
                    if (roadElementGraph){
                            roadElementGraph.mode = 'assignSensor';
                            roadElementGraph.selectedSensor(idSensorSelected);
                        }
                    //alert(current_segment);
                });
                //
                //popup.update();
                }, 100);
                
            });

            var assignedRoadElement = this.assignedRoadElement;
            var splitPoint = assignedRoadElement.indexOf('resource/') + 'resource/'.length;
            var beforeResource = assignedRoadElement.slice(0, splitPoint);  // Parte prima e inclusa 'resource/'
            var afterResource = assignedRoadElement.slice(splitPoint);      // Parte dopo 'resource/'

            var popupContent = `<div id="sensorPopup" style="width: 450px">
                                    <div id="sensorPopup_edit" style="display:none">
                                        <div id="considerOrNotConsiderPanel" style="background-color: #AF5050; color: white">Sensor: ${this.idSensor}</div>
                                        <div id="segmentLabel_view" style="padding:5%; max-width:450px; width: 450px; background-color: white;"><table>
                                        <tbody>
                                        <tr>
                                        <td><b>Traffic density:</b></td><td><select id="select_ttt" value="${this.trafficDensity}" style="width:230px; min-width:230px">`+ ttt_text + `</select></td>
                                        </tr>
                                        <tr>
                                        <td><b>Traffic sensor:</b></td><td><select id="select_ts" value="${this.trafficSensor}" style="width:230px; min-width:230px">`+ ts_text + `</select></td>
                                        </tr>
                                        <tr>
                                        <td><b>Assigned road:</b></td>
                                        <td>
                                            `+beforeResource+` <br />
                                            `+afterResource+`
                                        </td>
                                        </tr>
                                        <tr>  
                                        <td>
                                        <b>Sensor ID:</b></td>
                                        <!-- <td>`+afterResource+`<p id="idSensorSelected" style="display:none">${this.idSensor}</p></td><td></td> -->
                                        <td><p id="idSensorSelected" >${this.idSensor}</p></td>
                                        </tr>
                                        <tr>
                                        <td><button id="sensor_save">Save</button></td><td><button id="considerOrNotConsiderBtn">${this.considerato ? "Don't Consider" : "Consider"}</button>
                                        <button id="change_segment">Set Road element</button></td>
                                        </tr>
                                        </tbody>
                                        </table>
                                        </div>
                                    </div>
                                    <div id="sensorPopup_view">
                                    <div id="considerOrNotConsiderPanelView" style="background-color: #AF5050; color: white">Sensor: ${this.idSensor}</div>
                                        <div id="segmentLabel_view" style="padding:5%; max-width:450px; width: 450px; background-color: white;"><table>
                                        <tbody>
                                        <tr>
                                        <td><b>Traffic density:</b></td><td><p id="current_ttt_text">${this.trafficDensity}</p></td>
                                        </tr>
                                        <tr>
                                        <td><b>Traffic sensor:</b></td><td><p id="current_ts_text">${this.trafficSensor}</p></td>
                                        </tr>
                                        <tr>
                                        <td><b>Assigned road:</b></td>
                                        <td>
                                            `+beforeResource+` <br />
                                            `+afterResource+`
                                        </td>
                                        </tr>
                                        <tr>
                                        <td><b>Sensor ID:</b></td>
                                        <td><p id="idSensorSelected" >${this.idSensor}</p></td>
                                        </tr>
                                        </tbody>
                                        </table>
                                        </div>
                                    </div>
                                    </div>`;
            

            //////////
           /* var $dom = $($.parseHTML(popupContent));
            if (currentStatusEdit == 'streets') {
                $dom.find('#sensorPopup_edit').css('display', 'block');
                $dom.find('#sensorPopup_view').css('display', 'none');
                popupContent = $dom.prop('outerHTML');
                console.log('streets');
            }else if(currentStatusEdit == 'view') {
                $dom.find('#sensorPopup_edit').css('display', 'none');
                $dom.find('#sensorPopup_view').css('display', 'block');
                popupContent = $dom.prop('outerHTML');
                console.log('view');
            }else{
                $dom.find('#sensorPopup_edit').css('display', 'block');
                $dom.find('#sensorPopup_view').css('display', 'none');
                popupContent = $dom.prop('outerHTML');
                console.log('view');
            }*/
            /////////

            marker.bindPopup(popupContent);
            oms.addMarker(marker);
            return marker;
        }

        ///////////OPERAZIONI CLASSE IL SENSORE//////
        //////////
    }



    function findBoundingBox(enlargedPolygonWKT) {
        // Estrai le coordinate dal formato WKT
        const coordinates = enlargedPolygonWKT
            .match(/\(\(([^)]+)\)\)/)[1]
            .split(',')
            .map(point => point.trim().split(' ').map(Number));

        // Inizializza le coordinate minime e massime
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        // Itera attraverso i punti del poligono per trovare le coordinate estreme
        for (const [x, y] of coordinates) {
            // Aggiorna le coordinate minime e massime
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
        }

        // Restituisci il rettangolo che include il poligono
        const boundingBox = {
            minX,
            minY,
            maxX,
            maxY,
        };

        return boundingBox;
    }


    //#####################################################################################################
    //#####################################################################################################                
    //########################### main progam - SCENARIO BUILDER EVENT TRIGGERED ##########################
    //#####################################################################################################
    //#####################################################################################################                
    //
    //                  main <- addTrafficScenary            event sent dal selettore
    //                    |     |
    //                    |     |-> scenaryControl             inserisco nella mappa
    //                    |     -> #scenario-cancel            reset scenaryControl
    //                    |     -> #scenario-save              button click handler                
    //                    |     -> #scenario-check-acc1        button click handler
    //                    |        |-> #scenario-save-finale1  button click handler
    //                    |              
    //                    X   <- removeTrafficScenary          event toggled dal selettore                

    //################## appena inviato l'evento addTrafficScenary dal selettore ##########################
    $(document).on('addTrafficScenary', function (event) {
        getLeAltreUserInfo();
        if (event.target === map.mapName) {
            // metto subito il layer dei markers                         
            scenaryMarkers = new L.FeatureGroup();
            map.defaultMapRef.addLayer(scenaryMarkers);
            // e anche quello per i disegni sulla mappa
            scenaryDrawnItems = new L.FeatureGroup();
            map.defaultMapRef.addLayer(scenaryDrawnItems);
            // e anche quello per il grafo
            scenaryGrafo = new L.FeatureGroup();
            map.defaultMapRef.addLayer(scenaryGrafo);
            //aggiungo anche il tool per disegnare su mappa 
            drawerControl = new L.Control.Draw({
                edit: {
                    featureGroup: scenaryDrawnItems,
                    edit: false,
                    remove: false
                },
                draw: {
                    circle: false,
                    marker: false,
                    polyline: false,
                    polygon: false,
                    rectangle: false
                }
            });

            map.defaultMapRef.addControl(drawerControl);
            // poi sistemo i disegni che vengono fatti 

            //BOLOGNA
            map.defaultMapRef.on('draw:deleted', function (e) {
                console.log('DELETE LAYER');
                map.defaultMapRef.eachLayer(function (layer) {
                    // Verifica se il layer è un poligono, rettangolo o marker
                    if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
                        map.defaultMapRef.removeLayer(layer);
                    }
                });

                map.defaultMapRef.removeLayer(scenaryDrawnItems);
                map.defaultMapRef.removeLayer(scenaryMarkers);
                map.defaultMapRef.removeLayer(scenaryGrafo);
                map.defaultMapRef.removeLayer(scenaryOtherSensors);
                $('#jsonIstanze').text('');
                
                datidaisensorichestoconsiderando = []; // reinizializzo questa variabile
                istanzedeisensorichestoconsiderando = []; // reinizializzo questa variabile
                istanzedelgrafochestoconsiderando = []; // reinizializzo questa variabile
                
                scenaryMarkers = new L.FeatureGroup();
                map.defaultMapRef.addLayer(scenaryMarkers);
                // e anche quello per i disegni sulla mappa
                scenaryDrawnItems = new L.FeatureGroup();
                map.defaultMapRef.addLayer(scenaryDrawnItems);
                // e anche quello per il grafo
                scenaryGrafo = new L.FeatureGroup();
                map.defaultMapRef.addLayer(scenaryGrafo);
                //
                scenaryOtherSensors = new L.FeatureGroup();
                map.defaultMapRef.addLayer(scenaryOtherSensors);
                //
            });
            ////FINE BOLOGNA

            map.defaultMapRef.on('draw:created', function (e) {
                //
                console.log('event draw:');     

                $('#road_types').prop('disabled', true);
                $('#view_mod').prop('disabled', true);
                $('#edit_lines').prop('disabled', true);

                pulisciTutto();
                currentLoadedStatus = "init";
                riferimentoSensoriAccorpato = [];
                loadedtmpAcData = '';
                loadedAcData = '';
                loadedjs20Data = '';
                loadtmpRDGraph = '';

                // ENRICO svuoto di nuovo questi valori del db per il risalvataggio dell'acc
                loadedAccAC = '';
                loadedAccRoadGraph = '';
                loadedAccFilters = '';
                loadedAccSensors = '';
                loadedAccRestrictions = '';
                loadedAccJS20= '';
                //

                
                $('#jsonIstanze').text('');
                
                // metto un popup sul poligono attuale per riferimento
                var type = e.layerType,
                    layer = e.layer;
                console.log('layer', layer);   
                // mi prendo la geometria del poligono in formato geojson  
                var curGeojson = layer.toGeoJSON();
                // per il debug se vuoi scommenta sotto
                // aggiungo la geometria allo scenaryData.features 
                // e il layer al scenarydrawnitems per visualizzarlo su mappa
                scenaryData.features.push(curGeojson);
                scenaryDrawnItems.addLayer(layer);
                // a questo punto faccio la richiesta sensori del traffico
                // mi convertio la geometria in geojson in wkt
                const polygonWKT = getPolygonWKTFromScenarioArea(scenaryData.features);
                // adesso mi calcolo anche il poligono allargato per fare la query al grafo strade
                // Dividi il poligono WKT in coppie di coordinate
                const coordinates = polygonWKT
                    .match(/\d+\.\d+\s\d+\.\d+/g)
                    .map(coord => coord.split(' ').map(Number));
                // Calcola il centroide
                const centroid = coordinates.reduce(
                    (acc, [lon, lat]) => [acc[0] + lon, acc[1] + lat],
                    [0, 0]
                );
                centroid[0] /= coordinates.length;
                centroid[1] /= coordinates.length;
                // Definisci la distanza di espansione in gradi
                const enlargementDistance = 0.02; // Regola questa distanza come necessario
                // Applica l'espansione alle coordinate
                const enlargedCoordinates = coordinates.map(([lon, lat]) => [
                    lon + (lon - centroid[0]) * enlargementDistance,
                    lat + (lat - centroid[1]) * enlargementDistance
                ]);
                // Costruisci il poligono allargato come WKT
                const enlargedPolygonWKT = `POLYGON ((${enlargedCoordinates
                    .map(coord => coord.join(' '))
                    .join(', ')}))`;                             
                // per poi creare la url per fare la richiesta dei sensori del traffico 
                const sensorURL = buildSensorAPIURL(polygonWKT);

                // ora faccio la richiesta sparql alla kb per prendere i dati del grafo strade ...
                const enlargedPolygonBoundingBox = findBoundingBox(enlargedPolygonWKT);
                sparqlQueryottimizzata = buildSparqlQueryURLottimizzata(enlargedPolygonBoundingBox.maxY, enlargedPolygonBoundingBox.maxX, enlargedPolygonBoundingBox.minY, enlargedPolygonBoundingBox.minX);
                svoltesparqlquery = buildSparqlQueryURLsvolte(enlargedPolygonWKT);

                // execute query to KB

                // ressvolte = fetchSparqlDataSvolte(svoltesparqlquery);

                //BOLOGNA OtherSensors Level
                var bounds = layer.getBounds();
                var markersInShape = [];
                // Itera attraverso tutti i marker e verifica se sono nell'area del rettangolo
                map.defaultMapRef.eachLayer(function (layer) {
                    if (layer instanceof L.Marker) {
                        if (bounds.contains(layer.getLatLng())) {
                            markersInShape.push(layer);
                        }
                    }
                });

                for (var i = 0; i < markersInShape.length; i++) {
                    //console.log(markersInRectangle[i].feature.properties.serviceUri);
                    if (markersInShape[i].feature != undefined) {
                        var su_marker = markersInShape[i].feature.properties.serviceUri;
                        scenaryOtherSensors.push(su_marker);
                    }
                }

                //FINE BOLOGNA
                // Create the loading box element and add it to the document
                const loadingBox = document.createElement("div");
                loadingBox.id = "loading-box";
                loadingBox.style.position = "absolute";
                loadingBox.style.top = "20%";
                loadingBox.style.left = "50%";
                loadingBox.style.transform = "translate(-50%, -50%)";
                loadingBox.style.backgroundColor = "#fff";
                loadingBox.style.border = "1px solid #ccc";
                loadingBox.style.padding = "20px";
                loadingBox.style.boxShadow = "0 0 10px rgba(0, 0, 0, 0.2)";
                loadingBox.style.zIndex = "9999";
                loadingBox.innerHTML = '<p style="color: black";>The road graph is loading...</p>';
                // Append the loading box to the map container
                const mapContainer = this.getContainer(); // Assuming `this` refers to the map object
                mapContainer.appendChild(loadingBox);                                                        
                // Before making the requests, show the loading box
                loadingBox.style.display = "block";
                loadingboxloaded = false;
                // Use Promise.all to fetch data concurrently
                if (($('#showStreetGraph').is(':checked')) && ($('#showTrafficSensors').is(':checked'))) {
                    Promise.all([fetchTrafficSensorData(sensorURL), fetchSparqlData(sparqlQueryottimizzata, svoltesparqlquery, polygonWKT,null,null,'create')])
                        .then((data) => {
                            loadingBox.style.display = "none";
                            mapContainer.removeChild(loadingBox);
                            loadingboxloaded = true;
                            handleIntersectionsAndSensors(polygonWKT);
                        })
                        .catch(error => {
                            // Hide and remove the loading box in case of an error
                            loadingBox.style.display = "none";
                            mapContainer.removeChild(loadingBox);
                            loadingboxloaded = false;

                            console.error("Error:", error);
                        });
                } else if (($('#showStreetGraph').is(':checked')) && (!$('#showTrafficSensors').is(':checked'))) {
                    Promise.all(fetchSparqlData(sparqlQueryottimizzata, svoltesparqlquery, polygonWKT,null,null,'create'))
                        .then(() => {
                            loadingBox.style.display = "none";
                            mapContainer.removeChild(loadingBox);
                            loadingboxloaded = true;
                            handleIntersectionsAndSensors(polygonWKT);

                        })
                        .catch(error => {
                            // Hide and remove the loading box in case of an error
                            loadingBox.style.display = "none";
                            mapContainer.removeChild(loadingBox);
                            loadingboxloaded = false;

                            console.error("Error:", error);
                        });
                } else if ((!$('#showStreetGraph').is(':checked')) && ($('#showTrafficSensors').is(':checked'))) {
                    Promise.all([fetchTrafficSensorData(sensorURL)])
                        .then(() => {
                            loadingBox.style.display = "none";
                            mapContainer.removeChild(loadingBox);
                            loadingboxloaded = true;
                            handleIntersectionsAndSensors(polygonWKT);
                        })
                        .catch(error => {
                            // Hide and remove the loading box in case of an error
                            loadingBox.style.display = "none";
                            mapContainer.removeChild(loadingBox);
                            loadingboxloaded = false;

                            console.error("Error:", error);
                        });
                } else {
                    loadingBox.style.display = "none";
                    mapContainer.removeChild(loadingBox);
                    loadingboxloaded = false;
                }

            });

            

            var scenaryEditControl = L.control({
                position: 'bottomleft'
            });

            scenaryEditControl.onAdd = function (map) {
                ////Aggiunta pulsanti editing
                var div1 = L.DomUtil.create('div');
                div1.id = "scenary_selector";
                div1.innerHTML = `
                    <div id="menu-lines" style="max-width: 55px;" hidden>
                        <div id="scenario-div">
                            <table>
                                <tr>
                                    <td colspan="2">
                                        <button type="button" id="line_create" style="margin: 2%; width: 30px" title="Create"><i class="fa fa-pencil" aria-hidden="true"></i></button>
                                    </td>
                                </tr>
                                <tr>
                                    <td colspan="2">
                                        <button type="button" id="line_drag" style="margin: 2%; width: 30px" title="Drag/Join"><i class="fa fa-arrows" aria-hidden="true"></i></button>
                                    </td>
                                </tr>
                                <tr>
                                    <td colspan="2">
                                        <button type="button" id="line_split" style="margin: 2%; width: 30px" title="Split"><i class="fa fa-chain-broken" aria-hidden="true"></i></button>
                                    </td>
                                </tr>
                                <tr>
                                    <td colspan="2">
                                        <button type="button" id="line_delete" style="margin: 2%; width: 30px" title="Delete"><i class="fa fa-eraser" aria-hidden="true"></i></button>
                                    </td>
                                </tr>
                                <tr>
                                    <td colspan="2">
                                        <button type="button" id="line_redo" style="margin: 2%; width: 30px" title="Redo"><i class="fa fa-repeat" aria-hidden="true"></i></button>
                                    </td>
                                </tr>
                                <tr>
                                    <td colspan="2">
                                        <button type="button" id="line_undo" style="margin: 2%; width: 30px" title="Undo"><i class="fa fa-undo" aria-hidden="true"></i></button>
                                    </td>
                                </tr>
                                <tr>
                                    <td colspan="2">
                                        <button type="button" id="line_reset" style="margin: 2%; width: 30px" title="Reset"><i class="fa fa-trash" aria-hidden="true"></i></button>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <textarea id="jsonIstanze" style="display:none;"></textarea>
                    <div id="select-modality">
                        <div id="scenario-div" style="background-color: white">
                            <div id="edit-content">
                                <table>
                                    <tr>
                                        <td colspan="2">
                                            <input type="text" id="currentStatusEdit" value="" hidden></input>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>                                                                       
                                            <button type="button" id="view_mod" style="margin: 2%; background-color: rgb(62, 100, 166); color: rgb(255, 255, 255);"><i class="fa fa-eye" aria-hidden="true"></i>    View</button>
                                        </td>
                                        <td>    
                                            <button type="button" id="edit_lines" style="margin: 2%"><i class="fa fa-pencil" aria-hidden="true"></i> Edit</button> 
                                        </td>
                                    </tr>
                                    <tr></tr>
                                    <tr>
                                        <td colspan="2">
                                            <input type="checkbox" id="showStreetGraph" value="street" checked/>Show Road graph
                                        </td>
                                    </tr>
                                    <tr>
                                        <td colspan="2">
                                            <input type="checkbox" id="showTrafficSensors" value="traffic" checked/> Show Traffic Sensors
                                        </td>
                                    </tr>
                                    <! -- SELECT ROAD TYPE-->
                                    <tr>
                                        <td colspan="2">
                                            <button type="button" id="road_types" style="margin: 2%">Filter by road types</button> 
                                        </td>
                                        <td>       
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>`;

                // Disabilita l'interazione di questo div con la mappa per evitare conflitti
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(div1);
                    L.DomEvent.on(div1, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(div1, 'click', L.DomEvent.stopPropagation);
                }
                return div1;
            };
            scenaryEditControl.addTo(map.defaultMapRef); // e chiudo con l'inserimento di qusto nella mappa

            $('#road_types').click(function () {

                console.log('road_types');
                var scenaryControl4 = L.control({
                    position: 'bottomright'
                });

                var element = document.getElementById('filter-list');
                if (element !== null) {
                    if ($('#filter-list').is(':hidden')) {
                        $('#filter-list').show();
                        $("#road_types").css('background-color', '#3E64A6');
                        $("#road_types").css('color', 'white');
                    } else {
                        $('#filter-list').hide();
                        $("#road_types").css('background-color', '');
                        $("#road_types").css('color', 'black');
                    }
                } else {
                    scenaryControl4.onAdd = function (map) {
                        var div = L.DomUtil.create('div');
                        //currentStatusEdit MANAGE STATUS//
                        $("#road_types").css('background-color', '#3E64A6');
                        $("#road_types").css('color', 'white');
                        //
                        div.id = "filter-list";
                        div.innerHTML = `
                            <div id="scenario-div" style="margin: 10px;">
                                <table>
                                    <tbody style="margin-right: 5px; margin-left: 5px; background-color:#C0C0C0">
                                        <tr style="margin-bottom: 20px">
                                            <td colspan="2"><span><b>Road Types:</b></span></td>
                                            <td colspan="2"><input type="checkbox" id="selectAllRoad" value="all" checked/>Select All</td>
                                            <td colspan="2"><input type="checkbox" id="SelectNoRoad" value="noone" />Unselect All</td>
                                        </tr>
                                        <tr>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="abandoned" checked/>abandoned</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="bridleway" checked/>bridleway</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="bus_guideway" checked/>bus_guideway</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="bus_stop" checked/>bus_stop</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="construction"checked/>construction</td>
                                        </tr>
                                        <tr>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="corridor"  checked/>corridor</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="crossing"  checked/>crossing</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="cycleway" checked/>cycleway</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="disused" checked/>disused</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="elevator" checked/>elevator</td>
                                        </tr>
                                        <tr>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="emergency_access_point" checked/>emergency_access_point</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="emergency_bay" checked/>emergency_bay</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="footway" checked/>footway</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="island" checked/>island</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="living_street" checked/>living_street</td>
                                        </tr>
                                        <tr>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="motorway" checked/>motorway</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="motorway_link" checked/>motorway_link</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="no" checked/>no</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="path" checked/>path</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="platform" checked/>platform</td>
                                        </tr>
                                        <tr>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="primary" checked/>primary</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="primary_link" checked/>primary_link</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="private" checked/>private</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="raceway" checked/>raceway</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="razed" checked/>razed</td>
                                        </tr>
                                        <tr>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="residential" checked/>residential</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="rest_area" checked/>rest_area</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="road" checked/>road</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="secondary_link" checked/>secondary_link</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="service" checked/>service</td>
                                        </tr>
                                        <tr>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="services" checked/>services</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="steps" checked/>steps</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="tertiary" checked/>tertiary</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="tertiary_link" checked/>tertiary_link</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="track" checked/>track</td>
                                        </tr>
                                        <tr>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="traffic_island" checked/>traffic_island</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="tram" checked/>tram</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="trunk_link" checked/>trunk_link</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="unclassified" checked/>unclassified</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="via_ferrata" checked/>via_ferrata</td>
                                            
                                        </tr>
                                        <tr>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="secondary" checked/>secondary</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="yes" checked/>yes</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="pedestrian" checked/>pedestrian</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="bus_guideway" checked/>bus_guideway</td>
                                            <td colspan="2"><input type="checkbox" class="checkRoadType" value="ohm:military:Trench" checked/>ohm:military:Trench</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>`;

                        // Disabilita l'interazione di questo div con la mappa per evitare conflitti
                        if (L.Browser.touch) {
                            L.DomEvent.disableClickPropagation(div);
                            L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
                        } else {
                            L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
                        }
                        return div;
                    };
                    
                    // $('.checkRoadType').click(function () {
                    //     console.log('click 2');
                    //     var checkboxes = document.querySelectorAll('.checkRoadType:checked');
                    //     var selectedRoadTypes = [];
                    //     checkboxes.forEach(function (checkbox) {
                    //         if (checkbox.checked) {
                    //             selectedRoadTypes.push(checkbox.value);
                    //         }
                    //     });
                    //     roadElementGraph.filterTypes = selectedRoadTypes;
                    //     roadElementGraph.draw();

                    //     $("#SelectNoRoad").prop("checked", false);
                    //     $("#selectAllRoad").prop("checked", false);
                    // });

                    // $('#selectAllRoad').click(function () {
                    //     $(".checkRoadType").prop("checked", true);
                    //     $("#SelectNoRoad").prop("checked", false);
                    //     var checkboxes = document.querySelectorAll('.checkRoadType:checked');
                    //     var selectedRoadTypes = [];
                    //     checkboxes.forEach(function (checkbox) {
                    //         if (checkbox.checked) {
                    //             selectedRoadTypes.push(checkbox.value);
                    //         }
                    //     });
                    //     roadElementGraph.filterTypes = selectedRoadTypes;
                    //     roadElementGraph.draw();
                    // });

                    // $('#SelectNoRoad').click(function () {
                    //     $(".checkRoadType").prop("checked", false);
                    //     $("#selectAllRoad").prop("checked", false);
                    //     var checkboxes = document.querySelectorAll('.checkRoadType:checked');
                    //     var selectedRoadTypes = [];
                    //     checkboxes.forEach(function (checkbox) {
                    //         if (checkbox.checked) {
                    //             selectedRoadTypes.push(checkbox.value);
                    //         }
                    //     });
                    //     roadElementGraph.filterTypes = selectedRoadTypes;
                    //     roadElementGraph.draw();
                    // });
                }
            });

            $('#line_create').click(function () {
                //lline_create
                $("#line_create").css('background-color', '#3E64A6');
                $("#line_create").css('color', 'white');
                //line_drag
                $("#line_drag").css('background-color', '');
                $("#line_drag").css('color', 'black');
                //line_split
                $("#line_split").css('background-color', '');
                $("#line_split").css('color', 'black');
                //line_delete
                $("#line_delete").css('background-color', '');
                $("#line_delete").css('color', 'black');
                //
                // $('#line_assign').css('background-color', '');
                // $("#line_assign").css('color', 'black');

                if(roadElementGraph){
                    roadElementGraph.mode = 'create';
                }
            });

            $('#line_drag').click(function () {
                //lline_create
                $("#line_create").css('background-color', '');
                $("#line_create").css('color', 'black');
                //line_drag
                $("#line_drag").css('background-color', '#3E64A6');
                $("#line_drag").css('color', 'white');
                //line_split
                $("#line_split").css('background-color', '');
                $("#line_split").css('color', 'black');
                //line_delete
                $("#line_delete").css('background-color', '');
                $("#line_delete").css('color', 'black');
                //
                // $('#line_assign').css('background-color', '');
                // $("#line_assign").css('color', 'black');

                if(roadElementGraph){
                    roadElementGraph.mode = 'drag';
                }
            });

            $('#line_split').click(function () {
                //lline_create
                $("#line_create").css('background-color', '');
                $("#line_create").css('color', 'black');
                //line_drag
                $("#line_drag").css('background-color', '');
                $("#line_drag").css('color', 'black');
                //line_split
                $("#line_split").css('background-color', '#3E64A6');
                $("#line_split").css('color', 'white');
                //line_delete
                $("#line_delete").css('background-color', '');
                $("#line_delete").css('color', 'black');
                //
                // $('#line_assign').css('background-color', '');
                // $("#line_assign").css('color', 'black');

                if(roadElementGraph){
                    roadElementGraph.mode = 'split';
                }
            });

            $('#line_delete').click(function () {
                //lline_create
                $("#line_create").css('background-color', '');
                $("#line_create").css('color', 'black');
                //line_drag
                $("#line_drag").css('background-color', '');
                $("#line_drag").css('color', 'black');
                //line_split
                $("#line_split").css('background-color', '');
                $("#line_split").css('color', 'black');
                //line_delete
                $("#line_delete").css('background-color', '#3E64A6');
                $("#line_delete").css('color', 'white');
                //
                // $('#line_assign').css('background-color', '');
                // $("#line_assign").css('color', 'black');
                if(roadElementGraph){
                    roadElementGraph.mode = 'delete';
                }
            });

            // $('#line_assign').click(function () {
            //     //lline_create
            //     $("#line_create").css('background-color', '');
            //     $("#line_create").css('color', 'black');
            //     //line_drag
            //     $("#line_drag").css('background-color', '');
            //     $("#line_drag").css('color', 'black');
            //     //line_split
            //     $("#line_split").css('background-color', '');
            //     $("#line_split").css('color', 'black');
            //     //line_delete
            //     $("#line_delete").css('background-color', '');
            //     $("#line_delete").css('color', 'black');
            //     //
            //     $('#line_assign').css('background-color', '#3E64A6');
            //     $("#line_assign").css('color', 'white');
            // });


            $("#line_reset").click(function () {
                console.log('CLICK ON CANCEL');
                pulisciTutto();
            });

            //################## poi mi metto subito lo scenary control #################################                       
            var scenaryControl = L.control({
                position: 'topright'
            });

            scenaryControl.onAdd = function (map) {
                var div = L.DomUtil.create('div');
                //currentStatusEdit MANAGE STATUS//
                div.id = "modality-load";
                div.innerHTML = `
                    <div id="scenario-div">
                        <div id="notification" style="display: none;">
                            <p id="notification-message">bells</p>
                        </div>                                    
                        <div id="scenario-content">                                        
                            <div id="acc-content">
                                <!-- ONLOAD VERSIONE -->
                                <table>
                                    <tr>
                                        <td><label>Load Scenario:</label></td>
                                        <td>
                                            <input type="radio" id="acc-type-init" name="scenario-type" value="init" checked>
                                            <label for="acc-type-init">Init</label>

                                            <input type="radio" id="acc-type-acc" name="scenario-type" value="acc">
                                            <label for="acc-type-acc">Acc</label>

                                            <!-- <input type="radio" id="acc-type-tdm" name="scenario-type" value="tdm">
                                            <label for="acc-type-tdm">tfr</label> -->
                                        </td>
                                    </tr>
                                    <td id="scenario-init-row">                                                    
                                        <label for="scenario-init-list">Scenarios waiting to be processed:</label>
                                        <input type="text" id="search-scenario-init" placeholder="Search..." hidden>      
                                        <select id="scenario-init-list" style="max-height: 120px; overflow: auto;"></select>  
                                        <!-- -->
                                        <br />
                                        <label for="scenario-version-list">Scenario version:</label>
                                        <select id="scenario-version-list" style="max-height: 120px; overflow: auto;"></select>
                                        <br />
                                        <button id="scenario-load">Load Scenario</button>
                                        <button id="scenario-init-reload">Clean</button>                                                                                            
                                    </td>                                                   
                                    <tr class="scenario-list-row" style="display: none;">
                                        <td>
                                            <label for="scenario-list">Scenario List:</label>
                                        </td>
                                        <td>
                                            <select id="scenario-list" name="scenario-list"></select>
                                        </td>
                                    </tr>
                                    <tr class="scenario-list-row" style="display: none;">
                                        <td>
                                            <label for="acc-list">acc version:</label>
                                        </td>
                                        <td>
                                            <select id="acc-list" name="acc-list"></select>
                                        </td>
                                    </tr>
                                    <tr class="scenario-list-row" style="display: none;">
                                        <td colspan="2">
                                            <button id="scenario-check-acc1">Load ACC</button>
                                            <button id="scenario-check-acc-reaload">Clean</button>
                                        </td>
                                    </tr>
                                    <!-- -->                                    
                                    <tr class="scenario-tdm-row" style="display: none;">                                        
                                        <td>
                                            <label for="scenario-tdm-list">tfr Scenarios:</label>
                                        </td>
                                        <td>
                                            <select id="scenario-tdm-list" name="scenario-tdm-list"></select>
                                        </td>
                                            <!-- -->    
                                        </td>                                                   
                                    </tr>
                                    <tr class="scenario-tdm-row" style="display: none;">
                                        <td>
                                            <label for="tdm-list">tfr version:</label>
                                        </td>
                                        <td>
                                            <select id="tdm-list" name="tdm-list"></select>
                                        </td>
                                    </tr>
                                    <tr class="scenario-tdm-row">
                                        <td colspan="2">
                                            <button id="scenario-check-tdm">Load tfr</button>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>                                
                    </div>`;

                // Disabilita l'interazione di questo div con la mappa per evitare conflitti
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(div);
                    L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
                }
                return div;
            };
            scenaryControl.addTo(map.defaultMapRef); // e chiudo con l'inserimento di qusto nella mappa

            ////////Creazione del LoadFIlters (invisibile)
            /////////////////////////////////////////
            var scenaryControl0 = L.control({
                position: 'bottomright'
            });
            scenaryControl0.onAdd = function (map) {
                var div = L.DomUtil.create('div');
                //currentStatusEdit MANAGE STATUS//
                div.id = "filter-list";
                div.style.display = "none";
                div.innerHTML = `
                    <div id="scenario-div" style="margin: 10px; background-color:#C0C0C0">
                        <table>
                            <tbody style="margin-right: 5px; margin-left: 5px;">
                                <tr style="margin-bottom: 20px">
                                    <td colspan="2"><span><b>Road Types:</b></span></td>
                                    <td colspan="2"><input type="checkbox" id="selectAllRoad" value="all" />Select All</td>
                                    <td colspan="2"><input type="checkbox" id="SelectNoRoad" value="noone" />Unselect All</td>
                                </tr>
                                <tr>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="abandoned" checked/>abandoned</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="bridleway" checked/>bridleway</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="bus_guideway" checked/>bus_guideway</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="bus_stop" checked/>bus_stop</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="construction" checked/>construction</td>
                                </tr>
                                <tr>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="corridor" checked/>corridor</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="crossing"  checked/>crossing</td>
                                    <td colspan="2" style="color:cyan"><input type="checkbox" class="checkRoadType" value="cycleway" checked/>cycleway</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="disused" checked/>disused</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="elevator" checked/>elevator</td>
                                </tr>
                                <tr>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="emergency_access_point" checked/>emergency_access_point</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="emergency_bay" checked/>emergency_bay</td>
                                    <td colspan="2" style="color:yellow"><input type="checkbox" class="checkRoadType" value="footway" checked/>footway</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="island" checked/>island</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="living_street" checked/>living_street</td>
                                </tr>
                                <tr>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="motorway" checked/>motorway</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="motorway_link" checked/>motorway_link</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="no" checked/>no</td>
                                    <td colspan="2" style="color:yellow"><input type="checkbox" class="checkRoadType" value="path" checked/>path</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="platform" checked/>platform</td>
                                </tr>
                                <tr>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="primary" checked/>primary</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="primary_link" checked/>primary_link</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="private" checked/>private</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="raceway" checked/>raceway</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="razed" checked/>razed</td>
                                </tr>
                                <tr>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="residential" checked/>residential</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="rest_area" checked/>rest_area</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="road" checked/>road</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="secondary_link" checked/>secondary_link</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="service" checked/>service</td>
                                </tr>
                                <tr>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="services" checked/>services</td>
                                    <td colspan="2" style="color:yellow"><input type="checkbox" class="checkRoadType" value="steps" checked/>steps</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="tertiary" checked/>tertiary</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="tertiary_link" checked/>tertiary_link</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="track" checked/>track</td>
                                </tr>
                                <tr>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="traffic_island" checked/>traffic_island</td>
                                    <td colspan="2" style="color:green"><input type="checkbox" class="checkRoadType" value="tram" checked/>tram</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="trunk_link" checked/>trunk_link</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="unclassified" checked/>unclassified</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="via_ferrata" checked/>via_ferrata</td>
                                    
                                </tr>
                                <tr>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="secondary" checked/>secondary</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="yes" checked/>yes</td>
                                    <td colspan="2" style="color:yellow"><input type="checkbox" class="checkRoadType" value="pedestrian" checked/>pedestrian</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="bus_guideway" checked/>bus_guideway</td>
                                    <td colspan="2" style="color:blue"><input type="checkbox" class="checkRoadType" value="ohm:military:Trench" checked/>ohm:military:Trench</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>`;
                // Disabilita l'interazione di questo div con la mappa per evitare conflitti
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(div);
                    L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
                }
                return div;
                div.css('display', 'none');
            };
            scenaryControl0.addTo(map.defaultMapRef); // e chiudo con l'inserimento di qusto nella mappa

            getInits();

            window.addEventListener('message', async function(event) {
                // Optionally, check event.origin to ensure it's from a trusted source
                //console.log('Message received from iframe:', event.data);

                if (event.data.event === 'customEventShowACC') {
                    if (document.getElementById('view_mod').style.backgroundColor == ''){
                        await goIntoViewMode();
                    }
                    const receivedData = event.data.payload;
                    console.log('customEventShowACC data:', receivedData);
                    loadACCScenario(event.data);
                }

                if (event.data.event === 'customEventShowTFRErrors') {
                    if (document.getElementById('view_mod').style.backgroundColor == ''){
                        await goIntoViewMode();
                    }
                    const receivedData = event.data.payload;
                    console.log('customEventShowTFRErrors data:', receivedData);
                    // load the scenario in init
                    await loadACCScenario(event.data);
                    // color the segments with errors
                    for(let i = 0; i < event.data.payload.errors.length; i++){
                        const reID = event.data.payload.errors[i].reID;
                        const errString = event.data.payload.errors[i].description;

                        roadElementGraph.segments[reID].hasError = true;
                        roadElementGraph.segments[reID].errors = [];
                        roadElementGraph.segments[reID].errors.push(errString);
                    }
                    //roadElementGraph.segments['http://www.disit.org/km4city/resource/OS00000000606RE/1'].line.setStyle({color: 'yellow'})
                    roadElementGraph.draw();
                }
            }, false);

            

            //init list
            async function getInits() {
                console.log("GET INITS FUNCTION");

                $('#road_types').prop('disabled', true);
                $('#view_mod').prop('disabled', true);
                $('#edit_lines').prop('disabled', true);

                //debugger; // Execution will pause here if DevTools are open
                // Ottieni l'ID del radio button selezionato
                var selectedId = $(this).attr("id");
                console.log('change: ' + selectedId);
                // Determina il tipo di scenario in base all'ID
                var scenarioType = "All";
                // Nascondi la lista degli scenari se il tipo non è "ACC"
                $(".scenario-list-row").hide();
                $("#scenario-init-list").empty();
                $(".scenario-tdm-row").hide();
                document.getElementById("scenario-init-row").style.display = "block";

                document.getElementById("scenario-init-list").disabled = true;
                document.getElementById("scenario-version-list").disabled = true;

                var initScenarios = await getScenarios(scenarioType);
                var scenarioInitList = $("#scenario-init-list");
                // var searchInput = $("#search-scenario-init");
                // searchInput.on("input", function () {
                //     var searchTerm = $(this).val().toLowerCase();
                //     filterScenarios(initScenarios, searchTerm);
                // });

                scenarioInitList.empty();
                initScenarios = [...new Set(initScenarios)];
                initScenarios.sort();
                initScenarios.forEach(scenario => {
                    var optionValue = scenario.replace("deviceName", "");
                    var optionText = optionValue;
                    var listItem = $("<option>").val(scenario).text(optionText);
                    scenarioInitList.append(listItem);
                });

                var urlTTT = "<?= $mainsuperservicemap; ?>" + "/iot-search/?selection=43.769;11.25&maxDists=1000&model=TTT-Model&maxResults=1000";
                var Traffic_sensor_API = "<?= $mainsuperservicemap; ?>" + "/iot-search/?selection=43.769;11.25&maxDists=1000&model=metrotrafficsensor&maxResults=1000";
                
                console.log(urlTTT);
                const header = {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Authorization": `Bearer ${lAccessToken}`
                };

                const responseTTT = fetch(urlTTT, { // oppure metti urlencoded
                    method: "GET",
                    headers: header
                }).then(response => {
                    if (!response.ok) {
                        throw new Error('Errore nella richiesta');
                    }
                    return response.json();
                }).then(data => {
                    // Gestisci la risposta JSON
                    if (data.fullCount > 0) {
                        for (var r = 0; r < data.fullCount; r++) {
                            var prop = data.features[r].properties;
                            arrayTrafficDensity[r] = prop.deviceName;
                        }
                    }
                }).catch(error => {
                    console.error('Errore:', error);
                });

                //arrayTrafficSensors
                const responseTS = fetch(Traffic_sensor_API, { // oppure metti urlencoded
                    method: "GET",
                    headers: header
                }).then(response => {
                    if (!response.ok) {
                        throw new Error('Errore nella richiesta');
                    }
                    return response.json();
                }).then(data => {
                    // Gestisci la risposta JSON
                    var serv = data;
                    if (serv.fullCount > 0) {
                        for (var r = 0; r < serv.fullCount; r++) {
                            var prop = serv.features[r].properties;
                            arrayTrafficSensors[r] = prop.deviceName;
                        }
                    }
                }).catch(error => {
                    console.error('Errore:', error);
                });

                await getScenarioDates($('#scenario-init-list').val(), $('#scenario-version-list'), 'init');
                
                document.getElementById("scenario-init-list").disabled = false;
                document.getElementById("scenario-version-list").disabled = false;

                ////////SELECT EVENT
                $('#scenario-init-list').change( () => {
                    console.log("SELECTED OPTION: " + $('#scenario-init-list').val());
                    getScenarioDates($('#scenario-init-list').val(), $('#scenario-version-list'), 'init');
                });
                
                //SELECT ACC
                $('#scenario-list').change(function () {
                    getScenarioDates($('#scenario-list').val(), $('#acc-list'), 'acc');
                    // var selectedOption = $(this).val();
                    // console.log("Selected option: " + selectedOption);
                    // var suri = "<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + selectedOption;
                    // var url = "<?= $endprocessloader; ?>" + `getOneSpecific.php?suri=${suri}&accessToken=${lAccessToken}`;
                    // $('#acc-list').empty();
                    // $.ajax({
                    //     type: 'GET',
                    //     url: url,
                    //     dataType: "json",
                    //     data: { 'accessToken': lAccessToken },
                    //     contentType: 'application/json; charset=utf-8',
                    //     headers: { 'Authorization': `Bearer ${lAccessToken}` },
                    //     async: false,
                    //     success: function (data) {
                    //         console.log(data);
                    //         // scenario-version-list
                    //         var obj = (data);
                    //         for (var i = 0; i < obj.length; i++) {
                    //             if (obj[i].data) {
                    //                 var acc1 = JSON.parse(obj[i].data);
                    //                 if ((acc1.AC) || (acc1.grandidati.AC)) {
                    //                     console.log('AC', acc1.AC);
                    //                     $('#acc-list').append(`<option value='` + obj[i].data + `'>` + obj[i].dateObserved + `</option>`);
                    //                 }
                    //             }
                    //         }
                    //     }
                    // });
                });

                //SELECT TDM
                $('#scenario-tdm-list').change(function () {
                    getScenarioDates($('#scenario-tdm-list').val(), $('#tdm-list'), 'tdm');
                    // var selectedOption = $(this).val();
                    // console.log("Selected option: " + selectedOption);
                    // var suri = "<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + selectedOption;
                    // var url = "<?= $endprocessloader; ?>" + `getOneSpecific.php?suri=${suri}`;
                    // $('#tdm-list').empty();
                    // $.ajax({
                    //     type: 'GET',
                    //     url: url,
                    //     dataType: "json",
                    //     data: { 'accessToken': lAccessToken },
                    //     contentType: 'application/json; charset=utf-8',
                    //     headers: { 'Authorization': `Bearer ${lAccessToken}` },
                    //     async: false,
                    //     success: function (data) {
                    //         console.log(data);
                    //         // scenario-version-list
                    //         var obj = (data);
                    //         for (var i = 0; i < obj.length; i++) {
                    //             if (obj[i].data) {
                    //                 var tdm1 = JSON.parse(obj[i].data);
                    //                 if (tdm1.grandidati) {
                    //                     console.log(tdm1.grandidati);
                    //                     var gd = tdm1.grandidati;
                    //                     if ((gd.TDM)) {
                    //                         console.log('TDM', gd.TDM);
                    //                         $('#tdm-list').append(`<option value='` + obj[i].data + `'>` + obj[i].dateObserved + `</option>`);
                    //                     } else {
                    //                         console.log('no TDM');
                    //                     }
                    //                 }
                    //             }
                    //         }
                    //     }
                    // });
                });


                function filterScenarios(scenarios, searchTerm) {
                    var scenarioInitList = $("#scenario-init-list");
                    scenarioInitList.empty();

                    scenarios.forEach(scenario => {
                        // Modificato il confronto per verificare se il termine di ricerca è incluso nel testo del paragrafo
                        if (scenario.toLowerCase().includes(searchTerm)) {
                            var optionValue = scenario.replace("deviceName", "");
                            //var optionText = optionValue + " -> " + scenario;
                            var optionText = optionValue;
                            var listItem = $("<option>").val(scenario).text(optionText);
                            scenarioInitList.append(listItem);
                        }
                    });
                }

                if (scenarioType) {
                    console.log("Scenario type selected: " + scenarioType);
                    // Esegui qui le azioni specifiche in base al tipo di scenario
                } else {
                    console.error("Errore nel determinare il tipo di scenario.");
                }


                $('.checkRoadType').click(function () {
                    console.log('Click 1');
                    //
                    if (saveLoadGraph.length > 0) {
                        roadElementGraph.reset();
                        roadElementGraph.loadGraph(saveLoadGraph);
                    }
                    
                    var checkboxes = document.querySelectorAll('.checkRoadType:checked');
                    var selectedRoadTypes = [];
                    var filtraSensors = [];
                    checkboxes.forEach(function (checkbox) {
                        if (checkbox.checked) {
                            selectedRoadTypes.push(checkbox.value);

                        }
                    });
                    //
                    selectedRoadTypes.forEach(function (value) {
                        var filtered = istanzedeisensorichestoconsiderando.filter(sensor => sensor.tipo_del_sensore_in_base_alla_strada === value);
                        filtraSensors = filtraSensors.concat(filtered);
                    });

                    // per non far sparire i sensori che hanno tipo della strada "" li metto qui
                    let metro_sensors = istanzedeisensorichestoconsiderando.filter(sensor => sensor.idSensor === sensor.sensorUri);
                    // e poi li rimetto nei filtraSensors
                    if (selectedRoadTypes.length > 0) {
                        metro_sensors.forEach(sensor => {
                            filtraSensors.push(sensor);
                        });
                    }
                    //
                    roadElementGraph.filterTypes = selectedRoadTypes;
                    roadElementGraph.draw();
                    //
                    let newFilterList = istanzedeisensorichestoconsiderando.filter(item => !filtraSensors.includes(item));
                    //
                    newFilterList.forEach(function (sersorToOff) {
                        sersorToOff.turnOff();
                    });
                    filtraSensors.forEach(function (sersorToOn) {
                        sersorToOn.turnOn();
                    });
                    /////ELIMINARE O RICREARE I SENSORI////
                    $("#SelectNoRoad").prop("checked", false);
                    $("#selectAllRoad").prop("checked", false);
                });

                $('#selectAllRoad').click(function () {
                    $(".checkRoadType").prop("checked", true);
                    $("#SelectNoRoad").prop("checked", false);
                    var checkboxes = document.querySelectorAll('.checkRoadType:checked');
                    var selectedRoadTypes = [];
                    var filtraSensors = [];
                    checkboxes.forEach(function (checkbox) {
                        if (checkbox.checked) {
                            selectedRoadTypes.push(checkbox.value);
                        }
                    });

                    if (saveLoadGraph.length > 0) {
                        roadElementGraph.reset();
                        roadElementGraph.loadGraph(saveLoadGraph);
                    }
                    
                    roadElementGraph.filterTypes = selectedRoadTypes;
                    roadElementGraph.draw();
                    //
                    istanzedeisensorichestoconsiderando.forEach(function (sersorToOn) {
                        sersorToOn.turnOn();
                    });
                    console.log('All On', istanzedeisensorichestoconsiderando);
                    //
                });

                $('#SelectNoRoad').click(function () {
                    $(".checkRoadType").prop("checked", false);
                    $("#selectAllRoad").prop("checked", false);
                    var checkboxes = document.querySelectorAll('.checkRoadType:checked');
                    var selectedRoadTypes = [];
                    var filtraSensors = [];
                    checkboxes.forEach(function (checkbox) {
                        if (checkbox.checked) {
                            selectedRoadTypes.push(checkbox.value);
                        }
                    });
                    roadElementGraph.filterTypes = selectedRoadTypes;
                    roadElementGraph.draw();
                    //
                    istanzedeisensorichestoconsiderando.forEach(function (sersorToOff) {
                        sersorToOff.turnOff();
                    });
                    console.log('All Off', istanzedeisensorichestoconsiderando);
                    //
                });

                // $('#road_types').prop('disabled', false);
                $('#view_mod').prop('disabled', false);
                $('#edit_lines').prop('disabled', false);
                if(roadElementGraph && currentLoadedStatus=='init'){
                    $('#road_types').prop('disabled', false);
                }

            };
            //

            //load Accorped Scenario
            async function loadACCScenario(data = null) {
                console.log('Load Acc Scenario by function');
                var buttonToRemove = document.getElementById("scenario-save-finale1");
                pulisciTutto();
                //LOADING METADATA
                await getLAccessToken();

                if(data != null){
                    ildevicename = 'deviceName' + data.payload.deviceName;
                    console.log('ildevicename', ildevicename);
                    currentLoadedScenario = ildevicename;

                    currentLoadedDate = data.payload.datetime; //local datetime got from the form of the scenairo interface
                    currentLoadedDate = new Date(currentLoadedDate).toISOString(); // convert datetime to GTM/UTC ISOString
                } else {
                    ildevicename = $("#scenario-list").val();
                    console.log('ildevicename', ildevicename);
                    currentLoadedScenario = ildevicename;

                    currentLoadedDate = $('#acc-list option:selected').text().replace(" ", "T"); //local datetime got from the form of the scenairo interface
                    currentLoadedDate = new Date(currentLoadedDate).toISOString(); // convert datetime to GTM/UTC ISOString
                }

                currentLoadedStatus = "acc";
                console.log('currentLoadedScenario', currentLoadedScenario);
                try {
                    let datidalsensore = await readFromDevice(lAccessToken, ildevicename, currentLoadedDate);
                    questofather = datidalsensore.realtime.results.bindings[0].fatherDateObserved;
                    questofather = (questofather === undefined) ? 'not present' : questofather; // se è non definito lo metti not present
                    let lostatus = datidalsensore.realtime.results.bindings[0].status.value;
                    if (lostatus == "acc") {
                        showNotification("Successfully loaded!");
                    } else if (lostatus == "tfr") {
                        showNotification("tdm yet defined");
                    }

                    // DRAW SHAPE
                    console.dir(datidalsensore);
                    var shape = JSON.parse(datidalsensore.realtime.results.bindings[0].areaOfInterest.value).scenarioareaOfInterest;
                    //
                    var arrayShape = shape[0].geometry.coordinates[0];
                    var minY = arrayShape[0][1];
                    var minX = arrayShape[0][0];
                    var maxY = arrayShape[0][1];
                    var maxX = arrayShape[0][0];
                    for (let coord of arrayShape) {
                        if (coord[1] < minY) {
                            minY = coord[1]
                        }
                        if (coord[0] < minX) {
                            minX = coord[0]
                        }
                        if (coord[1] > maxY) {
                            maxY = coord[1]
                        }
                        if (coord[0] > maxX) {
                            maxX = coord[0]
                        }
                    }
                    //
                    scenaryData = new L.geoJSON();
                    scenaryData.type = "FeatureCollection";
                    scenaryData.features = shape;
                    //
                    console.log('scenaryData.feature: ', scenaryData.features);
                    
                    //load sensors
                    var otherSensors_load = "";
                    if (datidalsensore.realtime.results.bindings[0].otherSensors !== undefined) {
                        otherSensors_load = datidalsensore.realtime.results.bindings[0].otherSensors.value
                        otherSensors_load = otherSensors_load.slice(1, -1);
                        var arrayURL = otherSensors_load.split(", ");
                        scenaryOtherSensors = arrayURL;
                        if (scenaryOtherSensors.length > 0) {
                            //CARICAMENTO DATI
                            var suri = scenaryOtherSensors;
                            loadScenarioSensor(suri);                                              
                        }
                    }
                    //
                    function coordinateOrder(array) {
                        return array.map(function (coordinate) {
                            return [coordinate[1], coordinate[0]]; // Inverti l'ordine da [latitudine, longitudine] a [longitudine, latitudine]
                        });
                    }
                    //
                    var arrayshape2 = coordinateOrder(arrayShape);
                    var polygon = L.polygon(arrayshape2);
                    console.log('polygon', arrayshape2);
                    scenaryDrawnItems = new L.FeatureGroup();
                    layer = polygon;
                    scenaryData.features.push(shape);
                    scenaryDrawnItems.addLayer(layer);
                    map.defaultMapRef.addLayer(scenaryDrawnItems);
                    console.log('shape4', shape);

                    const polygonWKT = getPolygonWKTFromScenarioArea(shape);
                    //svoltesparqlquery = buildSparqlQueryURLsvolte(polygonWKT);
                    //let ressvolte = fetchSparqlDataSvolte(svoltesparqlquery);
                    //console.log('ressvolte:', ressvolte);
                    
                    //qui devo prendere l'AC e il JS20 adesso dal db non più dal device
                    let resDalDB = await getDataFromDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + ildevicename);                    

                    console.dir('resDalDB', resDalDB);
                    let tmpRDGraph = '';
                    let tmpAcData = '';
                    var total_resDalDB = resDalDB.length;

                    //FILTRARE I RISULTATI SULLA BASE DEL DATE OBSERVED
                    var version = currentLoadedDate.split('.')[0].replace('T', ' '); //$('#acc-list option:selected').text();
                    for (var i = 0; i < total_resDalDB; i++) {
                        if (resDalDB[i].dateObserved == version) {
                            if (JSON.parse(resDalDB[i].data).grandidati) {
                                //ENRICO: qui è il punto dove trovo i dati nel db della data corretta 
                                loadedAccAC = JSON.parse(resDalDB[i].data).grandidati.AC;
                                loadedAccRoadGraph = JSON.parse(resDalDB[i].data).grandidati.roadGraph;
                                loadedAccFilters = JSON.parse(resDalDB[i].data).grandidati.filters;
                                loadedAccSensors = JSON.parse(resDalDB[i].data).grandidati.sensors;
                                loadedAccRestrictions = JSON.parse(resDalDB[i].data).grandidati.restrictions;
                                loadedAccJS20= JSON.parse(resDalDB[i].data).grandidati.JS20;                                
                                //

                                tmpRDGraph = JSON.parse(resDalDB[i].data).grandidati.roadGraph;
                                tmpAcData = JSON.parse(resDalDB[i].data).grandidati.AC;
                                // qui mi salvo i riferimentoSensoriAccorpato prendendo gli elementi che hanno un sensore sopra                            
                                riferimentoSensoriAccorpato = []; //svuoto se è rimasto pieno da qualcosa successo prima
                                for (let index = 0; index < tmpAcData.length; index++) {
                                    if([tmpAcData[index]['sensor'][0]]!="0"){
                                        tmpAcData[index]['roadElmSpeedLimit'] = [Math.round(tmpAcData[index]['vmax'][0]/0.2777)];
                                        riferimentoSensoriAccorpato.push(tmpAcData[index]);
                                    }
                                }
                                acData = JSON.parse(resDalDB[i].data).grandidati.AC;
                                js20Data = JSON.parse(resDalDB[i].data).grandidati.JS20;
                                console.log('tmpAcData', tmpAcData);

                                

                                tmpAcData.forEach(obj => {
                                    for (let key in obj) {
                                        if (Array.isArray(obj[key])) {
                                            obj[key] = obj[key][0];
                                        }
                                    }
                                });

                                // collini x Sviluppo -> Assegna a random il 10% dei segmenti la proprietà 'notOptimizable'
                                /*tmpAcData.forEach(obj => {
                                    if (Math.random() < 0.1) {  // 10% probabilità
                                        obj.notOptimizable = true;  // Questo segmento non è ottimizzabile
                                    } else {
                                        obj.notOptimizable = false; // Questo segmento è ottimizzabile
                                    }
                                });*/
                                // collini: gestisco il caso mi arrivi accorpato da R senza valori per gli non ottimizzabili
                                tmpAcData.forEach(obj => {
                                    // Se la proprietà 'notOptimizable' non è definita, la imposta a false
                                    if (obj.notOptimizable === undefined) {
                                        obj.notOptimizable = false;
                                    }
                                });

                                // ENRICO: aggiusto le lanes e roadElemSpeedLimit per visualizzazione dell'accorpato di questi parametri
                                for (let index = 0; index < tmpAcData.length; index++) {
                                    if (tmpAcData[index]['sensor'] == '0') {
                                        tmpAcData[index]['lanes'] = tmpAcData[index]['lanes'][1][0];
                                        tmpAcData[index]['roadElmSpeedLimit'] = Math.round(tmpAcData[index]['vmax']/0.2777);
                                    }
                                }

                                //
                            } else {
                                let tmpRDGraph = JSON.parse(resDalDB[i].data).roadGraph;
                                tmpAcData = JSON.parse(resDalDB[i].data).AC;
                                acData = JSON.parse(resDalDB[i].data).AC;
                                js20Data = JSON.parse(resDalDB[i].data).JS20;
                                //
                                for (let key in tmpAcData) {
                                    if (Array.isArray(tmpAcData[key])) {
                                        tmpAcData[key] = tmpAcData[key][0];
                                    }
                                }
                                //
                                console.log('tmpAcData', tmpAcData);
                            }

                        }
                    }

                    loadedtmpAcData = tmpAcData;
                    loadedAcData = acData;
                    loadedjs20Data = js20Data;
                    loadtmpRDGraph = tmpRDGraph;
                    //
                    loadingboxloaded = true;
                    const roadGraph = JSON.parse(resDalDB[0].data).grandidati.AC;
                    const sparqlQueryottimizzata = buildSparqlQueryURLottimizzata(maxY, maxX, minY, minX);
                    fetchSparqlData(null, null, polygonWKT, tmpAcData, null, 'load');
                    //END CREATION NEW SCHEMA
                } catch (error) {
                    console.error("An error occurred:", error.message);
                }
            }

            //load Scenario
            async function loadScenario() {
                var scenarioLoad = $('#scenario-init-list').val();
                pulisciTutto();
                
                console.log('load scenario function: ' + scenarioLoad);
                currentLoadedScenario = scenarioLoad;

                currentLoadedDate = $('#scenario-version-list option:selected').text().replace(" ", "T"); //local datetime got from the form of the scenairo interface
                currentLoadedDate = new Date(currentLoadedDate).toISOString(); // convert datetime to GTM/UTC ISOString

                currentLoadedVersion = $('#scenario-version-list').prop('selectedIndex');
                currentLoadedStatus = "init";
                console.log('selectedIndex:', currentLoadedVersion);
                ////
                /////ADDING A LOADING BOX////////////
                const loadingBox = document.createElement("div");
                loadingBox.id = "loading-box";
                loadingBox.style.position = "absolute";
                loadingBox.style.top = "20%";
                loadingBox.style.left = "50%";
                loadingBox.style.transform = "translate(-50%, -50%)";
                loadingBox.style.backgroundColor = "#fff";
                loadingBox.style.border = "1px solid #ccc";
                loadingBox.style.padding = "20px";
                loadingBox.style.boxShadow = "0 0 10px rgba(0, 0, 0, 0.2)";
                loadingBox.style.zIndex = "9999";
                loadingBox.innerHTML = '<p style="color: black";>The road graph is loading...</p>';
                loadingBox.style.display = "block";
                loadingboxloaded = false;
                //////////END ADDING LOADING BOX//////////

                //var selectScenario = $('#search-scenario-init').val();
                var selectScenario = $('#scenario-init-list').val();
                getLAccessToken();
                ildevicename = $("#scenario-list").val();
                try {
                    let datidalsensore = await readFromDevice(lAccessToken, selectScenario, currentLoadedDate);
                    console.dir('datidalsensore', datidalsensore);
                    var shape = JSON.parse(datidalsensore.realtime.results.bindings[0].areaOfInterest.value).scenarioareaOfInterest;
                    //
                    var arrayShape = shape[0].geometry.coordinates[0];
                    var minY = arrayShape[0][1];
                    var minX = arrayShape[0][0];
                    var maxY = arrayShape[0][1];
                    var maxX = arrayShape[0][0];
                    for (let coord of arrayShape) {
                        if (coord[1] < minY) {
                            minY = coord[1]
                        }
                        if (coord[0] < minX) {
                            minX = coord[0]
                        }
                        if (coord[1] > maxY) {
                            maxY = coord[1]
                        }
                        if (coord[0] > maxX) {
                            maxX = coord[0]
                        }
                    }
                    //
                    scenaryData = new L.geoJSON();
                    scenaryData.type = "FeatureCollection";
                    scenaryData.features = shape;
                    //
                    console.log('scenaryData.feature: ', scenaryData.features);
                    ///////////load sensors
                    var otherSensors_load = "";
                    if (datidalsensore.realtime.results.bindings[0].otherSensors !== undefined) {
                        otherSensors_load = datidalsensore.realtime.results.bindings[0].otherSensors.value
                        //console.log('otherSensors_load',otherSensors_load);
                        otherSensors_load = otherSensors_load.slice(1, -1);
                        var arrayURL = otherSensors_load.split(", ");
                        scenaryOtherSensors = arrayURL;
                        //console.log(scenaryOtherSensors);
                        if (scenaryOtherSensors.length > 0) {
                            //CARICAMENTO DATI
                            var suri = scenaryOtherSensors;
                            loadScenarioSensor(suri);
                            ////                                              
                        }

                    }
                    //
                    var trafficSensorList_load = "";

                    function coordinateOrder(array) {
                        return array.map(function (coordinate) {
                            return [coordinate[1], coordinate[0]];  // Inverti l'ordine da [latitudine, longitudine] a [longitudine, latitudine]
                        });
                    }
                    //
                    var arrayshape2 = coordinateOrder(arrayShape);
                    var polygon = L.polygon(arrayshape2);
                    console.log('polygon', arrayshape2);
                    //
                    scenaryDrawnItems = new L.FeatureGroup();
                    //scenaryDrawnItems.push(polygon);
                    layer = polygon;
                    scenaryData.features.push(shape);
                    scenaryDrawnItems.addLayer(layer);
                    map.defaultMapRef.addLayer(scenaryDrawnItems);
                    //console.log('scenaryDrawnItems',scenaryDrawnItems);
                    //
                    console.log('shape1', shape);
                    //
                    const polygonWKT = getPolygonWKTFromScenarioArea(shape);
                    
                    
                    // svoltesparqlquery = buildSparqlQueryURLsvolte(polygonWKT);
                    // //console.log(svoltesparqlquery)
                    // let ressvolte = fetchSparqlDataSvolte(svoltesparqlquery);
                    
                    var roadGraph = '';                    
                    var filters = '';
                    var sensors = [];

                    // Data from DB is fetched during the creation of the datetime list ('#scenario-version-list') 
                    // and appended in the <option> tag in the value field. Then the value field is red,
                    // parsed as a JSON as saved in the selectedVersion variable
                    var version = $('#scenario-version-list').val();
                    var selectedVersion = JSON.parse(version);
                    console.log('version', selectedVersion);
                    if ((selectedVersion !== '') && (selectedVersion != null)) {
                        if (selectedVersion.grandidati.filters) {
                            filters = selectedVersion.grandidati.filters;
                        }
                        roadGraph = selectedVersion.grandidati.roadGraph;
                        console.log('filters;   ', filters);
                        if (selectedVersion.grandidati.sensors) {
                            sensors = selectedVersion.grandidati.sensors;
                            console.log('Sensors from DB: ', sensors);
                        }
                        if (selectedVersion.grandidati.restrictions){
                            restriction_data = selectedVersion.grandidati.restrictions;
                        }
                    } else {
                        // since DB data are already fetched when creating the datetime list, 
                        // the flow should not enter in this block of code
                        let resDalDB = await getDataFromDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + selectScenario);
                        console.dir(resDalDB);
                        var l = resDalDB.length;
                        console.log(l);
                        roadGraph = JSON.parse(resDalDB[l - 1].data).grandidati.roadGraph;
                        if (JSON.parse(resDalDB[l - 1].data).grandidati.filters) {
                            filters = JSON.parse(resDalDB[l - 1].data).grandidati.filters;
                        }
                        if (JSON.parse(resDalDB[l - 1].data).grandidati.sensors) {
                            sensors = JSON.parse(resDalDB[l - 1].data).grandidati.sensors;
                        }
                        if (JSON.parse(resDalDB[l - 1].data).grandidati.restrictions){
                            restriction_data = JSON.parse(resDalDB[l - 1].data).grandidati.restrictions;
                        }

                    }

                    //Set Checkbox
                    const checkboxes = document.querySelectorAll('.checkRoadType');
                    const checkedValues = filters;
                    trafficSensorList_load_list = sensors;
                    if (sensors.length > 0) {
                        for (i = 0; i < sensors.length; i++) {
                            var point = sensors[i];

                            var nearestRoad = point.nearestRoad.type;
                            console.log('nearestRoad', nearestRoad);
                            if (point.tipo_del_sensore_in_base_alla_strada) {
                                nearestRoad = point.tipo_del_sensore_in_base_alla_strada;
                            }
                            var directionRoad = '';
                            if (point.direction) {
                                directionRoad = point.direction;
                            }                            
                            console.log('directionRoad', directionRoad);
                            var trafficDensityLoad = point.trafficDensity;
                            var trafficSensorLoad = point.trafficSensor;
                            console.log('nearestRoad v2', nearestRoad);
                            var nearestRoadStatus = '';
                            var point_idSensor = '';
                            var point_considered = '';
                            if (point.status) {
                                nearestRoadStatus = point.status;
                            }

                            if (point.idSensor) {
                                point_idSensor = point.idSensor;
                            }

                            if (point.considered) {
                                point_considered = point.considered;
                            }
                            if (point.assignedRoadElement){
                                point_assignedRoadElement = point.assignedRoadElement;
                            }
                            console.log('point:', point);

                            try {
                                const ilSensore0 = new IlSensore(point.sensorUri, [point.coordinates[0], point.coordinates[1]], point.virtual, trafficDensityLoad, trafficSensorLoad, directionRoad, nearestRoad, nearestRoadStatus, point_idSensor, point_considered, point_assignedRoadElement);
                                istanzedeisensorichestoconsiderando.push(ilSensore0);
                                scenaryMarkers.addLayer(ilSensore0.marker);
                                if (ilSensore0.status == 'off') {
                                    ilSensore0.turnOff();
                                } else {
                                    ilSensore0.turnOn();
                                }
                            } catch (error) {
                                console.error("Error fetching sensor data:", error);
                            }
                        }
                    } 
                    // else { // OBSOLETO 
                    //     //
                    //     if (datidalsensore.realtime.results.bindings[0].trafficSensorList !== undefined) {
                    //         trafficSensorList_load = datidalsensore.realtime.results.bindings[0].trafficSensorList.value;

                    //         var arrayURL2 = JSON.parse(trafficSensorList_load);
                    //         trafficSensorList_load_list = arrayURL2.modified_scenario_data_sensors;
                    //         console.log(trafficSensorList_load_list);
                    //         if (trafficSensorList_load.length > 0) {
                    //             //CARICAMENTO DATI
                    //             var array_ts = [];
                    //             for (i = 0; i < trafficSensorList_load_list.length; i++) {
                    //                 var point = trafficSensorList_load_list[i];
                    //                 console.log('point', point);
                    //                 try {
                    //                     console.log('ilSensore');
                    //                     const ilSensore1 = new IlSensore(point.sensorUri, [point.coordinates[0], point.coordinates[1]], true, '', '', point.direction, point.tipo_del_sensore_in_base_alla_strada, point.status);
                    //                     console.log(ilSensore1);
                    //                     istanzedeisensorichestoconsiderando.push(ilSensore1);
                    //                     scenaryMarkers.addLayer(ilSensore1.marker);
                    //                     //////////
                    //                 } catch (error) {
                    //                     console.error("Error fetching sensor data:", error);
                    //                 }
                    //             }
                    //             ////                                              
                    //         } else {
                    //             console.log('NOT FOUND trafficSensors');
                    //         }

                    //     } else {
                    //         console.log('trafficSensors UNDEFINED');
                    //     }
                    //     //
                    //     //NED ELSE
                    // }
                    ////////
                    console.log('istanzedeisensorichestoconsiderando', istanzedeisensorichestoconsiderando);
                    console.log('istanzedelgrafochestoconsiderando', istanzedelgrafochestoconsiderando);

                    // Itera su tutte le caselle di controllo
                    console.log('checkedValues: ', checkedValues);
                    if (checkedValues.length > 0) {
                        $('#selectAllRoad').unchecked = true;
                        checkboxes.forEach((checkbox) => {
                            if (checkedValues.includes(checkbox.value)) {
                                checkbox.checked = true;
                            } else {
                                checkbox.checked = false;
                            }
                        });
                        ////
                        var filteredResults = $.grep(roadGraph, function (item) {
                            return $.inArray(item.type, checkedValues) !== -1;
                        });
                        saveLoadGraph = roadGraph;
                        roadGraph = filteredResults;
                        //////
                    }
                    //
                    console.log(roadGraph);
                    const sparqlQueryottimizzata = buildSparqlQueryURLottimizzata(maxY, maxX, minY, minX);
                    fetchSparqlData(null, null, polygonWKT, roadGraph, null, 'load');
                    loadingboxloaded = true;
                    showNotification("Loading Scenario...please wait");
                }
                catch (error) {
                    showNotification("Error during scenario load");
                    console.error("Error", error)
                }

            }

            //LOAD SCENARY
            $('#scenario-load').click(async function () {
                console.log('LOAD SCENARIO BY FUNCTION');
                loadScenario();
            });

            $('#scenario-check-acc-reaload').click(async function () {
                console.log('CLICK RELOAD');
                pulisciTutto();
                //window.location.reload();
            });

            $('#scenario-init-reload').click(async function () {
                console.log('CLICK REALOD');
                pulisciTutto();
                //window.location.reload();
            });

            //scenario-check-acc1
            $('#scenario-check-acc1').click(async function () {
                loadACCScenario();
            });

            // $('#scenario-check-acc2').click(async function () {
            //     console.log('scenario-check-acc1 NEW');
            //     //
            //     //LOADING METADATA
            //     currentLoadedScenario = $('#scenario-list').val();
            //     // Rimuovi il bottone del save finale se è rimasto pending
            //     var buttonToRemove = document.getElementById("scenario-save-finale1");
            //     pulisciTutto();
            //     await getLAccessToken();
            //     // Ottieni il valore selezionato utilizzando jQuery
            //     ildevicename = $("#scenario-list").val();
            //     console.log('ildevicename', ildevicename);
            //     // Ora puoi utilizzare selectedValue come necessario
            //     try {
            //         let datidalsensore = await readFromDevice(lAccessToken, ildevicename)
            //         let lostatus = datidalsensore.realtime.results.bindings[0].status.value;
            //         if (lostatus == 'init') {
            //             showNotification("status still init and not acc");
            //         } else if (lostatus == "acc" || lostatus == "tfr") {
            //             if (lostatus == "acc") {
            //                 showNotification("Successfully loaded!");
            //             } else if (lostatus == "tfr") {
            //                 showNotification("tfr yet defined");
            //             }

            //             // DRAW SHAPE
            //             let datidalsensore = await readFromDevice(lAccessToken, ildevicename);
            //             console.dir(datidalsensore);
            //             var shape = JSON.parse(datidalsensore.realtime.results.bindings[0].areaOfInterest.value).scenarioareaOfInterest;
            //             //
            //             var arrayShape = shape[0].geometry.coordinates[0];
            //             var minY = arrayShape[0][1];
            //             var minX = arrayShape[0][0];
            //             var maxY = arrayShape[0][1];
            //             var maxX = arrayShape[0][0];
            //             for (let coord of arrayShape) {
            //                 if (coord[1] < minY) {
            //                     minY = coord[1]
            //                 }
            //                 if (coord[0] < minX) {
            //                     minX = coord[0]
            //                 }
            //                 if (coord[1] > maxY) {
            //                     maxY = coord[1]
            //                 }
            //                 if (coord[0] > maxX) {
            //                     maxX = coord[0]
            //                 }
            //             }
            //             //
            //             scenaryData = new L.geoJSON();
            //             scenaryData.type = "FeatureCollection";
            //             scenaryData.features = shape;
            //             //
            //             console.log('scenaryData.feature: ', scenaryData.features);
            //             ///////////load sensors
            //             var otherSensors_load = "";
            //             if (datidalsensore.realtime.results.bindings[0].otherSensors !== undefined) {
            //                 otherSensors_load = datidalsensore.realtime.results.bindings[0].otherSensors.value;
            //                 otherSensors_load = otherSensors_load.slice(1, -1);
            //                 var arrayURL = otherSensors_load.split(", ");
            //                 scenaryOtherSensors = arrayURL;
            //                 if (scenaryOtherSensors.length > 0) {
            //                     //CARICAMENTO DATI
            //                     var suri = scenaryOtherSensors;
            //                     loadScenarioSensor(suri);                           
            //                 }

            //             }
            //             //
            //             function coordinateOrder(array) {
            //                 return array.map(function (coordinate) {
            //                     return [coordinate[1], coordinate[0]];  // Inverti l'ordine da [latitudine, longitudine] a [longitudine, latitudine]
            //                 });
            //             }
            //             //
            //             var arrayshape2 = coordinateOrder(arrayShape);
            //             var polygon = L.polygon(arrayshape2);
            //             console.log('polygon', arrayshape2);

            //             scenaryDrawnItems = new L.FeatureGroup();
            //             layer = polygon;
            //             scenaryData.features.push(shape);
            //             scenaryDrawnItems.addLayer(layer);
            //             map.defaultMapRef.addLayer(scenaryDrawnItems);
            //             //
            //             console.log('shape4', shape);

            //             const polygonWKT = getPolygonWKTFromScenarioArea(shape);
            //             svoltesparqlquery = buildSparqlQueryURLsvolte(polygonWKT);
            //             let ressvolte = fetchSparqlDataSvolte(svoltesparqlquery);
            //             console.log('ressvolte:', ressvolte);
                        
            //             //qui devo prendere l'AC e il JS20 adesso dal db non più dal device
            //             let resDalDB = await getDataFromDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + ildevicename);
            //             console.dir('resDalDB', resDalDB[0]);
            //             let tmpRDGraph = '';
            //             let tmpAcData = '';

            //             if (JSON.parse(resDalDB[0].data).grandidati) {
            //                 tmpRDGraph = JSON.parse(resDalDB[0].data).grandidati.roadGraph;
            //                 tmpAcData = JSON.parse(resDalDB[0].data).grandidati.AC;
            //                 acData = JSON.parse(resDalDB[0].data).grandidati.AC;
            //                 js20Data = JSON.parse(resDalDB[0].data).grandidati.JS20;
            //                 console.log('tmpAcData', tmpAcData);
                            
            //                 tmpAcData.forEach(obj => {
            //                     for (let key in obj) {
            //                         if (Array.isArray(obj[key])) {
            //                             obj[key] = obj[key][0];
            //                         }
            //                     }
            //                 });

            //                 // ENRICO: aggiusto le lanes e roadElemSpeedLimit per visualizzazione dell'accorpato di questi parametri
            //                 for (let index = 0; index < tmpAcData.length; index++) {
            //                     if (tmpAcData[index]['sensor'] == '0') {
            //                         tmpAcData[index]['lanes'] = tmpAcData[index]['lanes'][1][0];
            //                         tmpAcData[index]['roadElemSpeedLimit'] = tmpAcData[index]['vmax'];
            //                     }
            //                 }
            //             } else {
            //                 let tmpRDGraph = JSON.parse(resDalDB[0].data).roadGraph;
            //                 tmpAcData = JSON.parse(resDalDB[0].data).AC;
            //                 acData = JSON.parse(resDalDB[0].data).AC;
            //                 js20Data = JSON.parse(resDalDB[0].data).JS20;
            //                 //
            //                 for (let key in tmpAcData) {
            //                     if (Array.isArray(tmpAcData[key])) {
            //                         // Assegnare il primo elemento dell'array come nuovo valore della proprietà
            //                         tmpAcData[key] = tmpAcData[key][0];
            //                     }
            //                 }
            //                 //
            //                 console.log('tmpAcData', tmpAcData);
            //             }
            //             //
            //             loadingboxloaded = true;
            //             //CREATION NEW SCHEMA
            //             const roadGraph = JSON.parse(resDalDB[0].data).grandidati.AC;
            //             const sparqlQueryottimizzata = buildSparqlQueryURLottimizzata(maxY, maxX, minY, minX);
            //             fetchSparqlData(null, null, polygonWKT, tmpAcData, ressvolte, 'load');
            //             //END CREATION NEW SCHEMA
                        
            //             $('#scenario-save-finale1').on('click', async function () {
                            
            //                 ildevicenametest = $("#scenario-list").val();
            //                 if (ildevicenametest != ildevicename) {
            //                     showNotification("Device name is no more consistent");
            //                     // Rimuovi il bottone del save finale se è rimasto pending
            //                     var buttonToRemove = document.getElementById("scenario-save-finale1");
            //                     if (buttonToRemove) {
            //                         buttonToRemove.remove();
            //                         isSaveFinalSet = false; // Imposta la variabile a false per indicare che il bottone è stato rimosso
            //                     }
            //                     //rimuovi anche l'AC se è rimasto da uno scenario precedente
            //                     if (scenaryData.features.length >= 0) {
            //                         // Rimuovi i layer dei disegni
            //                         for (const layerId in scenaryDrawnItems._layers) {
            //                             scenaryDrawnItems.removeLayer(scenaryDrawnItems._layers[layerId]);
            //                         }
            //                         scenaryData.features = []; // reinizializzo questa variabile
            //                         // Rimuovi i marker associati
            //                         for (const layerId in scenaryMarkers._layers) {
            //                             const marker = scenaryMarkers._layers[layerId];
            //                             scenaryMarkers.removeLayer(marker);
            //                         }
            //                         // Rimuovi il vecchio grafo
            //                         for (const layerId in scenaryGrafo._layers) {
            //                             const grafo = scenaryGrafo._layers[layerId];
            //                             scenaryGrafo.removeLayer(grafo);
            //                         }
            //                         datidaisensorichestoconsiderando = []; // reinizializzo questa variabile
            //                         istanzedeisensorichestoconsiderando = []; // reinizializzo questa variabile
            //                         istanzedelgrafochestoconsiderando = []; // reinizializzo questa variabile
            //                     }
            //                 } else {
            //                     // codice per aggiungere le svolte
            //                     let areaOfInt = JSON.parse(datidalsensore.realtime.results.bindings[0].areaOfInterest.value);
            //                     ilpolygonWKT = getPolygonWKTFromScenarioArea(areaOfInt.scenarioareaOfInterest);
            //                     svoltesparqlquery = buildSparqlQueryURLsvolte(ilpolygonWKT);
            //                     console.log(svoltesparqlquery)
            //                     let ressvolte = await fetchSparqlDataSvolte(svoltesparqlquery);
            //                     let svolte = ressvolte.results.bindings;
            //                     var listScen = await getLAccessToken();
            //                     if (listScen != undefined) {
            //                         var listScen1 = JSON.parse(listScen);
            //                         if (listScen1.accessToken) {
            //                             lAccessToken = listScen1.accessToken;
            //                         }
            //                     }
            //                     try {
            //                         tdmaato = await sendDataACC(lAccessToken, ildevicename, js20Data, acData, svolte);
            //                         // invio anche i grandi dati al DB
            //                         sendDataToDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + ildevicename,
            //                             {
            //                                 "roadGraph": tmpRDGraph,
            //                                 "AC": tmpAcData,
            //                                 "JS20": js20Data,
            //                                 "TDM": acData
            //                             })
            //                         if (tdmaato == "tdmok") {
            //                             showNotification("Device tdm updated succesfully!");
            //                         } else {
            //                             showNotification("Device tdm error");
            //                         }
            //                     } catch {
            //                         showNotification("Device tdm error");
            //                     }
            //                 }
            //             });     
            //         } else {
            //             console.log("error non gestito")
            //         }
            //     } catch (error) {
            //         console.error("An error occurred:", error.message);
            //     }                                               
            // });

            /////////TDM çLOad
            // $('#scenario-check-tdm').click(async function () {
            //     console.log('scenario-check-tdm NEW');
            //     // Rimuovi il bottone del save finale se è rimasto pending
            //     var buttonToRemove = document.getElementById("scenario-save-finale1");
            //     if (buttonToRemove) {
            //         buttonToRemove.remove();
            //         isSaveFinalSet = false; // Imposta la variabile a false per indicare che il bottone è stato rimosso
            //     }
            //     //rimuovi anche l'AC se è rimasto da uno scenario precedente
            //     if (scenaryData.features.length >= 0) {
            //         // Rimuovi i layer dei disegni
            //         for (const layerId in scenaryDrawnItems._layers) {
            //             scenaryDrawnItems.removeLayer(scenaryDrawnItems._layers[layerId]);
            //         }
            //         scenaryData.features = []; // reinizializzo questa variabile
            //         // Rimuovi i marker associati
            //         for (const layerId in scenaryMarkers._layers) {
            //             const marker = scenaryMarkers._layers[layerId];
            //             scenaryMarkers.removeLayer(marker);
            //         }
            //         // Rimuovi il vecchio grafo
            //         for (const layerId in scenaryGrafo._layers) {
            //             const grafo = scenaryGrafo._layers[layerId];
            //             scenaryGrafo.removeLayer(grafo);
            //         }
            //         datidaisensorichestoconsiderando = []; // reinizializzo questa variabile
            //         istanzedeisensorichestoconsiderando = []; // reinizializzo questa variabile
            //         istanzedelgrafochestoconsiderando = []; // reinizializzo questa variabile
            //     }
            //     await getLAccessToken();
            //     ildevicename = $("#scenario-tdm-list").val();
            //     console.log('ildevicename', ildevicename);
            //     // Ora puoi utilizzare selectedValue come necessario
            //     try {
            //         let datidalsensore = await readFromDevice(lAccessToken, ildevicename)
            //         let lostatus = datidalsensore.realtime.results.bindings[0].status.value;
            //         if (lostatus == 'init') {
            //             showNotification("status still init and not acc");
            //         }
            //         else if (lostatus == "acc" || lostatus == "tfr") {
            //             if (lostatus == "tfr") {
            //                 showNotification("Successfully loaded!");
            //             } else if (lostatus == "tfr") {
            //                 showNotification("tfr yet defined");
            //             }

            //             // DRAW SHAPE
            //             let datidalsensore = await readFromDevice(lAccessToken, ildevicename);
            //             console.dir(datidalsensore);
            //             var shape = JSON.parse(datidalsensore.realtime.results.bindings[0].areaOfInterest.value).scenarioareaOfInterest;
            //             //
            //             var arrayShape = shape[0].geometry.coordinates[0];
            //             var minY = arrayShape[0][1];
            //             var minX = arrayShape[0][0];
            //             var maxY = arrayShape[0][1];
            //             var maxX = arrayShape[0][0];
            //             for (let coord of arrayShape) {
            //                 if (coord[1] < minY) {
            //                     minY = coord[1]
            //                 }
            //                 if (coord[0] < minX) {
            //                     minX = coord[0]
            //                 }
            //                 if (coord[1] > maxY) {
            //                     maxY = coord[1]
            //                 }
            //                 if (coord[0] > maxX) {
            //                     maxX = coord[0]
            //                 }
            //             }
            //             //
            //             scenaryData = new L.geoJSON();
            //             scenaryData.type = "FeatureCollection";
            //             scenaryData.features = shape;
            //             //
            //             console.log('scenaryData.feature: ', scenaryData.features);
            //             ///////////load sensors
            //             var otherSensors_load = "";
            //             if (datidalsensore.realtime.results.bindings[0].otherSensors !== undefined) {
            //                 otherSensors_load = datidalsensore.realtime.results.bindings[0].otherSensors.value;
            //                 otherSensors_load = otherSensors_load.slice(1, -1);
            //                 var arrayURL = otherSensors_load.split(", ");
            //                 scenaryOtherSensors = arrayURL;
            //                 if (scenaryOtherSensors.length > 0) {
            //                     var suri = scenaryOtherSensors;
            //                     loadScenarioSensor(suri);                                      
            //                 }
            //             }
            //             //
            //             function coordinateOrder(array) {
            //                 return array.map(function (coordinate) {
            //                     return [coordinate[1], coordinate[0]];  // Inverti l'ordine da [latitudine, longitudine] a [longitudine, latitudine]
            //                 });
            //             }
            //             //
            //             var arrayshape2 = coordinateOrder(arrayShape);
            //             var polygon = L.polygon(arrayshape2);
            //             console.log('polygon', arrayshape2);
            //             //
            //             scenaryDrawnItems = new L.FeatureGroup();
            //             layer = polygon;
            //             scenaryData.features.push(shape);
            //             scenaryDrawnItems.addLayer(layer);
            //             map.defaultMapRef.addLayer(scenaryDrawnItems);
            //             //
            //             console.log('shape5', shape);

            //             const polygonWKT = getPolygonWKTFromScenarioArea(shape);
            //             svoltesparqlquery = buildSparqlQueryURLsvolte(polygonWKT);
            //             let ressvolte = fetchSparqlDataSvolte(svoltesparqlquery);
            //             console.log('ressvolte:', ressvolte);

            //             //qui devo prendere l'AC e il JS20 adesso dal db non più dal device
            //             let resDalDB = await getDataFromDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + ildevicename)
            //             let tmpRDGraph = JSON.parse(resDalDB[0].data).roadGraph;
            //             let tmpAcData = JSON.parse(resDalDB[0].data).TDM;
            //             acData = JSON.parse(resDalDB[0].data).AC;
            //             js20Data = JSON.parse(resDalDB[0].data).JS20;
            //             //
            //             loadingboxloaded = true;
            //             //CREATION NEW SCHEMA
            //             const roadGraph = JSON.parse(resDalDB[0].data).roadGraph;
            //             const sparqlQueryottimizzata = buildSparqlQueryURLottimizzata(maxY, maxX, minY, minX);
            //             fetchSparqlData(null, null, polygonWKT, tmpAcData, ressvolte, 'load');
            //             //END CREATION NEW SCHEMA
            //             //
            //         } else {
            //             console.log("error non gestito")
            //         }
            //     } catch (error) {
            //         console.error("An error occurred:", error.message);
            //     }
            // });

            //######################### EDITING  #######################################//
            $('#showStreetGraph').change(function () {
                if ($(this).is(':checked')) {
                    console.log('is checked');
                    if(roadElementGraph){
                        roadElementGraph.showAll = true;
                        roadElementGraph.draw();
                    }
                } else {
                    console.log('non è checked');
                    if(roadElementGraph){
                        roadElementGraph.showAll = false;
                        roadElementGraph.draw();
                    }
                }
            });

            $('#showTrafficSensors').change(function () {
                var checkedValues = $('.checkRoadType:checked').map(function () {
                    return this.value;
                }).get();

                if ($(this).is(':checked')) {
                    istanzedeisensorichestoconsiderando.forEach(sensor => {
                        if (checkedValues.includes(sensor.tipo_del_sensore_in_base_alla_strada)) {
                            sensor.turnOn();
                        }
                    });
                } else {
                    istanzedeisensorichestoconsiderando.forEach(sensor => {
                        sensor.turnOff();
                    });
                }
            });

            //################ cancel function dei metadati del builder ######################################
            // $("#scenario-cancel").click(function () {
            //     console.log("#scenario-cancel 1")
            //     //
            //     if (saveLoadGraph.length > 0) {
            //         saveLoadGraph = [];
            //     }
            //     //
            //     roadElementGraph.clearSegments();
            //     roadElementGraph.clearNodes();
            //     if (scenaryData.features.length >= 0) {
            //         // Rimuovi i layer dei disegni
            //         for (const layerId in scenaryDrawnItems._layers) {
            //             scenaryDrawnItems.removeLayer(scenaryDrawnItems._layers[layerId]);
            //         }
            //         scenaryData.features = []; // reinizializzo questa variabile
            //         // Rimuovi i marker associati
            //         for (const layerId in scenaryMarkers._layers) {
            //             const marker = scenaryMarkers._layers[layerId];
            //             scenaryMarkers.removeLayer(marker);
            //         }
            //         // Rimuovi il vecchio grafo
            //         for (const layerId in scenaryGrafo._layers) {
            //             const grafo = scenaryGrafo._layers[layerId];
            //             scenaryGrafo.removeLayer(grafo);
            //         }
            //         datidaisensorichestoconsiderando = []; // reinizializzo questa variabile
            //         istanzedeisensorichestoconsiderando = []; // reinizializzo questa variabile
            //         istanzedelgrafochestoconsiderando = []; // reinizializzo questa variabile
            //     }
            //     // qui gestisco il cancel ovvero se l'utente vuole resettare il control panel via
            //     $("#scenario-name").val("");
            //     $("#scenario-location").val("");
            //     $("#scenario-description").val("");
            //     $("#scenario-startDatetime").val("");
            //     $("#scenario-modality").val("generic");
            //     $("#scenario-modality").val("sensors");
            //     $("#scenario-referenceKB").val("");
            //     $("#scenario-endDatetime").val("");
            //     scenaryData = new L.geoJSON();
            //     scenaryData.type = "FeatureCollection";
            //     scenaryData.features = [];
            // });

            //##################### salvo lo scenario ##################################################        
            // $("#scenario-save").click(async function () {
            //     console.error("SAVE SCENARIO 1 [13494]");
            //     console.log("scenario-save cliccato!");
            //     console.log('SAVE 2');
            //     // mi prendo tutti i metadati 
            //     var scenarioareaOfInterest = scenaryData.features[0];
            //     var scenarioName = $("#scenario-name").val();
            //     var scenarioLocation = $("#scenario-location").val();
            //     var scenarioDescription = $("#scenario-description").val();
            //     var scenarioreferenceKB = $("#scenario-referenceKB").val();
            //     var scenarioModality = $("#scenario-modality").val();
            //     var scenariosourceData = $("#scenario-sourceData").val();
            //     var scenarioStartDatetime = $("#scenario-startDatetime").val();
            //     var scenarioEndDatetime = $("#scenario-endDatetime").val();
            //     // per poi controllare se li hanno inseriti a modo oppure no 
            //     if (!scenarioName || !scenarioLocation || !scenarioDescription || !scenarioreferenceKB || !scenarioStartDatetime || !scenarioEndDatetime) {
            //         alert("Please fill in all required fields: Name, Location, Description, KB, Start Datetime, End Datetime.");
            //     } else if (!loadingboxloaded) {
            //         alert("Please Define a shape or wait the loading of the road graph");
            //     } else if (new Date(scenarioStartDatetime) >= new Date(scenarioEndDatetime)) {
            //         alert("Start Datetime must be before End Datetime.");
            //     } else if (scenarioareaOfInterest.length == 0) {
            //         alert("Select an areaOfInterest.");
            //     } else {
            //         // quindi se li hanno messi bene a questo punto riprendo i dati dall'istanzedeisensorichestoconsiderando
            //         // sperando che mantenga lo stato consistente.... Yess lo tiene ;)                            
            //         const sensoriArray = istanzedeisensorichestoconsiderando.map(ilSensore => {
            //             return {
            //                 sensorUri: ilSensore.sensorUri,
            //                 considered: ilSensore.considerato,
            //                 virtual: ilSensore.alContorno,
            //                 coordinates: ilSensore.coordinates,
            //                 tipo_del_sensore_in_base_alla_strada: ilSensore.tipo_del_sensore_in_base_alla_strada,
            //                 status: ilSensore.status,
            //                 direction: ilSensore.direction,
            //             };
            //         });
            //         //associo ad ogni sensore il segment stradale più vicino dato il grafo
            //         const stradeAssegnate = new Set(); // Usato per tenere traccia delle strade già assegnate
            //         // Itera attraverso gli istanzi dei sensori
            //         const sensoriArrayConStradaVicina = sensoriArray.map(sensore => {
            //             // Inizializza delle variabili per tenere traccia della strada più vicina e della sua distanza
            //             let stradaVicina = null;
            //             let distanzaMinima = Infinity;

            //             var jsonIstanze = $('#jsonIstanze').text();
            //             if (jsonIstanze !== '') {
            //                 istanzedelgrafochestoconsiderando = JSON.parse(jsonIstanze);
            //                 console.log('done 1');
            //             } else {
            //                 console.log('Not Modified 1');
            //             }

            //             // Itera attraverso le informazioni della strada per trovare quella più vicina
            //             istanzedelgrafochestoconsiderando.forEach(strada => {
            //                 // Calcola la distanza tra il sensore e il segmento stradale
            //                 const distanza = Math.sqrt(
            //                     Math.pow(sensore.coordinates[1] - strada.nALat, 2) +
            //                     Math.pow(sensore.coordinates[0] - strada.nALong, 2)
            //                 );

            //                 // Se la distanza è minore di quella minima precedentemente registrata e la strada non è già stata assegnata
            //                 if (distanza < distanzaMinima && !stradeAssegnate.has(strada)) {
            //                     distanzaMinima = distanza;
            //                     stradaVicina = strada;
            //                 }
            //             });

            //             // Se abbiamo trovato una strada vicina valida, assegniamola al sensore e aggiungiamola all'array delle strade assegnate
            //             if (stradaVicina) {
            //                 sensore.nearestRoad = stradaVicina;
            //                 stradeAssegnate.add(stradaVicina);
            //             }

            //             // Restituisci l'oggetto del sensore con le informazioni sulla strada più vicina
            //             return sensore;
            //         });
            //         // mi creo lo scenarioData che non è altro che il json di uscita di questo tuul diciamo  
            //         if (enableOtherSensors == 'No') {
            //             scenaryOtherSensors = '';
            //         }
            //         ///

            //         ///
            //         scenarioData = {
            //             "metadata": {
            //                 "dateObserved": new Date().toISOString(),
            //                 "name": ilbrokerdellorganizzazione + "_" + lorganizzazione + "_deviceName" + scenarioName,
            //                 "location": scenarioLocation,
            //                 "description": scenarioDescription,
            //                 "modality": scenarioModality,
            //                 "referenceKB": scenarioreferenceKB,
            //                 "sourceData": scenariosourceData,
            //                 "startTime": scenarioStartDatetime,
            //                 "endTime": scenarioEndDatetime,
            //                 "organization": orgParams['orgId']
            //             },
            //             "shape": {
            //                 "scenarioareaOfInterest": scenarioareaOfInterest
            //             },
            //             "sensors": sensoriArrayConStradaVicina,
            //             "otherSensors": scenaryOtherSensors,
            //             "roadGraph": "istanzedelgrafochestoconsiderando"
            //         };
            //         // mi creo il device sendDataINIT
            //         ilpoly = getPolygonWKTFromScenarioArea(scenarioareaOfInterest);
            //         const coordinates = ilpoly
            //             .match(/\d+\.\d+\s\d+\.\d+/g)
            //             .map(coord => coord.split(' ').map(Number));
            //         // Calcola il centroide
            //         const centroid = coordinates.reduce(
            //             (acc, [lon, lat]) => [acc[0] + lon, acc[1] + lat],
            //             [0, 0]
            //         );
            //         centroid[0] /= coordinates.length;
            //         centroid[1] /= coordinates.length;
            //         var listScen = await getLAccessToken();
            //         if (listScen != undefined) {
            //             var listScen1 = JSON.parse(listScen);
            //             if (listScen1.accessToken) {
            //                 lAccessToken = listScen1.accessToken;
            //             }
            //         }
            //         // includo il codice di Alberto per la creazione del device e invio dati per la versione INIT

            //         adesso = new Date().toISOString();
            //         ildevicename = "deviceName" + scenarioName;
            //         // Usa la funzione showNotification per mostrare un messaggio di successo
            //         creato = await createDevice(lAccessToken, ildevicename, scenarioareaOfInterest[0].geometry, centroid);
            //         if (creato == "ok") {
            //             showNotification("Scenario successfully created!");
            //             try {
            //                 initdatainviati = await sendDataINIT(lAccessToken, ildevicename, scenarioData);
            //                 // gestisco il salvataggio roadGraph nel mysql processloader_db e tabella bigdatafordevice del roadGraph per poi da nodered generare l'AC e JS20                                       
            //                 sendDataToDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + ildevicename, {
            //                     "roadGraph": istanzedelgrafochestoconsiderando
            //                 }).then(data => {
            //                     console.log('Risposta dal server:', data);
            //                 }).catch(error => {
            //                     console.error('Si è verificato un errore:', error);
            //                 });
            //                 // Aggiungi un ritardo di 1 secondo tra le notifiche
            //                 setTimeout(() => {
            //                     //showNotification("E i dati iniziali sono stati inviati con successo!");
            //                 }, 1000);
            //                 // Se entrambe le operazioni sono andate bene, mostra un messaggio di completamento
            //                 setTimeout(() => {
            //                     //showNotification("Ora puoi accorpare da Node-Red e continuare in seguito.");
            //                 }, 2000);
            //             } catch (error) {
            //                 console.error("Error sending initial data:", error);
            //                 showNotification("Error during initial data sending. Try again later.");
            //             }
            //         } else {
            //             console.error("Error during devide reation:", creato);
            //             try {
            //                 initdatainviati = await sendDataINIT(lAccessToken, ildevicename, scenarioData);
            //                 sendDataToDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + ildevicename, istanzedelgrafochestoconsiderando)
            //                     .then(data => {
            //                         console.log('Risposta dal server:', data);
            //                     })
            //                     .catch(error => {
            //                         console.error('Si è verificato un errore:', error);
            //                     });
            //                 if (initdatainviati == "dati_init_si") {
            //                     showNotification("Initial data successfully created");
            //                     // Se entrambe le operazioni sono andate bene, mostra un messaggio di completamento
            //                     setTimeout(() => {
            //                         showNotification("Error during initial data sending. Try again later.");
            //                     }, 1000);
            //                 } else {
            //                     console.error("Errore nell'invio dei dati iniziali:", error);
            //                     showNotification("Error during initial data sending. Try again later.");
            //                 }
            //             } catch (error) {
            //                 console.error("Errore nell'invio dei dati iniziali:", error);
            //                 showNotification("Error during initial data sending. Try again later.");
            //             }
            //         }
            //     }
            // });

            ///BOLOGNA
            $('#updateStreetGraph').click(async function () {

                // WHEN THIS EVENT IS RISEN?
                console.error("IN [$('#updateStreetGraph').click(async function] :: CHECK CODE!");
                debugger;  // Execution will pause here when the developer tools are open
                //////////////////////////// 

                var segment = $('#segment').val();
                var json_list = JSON.parse($('#jsonIstanze').text());
                let streetElement = json_list.find(function (oggetto) {
                    return oggetto.segment === segment;
                });

                var updateType = $('#updateType').val();
                var updateLanes = $('#updateLanes').val();
                var updateSpeedLimit = $('#updateSpeedLimit').val();
                var updateDir = $('#updateDir').val();
                var updateRestriction = $('#updateRestriction').val();
                var stradajson = $('#stradajson').text();
                var strada = JSON.parse(stradajson);

                map.defaultMapRef.removeLayer(scenaryGrafo);
                scenaryGrafo = new L.FeatureGroup();
                map.defaultMapRef.addLayer(scenaryGrafo);
                //
                strada.dir = updateDir;
                strada.type = updateType;
                strada.lanes = updateLanes;
                strada.roadElmSpeedLimit = updateSpeedLimit;
                var strada2 = JSON.stringify(strada);
                //
                var istanzedelgrafochestoconsiderandoJSON = $('#jsonIstanze').text();
                var nuovaStringa = istanzedelgrafochestoconsiderandoJSON.replace(stradajson, strada2);
                $('#stradajson').text(strada2);
                //REFRESH DATA
                istanzedelgrafochestoconsiderando = nuovaStringa;
                
                ///////////BOLOGNA
                // Create the loading box element and add it to the document
                const loadingBox = document.createElement("div");
                const polygonWKT = getPolygonWKTFromScenarioArea(scenaryData.features);
                /////BOLOGNA

                Promise.all([fetchSparqlData(sparqlQueryottimizzata, null, polygonWKT, null, null, 'create')]).then(() => {
                    loadingBox.style.display = "none";
                    loadingboxloaded = true;                     
                    $('#close').click();
                    alert('Updated street data');
                }).catch(error => {
                    // Hide and remove the loading box in case of an error
                    loadingBox.style.display = "none";
                    // mapContainer.removeChild(loadingBox);
                    loadingboxloaded = false;
                    console.error("Error:", error);
                });
            });


            ////BOLOGNA
            //edit-lines
            $("#edit_lines").click(async function () {
                console.log('edit modality');
                console.log('currentLoadedScenario', currentLoadedScenario);
                var devNameLoadScenario = '';
                var locationLoadScenario = '';
                var descriptionLoadScenario = '';
                var referenceLoadScenario = '';
                var starttime = '';
                var endTime = '';
                var trafficSensorList = 'Yes';
                var otherSensors = 'Yes';
                //
                if ((currentLoadedScenario != "") && (currentLoadedScenario != 'undefined')) {
                    devNameLoadScenario = currentLoadedScenario.replace("deviceName", "");
                    var devNameLoadUrl = "<?= $mainsuperservicemap; ?>" + "?serviceUri=" + "<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + `/${currentLoadedScenario}&maxResults=10&fromTime=2023-01-01T00:00:00`;
                    var listScen = await getLAccessToken();
                    if (listScen != undefined) {
                        var listScen1 = JSON.parse(listScen);
                        if (listScen1.accessToken) {
                            lAccessToken = listScen1.accessToken;
                        }
                        console.log('listScen1', listScen1);
                    }
                    const header = {
                        "Content-Type": "application/json",
                        "Accept": "application/json",
                        "Authorization": `Bearer ${lAccessToken}`
                    };
                    try {
                        const response = await fetch(devNameLoadUrl, { // oppure metti urlencoded
                            method: "GET",
                            headers: header
                        });
                        if (!response.ok) {
                            throw new Error(`Error fetching sensor data: ${response.status}`);
                        }
                        const jsonResponse = await response.json();
                        var realtime = jsonResponse.realtime;
                        var bind = realtime.results.bindings;
                        console.log('currentLoadedVersion: ', currentLoadedVersion);

                        if (currentLoadedVersion != '') {
                            console.log('IN');
                            locationLoadScenario = bind[currentLoadedVersion].location.value;
                            referenceLoadScenario = bind[currentLoadedVersion].referenceKB.value;
                            descriptionLoadScenario = bind[currentLoadedVersion].description.value;
                            starttime = bind[currentLoadedVersion].startTime.value;
                            endTime = bind[currentLoadedVersion].endTime.value;
                            //
                            var trafficSensorList0 = bind[currentLoadedVersion].trafficSensorList.value;
                            var otherSensors0 = bind[currentLoadedVersion].otherSensors.value;
                            if (trafficSensorList0.length > 0) {
                                trafficSensorList = 'Yes';
                            } else {
                                trafficSensorList = 'No';
                            }
                            if (otherSensors0.length > 0) {
                                otherSensors = 'Yes';
                            } else {
                                otherSensors = 'No';
                            }
                            //
                        } else {
                            console.log('OUT');
                            locationLoadScenario = bind[0].location.value;
                            referenceLoadScenario = bind[0].referenceKB.value;
                            descriptionLoadScenario = bind[0].description.value;
                            starttime = bind[0].startTime.value;
                            endTime = bind[0].endTime.value;
                        }                   
                    } catch (error) {
                        console.error("Oops: Something Else", error);
                    }
                    console.log('devNameLoadUrl: ', devNameLoadUrl);
                }
                
                if (roadElementGraph)
                    roadElementGraph.mode = 'drag';

                $('#menu-lines').show();
                $('#currentStatusEdit').val('streets');
                var drawControl = document.querySelector('.leaflet-draw');
                if (drawControl) {
                    drawControl.parentNode.removeChild(drawControl);
                    isSaveFinalSet = false;
                }
                //levo il drawer control
                map.defaultMapRef.removeControl(drawerControl);
                // levo anche il grafo
                map.defaultMapRef.removeLayer(scenaryGrafo);
                $("#edit_lines").css('background-color', '#3E64A6');
                $("#edit_lines").css('color', 'white');
                $("#view_mod").css('background-color', '');
                $("#view_mod").css('color', 'black');
                //line_create
                $("#line_create").css('background-color', '');
                $("#line_create").css('color', 'black');
                //line_drag
                $("#line_drag").css('background-color', '');
                $("#line_drag").css('color', 'black');
                //line_split
                $("#line_split").css('background-color', '');
                $("#line_split").css('color', 'black');
                //line_delete
                $("#line_delete").css('background-color', '');
                $("#line_delete").css('color', 'black');
                //db_new
                $('.sensorPopup_view').css('display', 'none');
                $('.sensorPopup_edit').css('display', 'inline');

                // metto subito il layer dei markers                         
                scenaryMarkers = new L.FeatureGroup();
                map.defaultMapRef.addLayer(scenaryMarkers);
                scenaryGrafo = new L.FeatureGroup();
                map.defaultMapRef.addLayer(scenaryGrafo);
                drawerControl2 = new L.Control.Draw({
                    edit: {
                        featureGroup: scenaryDrawnItems,
                        edit: false,
                        remove: false
                    },
                    draw: {
                        circle: false,
                        marker: false,
                        polyline: false,
                        polygon: {
                            allowIntersection: false,
                            showArea: true
                        }
                    }
                });
                map.defaultMapRef.addControl(drawerControl2);

                try {
                    ////
                    if (scenaryData.features.length >= 0) {
                        for (const layerId in scenaryGrafo._layers) {
                            const grafo = scenaryGrafo._layers[layerId];
                            scenaryGrafo.removeLayer(grafo);
                        }

                        var scenarioToRemove = document.getElementById("modality-load");
                        if (scenarioToRemove) {
                            scenarioToRemove.remove();
                            isSaveFinalSet = false;
                        }

                        var scenaryControl2 = L.control({
                            position: 'topright'
                        });

                        var scenarioToRemove = document.getElementById("scenario-edit-form");
                        console.log(scenarioToRemove);
                        
                        //check if logged
                        var loggedUsername = '<?= $_SESSION['loggedUsername'] ?>';
                        console.log('loggedUsername', loggedUsername);
                        var check_save = 'disabled';
                        if ((loggedUsername !== '') && (loggedUsername !== null)) {
                            check_save = '';
                        }

                        if (!scenarioToRemove) {
                            scenaryControl2.onAdd = function (map) {
                                var div2 = L.DomUtil.create('div');
                                div2.id = 'scenario-edit-form';
                                div2.innerHTML = `
                                    <div id="scenario-div">
                                        <div id="notification" style="display: none;">
                                            <p id="notification-message">bells</p>
                                        </div>
                                        <div id="scenario-content">
                                            <div id="complete-content">
                                                <!-- Contenuto per la modalità completa -->
                                                <table>
                                                    <tr>
                                                        <td><label for="scenario-name">Scenario name:</label></td>
                                                        <td><input id="scenario-name" type="text" name="name" placeholder="Scenario name" value="`+ devNameLoadScenario + `"></td>
                                                    </tr>
                                                    <tr>
                                                        <td><label for="scenario-location">Location:</label></td>
                                                        <td><input id="scenario-location" type="text" name="location" value="`+ locationLoadScenario + `" placeholder="Location"></td>
                                                    </tr>
                                                    <tr>
                                                        <td><label for="scenario-description">Scenario description:</label></td>
                                                        <td><input id="scenario-description" type="text" name="description" value="`+ descriptionLoadScenario + `" placeholder="Scenario description"></td>
                                                    </tr>
                                                    <!-- Aggiungi altre righe per i campi -->
                                                    <tr>
                                                        <td><label for="scenario-referenceKB">ReferenceKB:</label></td>
                                                        <td><input id="scenario-referenceKB" type="text" name="SURI of the reference KB" value="`+ referenceLoadScenario + `" placeholder="Reference KB"></td>
                                                    </tr>
                                                    <!--<tr>
                                                        <td><label for="scenario-modality">Modality:</label></td>
                                                        <td>
                                                            <select id="scenario-modality" name="modality">
                                                                <option value="generic">Generic</option>
                                                                <option value="cars">Cars</option>
                                                                <option value="trucks">Trucks</option>
                                                                <option value="buses">Buses</option>
                                                            </select>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td><label for="scenario-sourceData">Source Data:</label></td>
                                                        <td>
                                                            <select id="scenario-sourceData" name="sourceData">
                                                                <option value="sensors">Sensors</option>
                                                                <option value="native">Native</option>
                                                                <option value="Here">Here</option>
                                                            </select>
                                                        </td>
                                                    </tr>-->
                                                    <tr>
                                                        <td><label for="scenario-roadData">Save Road Graph:</label></td>
                                                        <td>
                                                        <select id="scenario-roadData" name="roadData" >
                                                                <option value="Yes">Yes</option>
                                                                <option value="No">No</option>
                                                            </select>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td><label for="scenario-trafficData">Save traffic Sensors:</label></td>
                                                        <td>
                                                        <select id="scenario-trafficData" name="trafficData" value="`+ trafficSensorList + `">
                                                                <option value="Yes">Yes</option>
                                                                <option value="No">No</option>
                                                            </select>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td><label for="scenario-otherData">Save other Sensors:</label></td>
                                                        <td>
                                                            <select id="scenario-otherData" name="otherData" value="`+ otherSensors + `">
                                                                <option value="Yes">Yes</option>
                                                                <option value="No">No</option>
                                                            </select>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td><label for="scenario-startDatetime">From:</label></td>
                                                        <td><input id="scenario-startDatetime" type="datetime-local" name="datetimeFrom" value="`+ starttime + `"></td>
                                                    </tr>
                                                    <tr>
                                                        <td><label for="scenario-endDatetime">To:</label></td>
                                                        <td><input id="scenario-endDatetime" type="datetime-local" name="datetimeTo"  value="`+ endTime + `"></td>
                                                    </tr>
                                                    <tr>
                                                        <td colspan="2">
                                                            <input type="button" id="scenario-save" value="Save" `+ check_save + `/>
                                                            <button id="scenario-summary">Show Summary</button>
                                                            <button id="scenario-cancel" type="button">Cancel</button>
                                                        </td>
                                                    </tr>
                                                </table>
                                            </div>                                        
                                        </div>                                
                                    </div>`;
                                ////
                                // Disabilita l'interazione di questo div con la mappa per evitare conflitti
                                if (L.Browser.touch) {
                                    L.DomEvent.disableClickPropagation(div2);
                                    L.DomEvent.on(div2, 'mousewheel', L.DomEvent.stopPropagation);
                                } else {
                                    L.DomEvent.on(div2, 'click', L.DomEvent.stopPropagation);
                                }
                                return div2;
                                ////
                            }
                        }
                        scenaryControl2.addTo(map.defaultMapRef); // e chiudo con l'inserimento di qusto nella mappa
                        ///

                        $("#scenario-cancel").click(function () {
                            console.log("#scenario-cancel 2")
                            console.log('CLICK ON CANCEL');
                            pulisciTutto();
                        });

                        $('#scenario-summary').click(async function () {
                            //alert('SCENARIO SUMMARY');
                            console.log('istanzedeisensorichestoconsiderando', istanzedeisensorichestoconsiderando);
                            var counts_segments = istanzedelgrafochestoconsiderando.length;
                            console.log('counts_segments', counts_segments);
                            var array_summary = istanzedeisensorichestoconsiderando;
                            const result = array_summary.reduce((acc, obj) => {
                                if (obj.alContorno) {
                                    acc.trueCount += 1;
                                } else {
                                    acc.falseCount += 1;
                                }
                                return acc;
                            }, { trueCount: 0, falseCount: 0 });

                            const resultFlow = array_summary.reduce((acc2, obj) => {
                                if ((obj.direction == "InFlow") && (obj.status == 'on') && (obj.assignedRoadElement !== "")) {
                                    acc2.inflow += 1;
                                } else if ((obj.direction == "OutFlow") && (obj.status == 'on') && (obj.assignedRoadElement !== "")) {
                                    acc2.outflow += 1;
                                } else if ((obj.direction == "Bidirectional") && (obj.status == 'on') && (obj.assignedRoadElement !== "")) {
                                    acc2.Bidimentionalflow += 1;
                                } else if (obj.assignedRoadElement == "") {
                                    acc2.notAssigned += 1;
                                }
                                return acc2;
                            }, { inflow: 0, outflow: 0, Bidimentionalflow: 0, notAssigned: 0 });

                            const elementToRemove = document.getElementById('summary-table');

                            // Remove the element from the DOM 
                            console.log(elementToRemove);
                            if (elementToRemove) {
                                elementToRemove.remove();
                                $('#scenario-summary').text('Show Summary');
                            } else {
                                var scenaryControlSummary = L.control({
                                    position: 'bottomright'
                                });
                                $('#scenario-summary').text('Hide Summary');
                                scenaryControlSummary.onAdd = function (map) {
                                    var div = L.DomUtil.create('div');
                                    //currentStatusEdit MANAGE STATUS//
                                    //
                                    div.id = "summary-table";

                                    div.innerHTML = `
                                        <div id="scenario-summary" style="margin: 10px; background-color: white; color: black">
                                            <div id="scenario-div">
                                                <table>
                                                    <tbody style="margin-right: 5px; margin-left: 5px;">
                                                        <tr>
                                                            <td><b>Inflow sensors: </b></td>
                                                            <td>${resultFlow.inflow}</td>
                                                        </tr>
                                                        <tr>
                                                            <td><b>Outflow sensors: </b></td>
                                                            <td>${resultFlow.outflow}</td>
                                                        </tr>
                                                        <tr>
                                                        <tr>
                                                            <td><b>Bidirectional: </b></td>
                                                            <td>${resultFlow.Bidimentionalflow}</td>
                                                        </tr>
                                                        <tr>
                                                            <td><b>nr. Segments: </b></td>
                                                            <td>${counts_segments}</td>
                                                        </tr>
                                                        <tr>
                                                            <td><b>Real sensors: </b></td>
                                                            <td>${result.falseCount}</td>
                                                        </tr>
                                                        <tr>
                                                            <td><b>Not Assigned sensors: </b></td>
                                                            <td>${resultFlow.notAssigned}</td>
                                                        </tr>
                                                        <tr>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>`;
                                    // Disabilita l'interazione di questo div con la mappa per evitare conflitti
                                    if (L.Browser.touch) {
                                        L.DomEvent.disableClickPropagation(div);
                                        L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
                                    } else {
                                        L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
                                    }
                                    return div;
                                    div.css('display', 'none');
                                };
                                scenaryControlSummary.addTo(map.defaultMapRef); 
                            }
                        });

                        $("#scenario-save").click(async function () {
                            console.log("SAVE SCENARIO 2 [14111] - current status: " + currentLoadedStatus);
                            
                            // get metadata
                            var scenarioareaOfInterest = scenaryData.features;
                            var scenarioName = $("#scenario-name").val();
                            var scenarioLocation = $("#scenario-location").val();
                            var scenarioDescription = $("#scenario-description").val();
                            var scenarioreferenceKB = $("#scenario-referenceKB").val();
                            // var scenarioModality = $("#scenario-modality").val(); // NO USED AT THIS MOMENT
                            // var scenariosourceData = $("#scenario-sourceData").val(); // NO USED AT THIS MOMENT
                            var scenarioStartDatetime = $("#scenario-startDatetime").val();
                            var scenarioEndDatetime = $("#scenario-endDatetime").val();
                            
                            var enableRoadGraph = $('#scenario-roadData').val();
                            var enableTrafficSensors = $('#scenario-trafficData').val();
                            var enableOtherSensors = $('#scenario-otherData').val();
                            
                            var restrictions = null;

                            if (roadElementGraph && restriction_data) {
                                var arrayAlfanumerico = roadElementGraph.segments;
                                var arrayNumerico = Object.keys(arrayAlfanumerico).map((key, index) => {
                                    const obj = arrayAlfanumerico[key];
                                    // Check if the keys exist, then destructure them if they do
                                    const { line, arrow, hasError, errors, ...rest } = {
                                        ...('line' in obj && { line: obj.line }),
                                        ...('arrow' in obj && { arrow: obj.arrow }),
                                        ...('hasError' in obj && { hasError: obj.hasError }),
                                        ...('errors' in obj && { errors: obj.errors }),
                                        ...obj
                                    };
                                    return { ...rest, id: index + 1 };
                                });
                                istanzedelgrafochestoconsiderando = arrayNumerico;

                                //Manage Restrictions
                                restrictions = restriction_data;

                            } else {
                                alert("No road graph in memory");
                                return null;
                            }

                            ///////////
                            console.log('scenarioareaOfInterest', scenarioareaOfInterest);

                            //BOLOGNA SAVING PINS
                            function isPointInPolygon(point, polygon) {
                                var x = point.lat, y = point.lng;
                                
                                var inside = false;
                                
                                // Get the array of latlngs for the polygon
                                var latlngs = polygon.getLatLngs()[0]; // Assuming polygon is simple and not multipolygon
                                
                                // Ray-casting algorithm
                                for (var i = 0, j = latlngs.length - 1; i < latlngs.length; j = i++) {
                                    var xi = latlngs[i].lat, yi = latlngs[i].lng;
                                    var xj = latlngs[j].lat, yj = latlngs[j].lng;

                                    var intersect = ((yi > y) !== (yj > y)) &&
                                                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                                    if (intersect) inside = !inside;
                                }
                                
                                return inside;
                            }

                            var markersInPolygon = [];
                            var shapes = [];
                            //var polygonBounds = scenaryDrawnItems.getBounds();
                            const coords = scenaryData.features[0].geometry.coordinates[0];
                            var coords_latlon = []
                            for(let c = 0; c < coords.length; c++){
                                var tmp = coords[c];
                                coords_latlon.push([tmp[1], tmp[0]]);
                            }
                            const scenaryPolygon = L.polygon(coords_latlon);
                            map.defaultMapRef.eachLayer(function (layer) {
                                if (layer instanceof L.Marker) {
                                    // if (polygonBounds.contains(layer.getLatLng())) {
                                    //     if (layer.feature != undefined) {
                                    //         var item = layer.feature.properties.serviceUri;
                                    //         markersInPolygon.push(item);
                                    //     }
                                    // }
                                    if (isPointInPolygon(layer.getLatLng(), scenaryPolygon)) {
                                        if (layer.feature != undefined) {
                                            var item = layer.feature.properties.serviceUri;
                                            markersInPolygon.push(item);
                                        }
                                    }
                                }
                            });
                            if (markersInPolygon.length > 0) {
                                scenaryOtherSensors = markersInPolygon;
                            }

                            if (!scenarioName || !scenarioLocation || !scenarioDescription || !scenarioreferenceKB || !scenarioStartDatetime || !scenarioEndDatetime) {
                                alert("Please fill in all required fields: Name, Location, Description, KB, Start Datetime, End Datetime.");
                                return null;
                            }
                            if (!loadingboxloaded) {
                                alert("Please Define a shape or wait the loading of the road graph");
                                return null;
                            } 
                            if (new Date(scenarioStartDatetime) >= new Date(scenarioEndDatetime)) {
                                alert("Start Datetime must be before End Datetime.");
                                return null;
                            } 
                            if (scenarioareaOfInterest.length == 0) {
                                alert("Select an areaOfInterest.");
                                return null;
                            } 
                            
                            var sensoriArray = null;
                            if(istanzedeisensorichestoconsiderando){
                                sensoriArray = istanzedeisensorichestoconsiderando.map(ilSensore => {
                                    return {
                                        sensorUri: ilSensore.sensorUri,
                                        considered: ilSensore.considerato,
                                        virtual: ilSensore.alContorno,
                                        coordinates: ilSensore.coordinates,
                                        trafficDensity: ilSensore.trafficDensity,
                                        trafficSensor: ilSensore.trafficSensor,
                                        tipo_del_sensore_in_base_alla_strada: ilSensore.tipo_del_sensore_in_base_alla_strada,
                                        status: ilSensore.status,
                                        direction: ilSensore.direction,
                                        //db_NEW 
                                        assignedRoadElement: ilSensore.assignedRoadElement,
                                        idSensor: ilSensore.idSensor
                                    };
                                });
                            }
                                                        
                            if (enableOtherSensors == 'No') { // TODO check with other sensors
                                scenaryOtherSensors = '';
                            }

                            // TODO: what happns if a sensors is already assigned to a road? (e.g. virtual sensor on the border)
                            const stradeAssegnate = new Set(); // Usato per tenere traccia delle strade già assegnate

                            for(let i = 0; i < sensoriArray.length; i++){
                                if(sensoriArray[i].assignedRoadElement){
                                    const strada = istanzedelgrafochestoconsiderando.find(obj => obj["segment"] === sensoriArray[i].assignedRoadElement);
                                    stradeAssegnate.add(strada);
                                    sensoriArray[i].nearestRoad = strada;
                                }
                            }

                            sensoriArray = sensoriArray.map(sensore => {
                                if(!sensore.nearestRoad){
                                    let stradaVicina = null;
                                    let distanzaMinima = Infinity;
                                    //BOLOGNA                                    
                                    istanzedelgrafochestoconsiderando.forEach(strada => {
                                        const distanza = Math.sqrt(
                                            Math.pow(sensore.coordinates[1] - strada.nALat, 2) +
                                            Math.pow(sensore.coordinates[0] - strada.nALong, 2)
                                        );
                                        // Verifica se la distanza è minore di quella minima precedentemente registrata,
                                        // se la strada non è già stata assegnata e se il tipo di strada è uno dei tipi specificati
                                        if (distanza < distanzaMinima &&
                                            !stradeAssegnate.has(strada) &&
                                            ['primary', 'tertiary', 'residential', 'secondary', 'unclassified'].includes(strada.type)) {
                                            distanzaMinima = distanza;
                                            stradaVicina = strada;
                                        }
                                    });
                                    if (stradaVicina) {
                                        sensore.nearestRoad = stradaVicina;
                                        sensore.assignedRoadElement = stradaVicina.segment;
                                        stradeAssegnate.add(stradaVicina);
                                    }
                                }
                                return sensore;
                            });
                            
                            if (scenaryOtherSensors == "") {
                                scenaryOtherSensors = [];
                                console.log('scenaryOtherSensors modified');
                            } else {
                                console.log(scenaryOtherSensors);
                            }

                            var ilDateObserved = new Date().toISOString();
                            // TODO among those variable which one are really sent to the device?
                            scenarioData = {
                                "metadata": {
                                    "dateObserved": ilDateObserved,
                                    "name": ilbrokerdellorganizzazione + "_" + lorganizzazione + "_deviceName" + scenarioName,
                                    "location": scenarioLocation,
                                    "description": scenarioDescription,
                                    //"modality": scenarioModality, // NO USED AT THIS MOMENT
                                    "referenceKB": scenarioreferenceKB,
                                    //"sourceData": scenariosourceData, // NO USED AT THIS MOMENT
                                    "startTime": scenarioStartDatetime,
                                    "endTime": scenarioEndDatetime,
                                    "enableRoadGraph": enableRoadGraph,
                                    "enableTrafficSensors": enableTrafficSensors,
                                    "enableOtherSensors": enableOtherSensors,
                                    "organization": orgParams['orgId']
                                },
                                "shape": {
                                    "scenarioareaOfInterest": scenarioareaOfInterest
                                },
                                "sensors": sensoriArray,
                                "otherSensors": scenaryOtherSensors, 
                                "roadGraph": "istanzedelgrafochestoconsiderando",  //in prod mettere tra virgolette "istanzedelgrafochestoconsiderando"
                                "filters": '',
                                // "turn": restrictions
                            };
                            //
                            console.log('scenarioData:', scenarioData);
                            //
                            ilpoly = getPolygonWKTFromScenarioArea(scenarioareaOfInterest);
                            const coordinates = ilpoly
                                .match(/\d+\.\d+\s\d+\.\d+/g)
                                .map(coord => coord.split(' ').map(Number));
                            const centroid = coordinates.reduce(
                                (acc, [lon, lat]) => [acc[0] + lon, acc[1] + lat],
                                [0, 0]
                            );
                            centroid[0] /= coordinates.length;
                            centroid[1] /= coordinates.length;
                            
                            var list_filters = [];
                            const checkboxes = document.querySelectorAll('.checkRoadType');
                            checkboxes.forEach((checkbox) => {
                                // Verifica se la casella di controllo è selezionata
                                if (checkbox.checked) {
                                    // Selezionata, aggiungi la casella di controllo all'array
                                    list_filters.push(checkbox.value);
                                }
                            });

                            //
                            var istanzedelgrafochestoconsiderando_forSaving = istanzedelgrafochestoconsiderando;
                            if (enableRoadGraph == 'No') {
                                istanzedelgrafochestoconsiderando_forSaving = [];
                            }
                            //
                            console.log('istanzeSensors:    ', sensoriArray);

                            //await getLAccessToken(); 
                            var listScen = await getLAccessToken();
                            if (listScen != undefined) {
                                var listScen1 = JSON.parse(listScen);
                                if (listScen1.accessToken) {
                                    lAccessToken = listScen1.accessToken;
                                }
                            }
                            console.log('listScen1', listScen1);

                            adesso = new Date().toISOString();
                            ildevicename = "deviceName" + scenarioName;
                            currentLoadedScenario = ildevicename;

                            // check if device exist
                            var deviceExist = false;
                            try{
                                const data = await readFromDevice(null, ildevicename, null);
                                if(data){
                                    deviceExist = true;
                                } else {
                                    deviceExist = false;
                                }
                            } catch {
                                deviceExist = false;
                            }

                            if(!deviceExist){                                
                                creato = await createDevice(lAccessToken, ildevicename, scenarioareaOfInterest[0].geometry, centroid);
                                if (creato == "ok") { // device did not exist and it has been created successfully
                                    showNotification("Scenario successfully created!");
                                    try {
                                        initdatainviati = await sendDataINIT(lAccessToken, ildevicename, scenarioData);
                                        if (initdatainviati == "dati_init_si") {
                                            sendDataToDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + ildevicename, {
                                                "roadGraph": istanzedelgrafochestoconsiderando_forSaving,
                                                "filters": list_filters,
                                                "sensors": sensoriArray,
                                                "restrictions": restrictions
                                            }, ilDateObserved).then(data => {
                                                console.log('Risposta dal server:', data);
                                                console.log('currentLoadedStatus: ', currentLoadedStatus);
                                                console.log('istanzedelgrafochestoconsiderando_forSaving', istanzedelgrafochestoconsiderando_forSaving);
                                                setTimeout(() => {
                                                    showNotification("Scenario device successfully created and data sent correctly.");
                                                }, 1000);
                                            }).catch(error => {
                                                console.error('Si è verificato un errore:', error);
                                                showNotification("Error in sending data to DB.");
                                            });                                            
                                        } else {
                                            console.error("Error during initial data sending:", error);
                                            showNotification("Error during initial data sending to device.");
                                        }
                                    } catch (error) {
                                        console.error("Error during initial data sending:", error);
                                        showNotification("Error during initial data sending.");
                                    }
                                } else {
                                    console.error("Error during scenario device creation.");
                                    showNotification("Error during scenario device creation.");
                                }
                            } else {                                 
                                try {
                                    //INVIO DATI AL DB STATO INIT
                                    if (currentLoadedStatus == 'init') {
                                        initdatainviati = await sendDataINIT(lAccessToken, ildevicename, scenarioData);
                                        if (initdatainviati == "dati_init_si") {
                                            sendDataToDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + ildevicename, {
                                                "roadGraph": istanzedelgrafochestoconsiderando_forSaving,
                                                "filters": list_filters,
                                                "sensors": sensoriArray,
                                                "restrictions": restrictions
                                            }, ilDateObserved).then(data => {
                                                console.log('Risposta dal server:', data);
                                                setTimeout(() => {
                                                    showNotification("Scenario data successfully updated.");
                                                }, 1000);
                                            }).catch(error => {
                                                console.error('Si è verificato un errore:', error);
                                                showNotification("Error during scenario data updating.");
                                            });
                                        } else {
                                            console.error("Error during data updating in device");
                                            showNotification("Error during data updating in device.");
                                        }
                                    } else if (currentLoadedStatus == 'acc') { //INVIO DATI AL DB STATO ACC // TODO: TO BE REVISED!!!
                                        // // mi prendo la data attuale da mandare nel DB
                                        // ilDateObserved = new Date().toISOString();
                                        // // mentre per il dato che andrà sul device ci devo mettere + 2 ore
                                        // let ilDateObserved2 = new Date(ilDateObserved);                                    
                                        // ilDateObserved2.setHours(ilDateObserved2.getHours() + 2);
                                        // ilDateObserved2 = ilDateObserved2.toISOString();
                                        // scenarioData.metadata.dateObserved = ilDateObserved2; // lo devo aggiornare sennò prende lo stesso dell'acc che carico                                                                                        
                                        initdatainviati = await sendDataINIT(lAccessToken, ildevicename, scenarioData, questofather.value);
                                        if (initdatainviati == "dati_init_si") {
                                            //NEW FORMAT DATA
                                            let acc_pronto_per_il_risalvataggio = istanzedelgrafochestoconsiderando_forSaving.map(item => {
                                                if(item.lanes.lanes != undefined){
                                                    let questaLenght = -1;

                                                    // ENRICO: qui ho l'AC dal db in loadedAccAC e mi prendo la length specifica
                                                    for (let i = 0; i < loadedAccAC.length; i++) {
                                                        if(loadedAccAC[i]['segment'][0] == item.segment){
                                                            if (loadedAccAC[i]['length'][0] != 0){
                                                                questaLenght = loadedAccAC[i]['length'][0];
                                                            }                                                                                                                
                                                        }
                                                    }
                                                    return {
                                                        "road": [item.road],
                                                        "segment": [item.segment],
                                                        "type": [item.type],
                                                        "nALat": [item.nALat],
                                                        "nALong": [item.nALong],
                                                        "nBLat": [item.nBLat],
                                                        "nBLong": [item.nBLong],
                                                        "dir": ["tratto stradale aperto nella direzione positiva (da giunzione NOD_INI a giunzione NOD_FIN)"], // forzo a "tratto stradale aperto nella direzione positiva (da giunzione NOD_INI a giunzione NOD_FIN)" che delle votle viene "none" su item.dir
                                                        "length": [parseFloat(questaLenght)],//[parseInt(haversineDistance(item.nALat, item.nALong, item.nBLat, item.nBLong, R=6371000))], //[item.length], // e manca la lenght! come cacchio la sistemo ora ?!
                                                        "nodeA": [item.nodeA],
                                                        "nodeB": [item.nodeB],
                                                        "lanes": {
                                                            "1": [item.lanes.lanes[0]]  // va aggiustato qui
                                                        }, 
                                                        "elemType": {
                                                            "1": item.elemType.elemType
                                                        },  // questo Rimane uguale
                                                        "sensor": ["0"],   // questo dovrebbe essere itm.sensor ma va messo a 0 forse li mette da qualche parte
                                                        "considered": [0], //[item.considered], // lo mette a 1 ma dovrebbe essere 0 quindi imposto 0 per conformarmi a stefano
                                                        "virtual": [0], //[item.virtual], // idem come sopra
                                                        "recSeg": [item.recSeg],
                                                        "recRoad": [item.recRoad],
                                                        "realSegment": [item.realSegment],
                                                        "realRoad": [item.realRoad],
                                                        "weight": [parseFloat(item.weight)] ,
                                                        "vmax": [parseFloat(item.roadElmSpeedLimit)*0.2777],
                                                        "delta_x": [item.delta_x],
                                                        "notOptimizable": [item.notOptimizable]
                                                    };
                                                }else{
                                                    return {
                                                        "road": [item.road],
                                                        "segment": [item.segment],
                                                        "type": [item.type],
                                                        "nALat": [item.nALat],
                                                        "nALong": [item.nALong],
                                                        "nBLat": [item.nBLat],
                                                        "nBLong": [item.nBLong],
                                                        "dir": [item.dir],
                                                        "length": [item.length],
                                                        "nodeA": [item.nodeA],
                                                        "nodeB": [item.nodeB],
                                                        "lanes": {
                                                            "1": [item.lanes]
                                                        },
                                                        "elemType": item.elemType,  // Rimane uguale
                                                        "sensor": [item.sensor],
                                                        "considered": [item.considered],
                                                        "virtual": [item.virtual],
                                                        "recSeg": [item.recSeg],
                                                        "recRoad": [item.recRoad],
                                                        "realSegment": [item.realSegment],
                                                        "realRoad": [item.realRoad],
                                                        "weight": [parseFloat(item.weight)],
                                                        "vmax": [parseFloat(item.roadElmSpeedLimit)*0.2777],
                                                        "delta_x": [item.delta_x],
                                                        "notOptimizable": [item.notOptimizable]                                                        
                                                    };
                                                }
                                            });

                                            // Stampa il nuovo JSON
                                            console.log(acc_pronto_per_il_risalvataggio);

                                            // 
                                            // riprendo i riferimenti che erano persi e gli aggiorno l'eventuale weight se è stato modificato sul segmento di riferimento
                                            riferimentoSensoriAccorpato.forEach(sensorItem => {
                                                // Trova l'elemento corrispondente in acc_pronto_per_il_risalvataggio
                                                let correspondingItem = acc_pronto_per_il_risalvataggio.find(accItem => accItem.segment[0] === sensorItem.segment);
                                                if (correspondingItem) {                                                
                                                    if (correspondingItem.weight[0] !== sensorItem.weight) {                                                    
                                                        sensorItem.weight = correspondingItem.weight[0]; // e qui gli aggiorno il weight
                                                        //console.log(`Aggiornato weight per il segmento ${sensorItem.segment} da ${sensorItem.weight} a ${correspondingItem.weight[0]}`);
                                                    }
                                                    
                                                }
                                            });

                                            // manca di convertire nel formato originale anche riferimentoSensoriAccorpato
                                            // eh oh va ripetuto perchè tipo lanes ed eemtype sono diversi...
                                            let riferimentoSensoriConvertito = riferimentoSensoriAccorpato.map(sensorItem => {
                                                return {
                                                    "road": [sensorItem.road],
                                                    "segment": [sensorItem.segment],
                                                    "type": [sensorItem.type],
                                                    "nALat": [sensorItem.nALat],
                                                    "nALong": [sensorItem.nALong],
                                                    "nBLat": [sensorItem.nBLat],
                                                    "nBLong": [sensorItem.nBLong],
                                                    "dir": [sensorItem.dir], // dovrebbe essere none
                                                    "length": [sensorItem.length],
                                                    "nodeA": [sensorItem.nodeA],
                                                    "nodeB": [sensorItem.nodeB],
                                                    "lanes": {
                                                        "lanes": sensorItem.lanes.lanes // Estrarre il valore giusto da 'lanes'
                                                    },
                                                    "elemType": {
                                                        "elemType": sensorItem.elemType.elemType // Estrarre il valore giusto da 'elemType'
                                                    },
                                                    "sensor": [sensorItem.sensor],
                                                    "considered": [sensorItem.considered],
                                                    "virtual": [sensorItem.virtual],
                                                    "recSeg": [sensorItem.recSeg],
                                                    "recRoad": [sensorItem.recRoad],
                                                    "realSegment": [sensorItem.realSegment],
                                                    "realRoad": [sensorItem.realRoad],
                                                    "weight": [parseFloat(sensorItem.weight)],
                                                    "vmax": [parseFloat(sensorItem.roadElmSpeedLimit)*0.2777],
                                                    "delta_x": [sensorItem.delta_x],
                                                    "notOptimizable": [sensorItem.notOptimizable]     
                                                };
                                            });

                                            // aggiorno pre invio .. forse
                                            acc_pronto_per_il_risalvataggio = acc_pronto_per_il_risalvataggio.concat(riferimentoSensoriConvertito);

                                            ///
                                            sendDataToDB("<?= $baseServiceURI; ?>" + ilbrokerdellorganizzazione + "/" + lorganizzazione + "/" + ildevicename, {
                                                "roadGraph": loadedAccRoadGraph,
                                                "filters": loadedAccFilters,
                                                "sensors": loadedAccSensors,
                                                "restrictions": loadedAccRestrictions,
                                                "AC": acc_pronto_per_il_risalvataggio,
                                                "JS20": loadedAccJS20,
                                                "TDM": acc_pronto_per_il_risalvataggio                                            
                                            }, ilDateObserved).then(data => {
                                                console.log('Risposta dal server:', data);
                                                showNotification("Scenario data successfully updated.");
                                            }).catch(error => {
                                                console.error('Si è verificato un errore:', error);
                                                console.error("Errore nell'invio dei dati iniziali:", error);
                                                showNotification("Error during scenario data updating.");
                                            });
                                        } else {
                                            console.error("Error during data updating in device");
                                            showNotification("Error during data updating in device.");
                                        }
                                    }                                    
                                } catch (error) {
                                    console.error("Errore nell'invio dei dati iniziali:", error);
                                    showNotification("Error during data sending.");
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error("An error occurred:", error.message);
                }
            });

            async function goIntoViewMode(){
                //$('input[name="scenario-type"][value="init"]').prop('checked', true).trigger('change');
                
                $('#segmentLabel').hide();
                $('#menu-lines').hide();
                if (roadElementGraph) {
                    roadElementGraph.mode = "view";
                }
                $('#currentStatusEdit').val('view');
                //db_new
                $('.sensorPopup_edit').css('display', 'none');
                $('.sensorPopup_view').css('display', 'inline');
                $("#view_mod").css('background-color', '#3E64A6');
                $("#view_mod").css('color', 'white');
                $("#edit_lines").css('background-color', '');
                $("#edit_lines").css('color', 'black');
                //scenario-edit-form
                // Trova l'elemento con la classe "leaflet-draw" nell'intero documento
                var drawControl = document.querySelector('.leaflet-draw');
                if (drawControl) {
                    drawControl.parentNode.removeChild(drawControl);
                }

                var scenarioToRemove = document.getElementById("modality-load");
                if (scenarioToRemove) {
                    scenarioToRemove.remove();
                    isSaveFinalSet = false;
                }
                //$('#showStreetGraph').hide();
                var scenarioToRemove = document.getElementById("scenario-edit-form");

                console.log(scenarioToRemove);
                if (scenarioToRemove) {
                    scenarioToRemove.remove();
                    isSaveFinalSet = false;
                }
                try {
                    ////
                    if (scenaryData.features.length >= 0) {
                        for (const layerId in scenaryGrafo._layers) {
                            const grafo = scenaryGrafo._layers[layerId];
                            scenaryGrafo.removeLayer(grafo);
                        }

                        var scenaryControl3 = L.control({
                            position: 'topright'
                        });
                        scenaryControl3.onAdd = function (map) {
                            var div3 = L.DomUtil.create('div');
                            var currentStatusEdit = $('#currentStatusEdit').val();
                            div3.id = "modality-load";
                            div3.innerHTML = `
                                <div id="scenario-div">
                                    <div id="notification" style="display: none;">
                                        <p id="notification-message">bells</p>
                                    </div>
                                    <div id="scenario-content">
                                        <div id="acc-content">
                                            <table>
                                                <tr>
                                                    <td>
                                                        <label>Load Scenario:</label>
                                                    </td>
                                                    <td>
                                                        <input type="radio" id="acc-type-init" name="scenario-type" value="init" checked>
                                                        <label for="acc-type-init">Init</label>
                                                        <input type="radio" id="acc-type-acc" name="scenario-type" value="acc">
                                                        <label for="acc-type-acc">Acc</label>
                                                        <!-- <input type="radio" id="acc-type-tdm" name="scenario-type" value="tdm">
                                                        <label for="acc-type-tdm">tfr</label> -->
                                                    </td>
                                                </tr>
                                                <td id="scenario-init-row">
                                                    <label for="scenario-init-list">Scenarios waiting to be processed:</label>
                                                    <input type="text" id="search-scenario-init" placeholder="Search..." hidden>
                                                    <select id="scenario-init-list" style="max-height: 120px; overflow: auto;"></select>
                                                    <br />
                                                    <label for="scenario-version-list">Scenario version:</label>
                                                    <select id="scenario-version-list" style="max-height: 120px; overflow: auto;"></select>
                                                    <br />
                                                    <button id="scenario-load">Load Scenario</button>
                                                    <button id="scenario-init-reload">Clean</button>
                                                </td>
                                                <tr class="scenario-list-row" style="display: none;">
                                                    <td>
                                                        <label for="scenario-list">Scenario List:</label>
                                                    </td>
                                                    <td>
                                                        <select id="scenario-list" name="scenario-list"></select>
                                                    </td>
                                                </tr>
                                                <tr class="scenario-list-row" style="display: none;">
                                                    <td>
                                                        <label for="acc-list">acc version:</label>
                                                    </td>
                                                <td>
                                                    <select id="acc-list" name="acc-list"></select>
                                                </td>
                                                <tr class="scenario-list-row" style="display: none;">
                                                    <td colspan="2">
                                                        <button id="scenario-check-acc1">Load ACC</button>
                                                        <button id="scenario-check-acc-reaload">Clean</button>
                                                    </td>
                                                </tr>
                                                <tr class="scenario-tdm-row" style="display: none;">
                                                    <td>
                                                        <label for="scenario-tdm-list">tfr Scenarios:</label>
                                                    </td>
                                                    <td>
                                                        <select id="scenario-tdm-list" name="scenario-tdm-list"></select>
                                                    </td>
                                                    </td>
                                                </tr>
                                                <tr class="scenario-tdm-row" style="display: none;">
                                                    <td>
                                                        <label for="tdm-list">tfr version:</label>
                                                    </td>
                                                    <td>
                                                        <select id="tdm-list" name="tdm-list"></select>
                                                    </td>
                                                </tr>
                                                <tr class="scenario-tdm-row">
                                                    <td colspan="2">
                                                        <button id="scenario-check-tdm">Load tfr</button>
                                                    </td>
                                                </tr>
                                            </table>
                                        </div>
                                    </div>
                                </div>`;
                            
                            // Disabilita l'interazione di questo div con la mappa per evitare conflitti
                            if (L.Browser.touch) {
                                L.DomEvent.disableClickPropagation(div3);
                                L.DomEvent.on(div3, 'mousewheel', L.DomEvent.stopPropagation);
                            } else {
                                L.DomEvent.on(div3, 'click', L.DomEvent.stopPropagation);
                            }
                            return div3;
                            ////   
                        }
                        scenaryControl3.addTo(map.defaultMapRef);
                        
                        getInits();
                    

                        $('#scenario-check-acc-reaload').click(async function () {
                            console.log('CLICK REALOD');
                            //window.location.reload();
                            pulisciTutto();
                        });
            
                        $('#scenario-init-reload').click(async function () {
                            console.log('CLICK REALOD');
                            //window.location.reload();
                            pulisciTutto();
                        });
            
                        $('#scenario-load').click(async function () {
                            loadScenario();
                        });

                    
                    }
                } catch (error) {
                    console.error("An error occurred:", error.message);
                }
                //sparqlQuery = buildSparqlQueryURL(enlargedPolygonWKT);
                $('#scenario-check-acc1').click(async function () {
                    console.log('scenario-check-acc1 CHANGED VIEW');
                    loadACCScenario();
                });

                //////////////VIEW CHANGING ///////////
                $("input[name='scenario-type']").change(async function () {
                    //var selectedId = $(this).attr("id");
                    var select_scenario_type = null;
                    if (document.querySelector('input[name="scenario-type"][value="init"]').checked) {
                        select_scenario_type = document.querySelector('input[name="scenario-type"][value="init"]').id;
                    } else if(document.querySelector('input[name="scenario-type"][value="acc"]').checked){
                        select_scenario_type = document.querySelector('input[name="scenario-type"][value="acc"]').id;
                    } else if (document.querySelector('input[name="scenario-type"][value="tdm"]').checked) {
                        select_scenario_type = document.querySelector('input[name="scenario-type"][value="tdm"]').id;
                    }
                    changeScenarioTypeToLoad(select_scenario_type);
                    // console.log('CHANGE 01');
                    // console.log('change: ' + selectedId);

                    // var scenarioType;
                    // if (selectedId === "acc-type-init") {
                    //     scenarioType = "init";
                    //     $(".scenario-list-row").hide();
                    //     document.getElementById("scenario-init-row").style.display = "block";
                    //     $(".scenario-tdm-row").hide();
                    //     var initScenarios0 = await getScenarios(scenarioType);
                    //     var initScenarios = [...new Set(initScenarios0)];
                    //     var scenarioInitList = $("#scenario-init-list");
                    //     var searchInput = $("#search-scenario-init");
                    //     searchInput.on("input", function () {
                    //         var searchTerm = $(this).val().toLowerCase();
                    //         filterScenarios(initScenarios, searchTerm);
                    //     });

                    //     scenarioInitList.empty();
                    //     initScenarios.sort();
                    //     initScenarios.forEach(scenario => {
                    //         var optionValue = scenario.replace("deviceName", "");
                    //         var optionText = optionValue;
                    //         var listItem = $("<option>").val(scenario).text(optionText);
                    //         scenarioInitList.append(listItem);
                    //     });

                    //     function filterScenarios(scenarios, searchTerm) {
                    //         var scenarioInitList = $("#scenario-init-list");
                    //         scenarioInitList.empty();
                    //         initScenarios.sort();
                    //         scenarios.forEach(scenario => {
                    //             if (scenario.toLowerCase().includes(searchTerm)) {
                    //                 var optionValue = scenario.replace("deviceName", "");
                    //                 var optionText = optionValue;
                    //                 var listItem = $("<option>").val(scenario).text(optionText);
                    //                 scenarioInitList.append(listItem);
                    //             }
                    //         });
                    //     }
                    // } else if (selectedId === "acc-type-acc") {
                    //     scenarioType = "acc";
                    //     $(".scenario-list-row").show();
                    //     document.getElementById("scenario-init-row").style.display = "none";
                    //     $(".scenario-tdm-row").hide();
                    //     var accScenarios0 = await getScenarios(scenarioType);
                    //     var scenarioList = $("#scenario-list");
                    //     scenarioList.empty(); // Pulisci eventuali opzioni preesistenti
                    //     var accScenarios = [...new Set(accScenarios0)];
                    //     accScenarios.sort();
                    //     accScenarios.forEach(scenario => {
                    //         var scenarioName = scenario.replace("deviceName", "");
                    //         var option = $("<option>").val(scenario).text(scenarioName);
                    //         scenarioList.append(option);
                    //     });
                    // } else if (selectedId === "acc-type-tdm") {
                    //     scenarioType = "tfr";
                    //     $(".scenario-list-row").hide();
                    //     $("#scenario-init-row").hide();
                    //     $(".scenario-tdm-row").show();

                    //     var tdmScenarios0 = await getScenarios(scenarioType);
                    //     var scenarioTDMList = $("#scenario-tdm-list");

                    //     scenarioTDMList.empty();
                    //     var tdmScenarios = [...new Set(tdmScenarios0)];
                    //     tdmScenarios.forEach(scenario => {

                    //         var optionValue = scenario.replace("deviceName", "");
                    //         var optionText = optionValue + " -> " + ilbrokerdellorganizzazione + "_" + lorganizzazione + "_" + scenario;
                    //         var listItem = $("<option>").val(scenario).text(optionValue);
                    //         scenarioTDMList.append(listItem);
                    //     });
                    //     function filterScenariosTDM(scenarios, searchTerm) {
                    //         var scenarioTDMList = $("#scenario-tdm-list");
                    //         scenarioTDMList.empty();
                    //         scenarios.forEach(scenario => {
                    //             if (scenario.toLowerCase().includes(searchTerm) || scenario.toLowerCase().includes('acc')) {
                    //                 var optionValue = scenario.replace("deviceName", "");
                    //                 var optionText = optionValue + " -> " + ilbrokerdellorganizzazione + "_" + lorganizzazione + "_" + scenario;
                    //                 var listItem = $("<option>").val(scenario).text(optionText);
                    //                 scenarioTDMList.append(listItem);
                    //             }
                    //         });
                    //     }
                    // }

                    // if (scenarioType) {
                    //     console.log("Scenario type selected: " + scenarioType);
                    // } else {
                    //     console.error("Errore nel determinare il tipo di scenario.");
                    // }
                });
            }


            $("#view_mod").click(async function () {

                goIntoViewMode();

                // //$('input[name="scenario-type"][value="init"]').prop('checked', true).trigger('change');
                
                // $('#segmentLabel').hide();
                // $('#menu-lines').hide();
                // if (roadElementGraph) {
                //     roadElementGraph.mode = "view";
                // }
                // $('#currentStatusEdit').val('view');
                // //db_new
                // $('.sensorPopup_edit').css('display', 'none');
                // $('.sensorPopup_view').css('display', 'inline');
                // $("#view_mod").css('background-color', '#3E64A6');
                // $("#view_mod").css('color', 'white');
                // $("#edit_lines").css('background-color', '');
                // $("#edit_lines").css('color', 'black');
                // //scenario-edit-form
                // // Trova l'elemento con la classe "leaflet-draw" nell'intero documento
                // var drawControl = document.querySelector('.leaflet-draw');
                // if (drawControl) {
                //     drawControl.parentNode.removeChild(drawControl);
                // }

                // var scenarioToRemove = document.getElementById("modality-load");
                // if (scenarioToRemove) {
                //     scenarioToRemove.remove();
                //     isSaveFinalSet = false;
                // }
                // //$('#showStreetGraph').hide();
                // var scenarioToRemove = document.getElementById("scenario-edit-form");

                // console.log(scenarioToRemove);
                // if (scenarioToRemove) {
                //     scenarioToRemove.remove();
                //     isSaveFinalSet = false;
                // }
                // try {
                //     ////
                //     if (scenaryData.features.length >= 0) {
                //         for (const layerId in scenaryGrafo._layers) {
                //             const grafo = scenaryGrafo._layers[layerId];
                //             scenaryGrafo.removeLayer(grafo);
                //         }

                //         var scenaryControl3 = L.control({
                //             position: 'topright'
                //         });
                //         scenaryControl3.onAdd = function (map) {
                //             var div3 = L.DomUtil.create('div');
                //             var currentStatusEdit = $('#currentStatusEdit').val();
                //             div3.id = "modality-load";
                //             div3.innerHTML = `
                //                 <div id="scenario-div">
                //                     <div id="notification" style="display: none;">
                //                         <p id="notification-message">bells</p>
                //                     </div>
                //                     <div id="scenario-content">
                //                         <div id="acc-content">
                //                             <table>
                //                                 <tr>
                //                                     <td>
                //                                         <label>Load Scenario:</label>
                //                                     </td>
                //                                     <td>
                //                                         <input type="radio" id="acc-type-init" name="scenario-type" value="init" checked>
                //                                         <label for="acc-type-init">Init</label>
                //                                         <input type="radio" id="acc-type-acc" name="scenario-type" value="acc">
                //                                         <label for="acc-type-acc">Acc</label>
                //                                         <!-- <input type="radio" id="acc-type-tdm" name="scenario-type" value="tdm">
                //                                         <label for="acc-type-tdm">tfr</label> -->
                //                                     </td>
                //                                 </tr>
                //                                 <td id="scenario-init-row">
                //                                     <label for="scenario-init-list">Scenarios waiting to be processed:</label>
                //                                     <input type="text" id="search-scenario-init" placeholder="Search..." hidden>
                //                                     <select id="scenario-init-list" style="max-height: 120px; overflow: auto;"></select>
                //                                     <br />
                //                                     <label for="scenario-version-list">Scenario version:</label>
                //                                     <select id="scenario-version-list" style="max-height: 120px; overflow: auto;"></select>
                //                                     <br />
                //                                     <button id="scenario-load">Load Scenario</button>
                //                                     <button id="scenario-init-reload">Clean</button>
                //                                 </td>
                //                                 <tr class="scenario-list-row" style="display: none;">
                //                                     <td>
                //                                         <label for="scenario-list">Scenario List:</label>
                //                                     </td>
                //                                     <td>
                //                                         <select id="scenario-list" name="scenario-list"></select>
                //                                     </td>
                //                                 </tr>
                //                                 <tr class="scenario-list-row" style="display: none;">
                //                                     <td>
                //                                         <label for="acc-list">acc version:</label>
                //                                     </td>
                //                                 <td>
                //                                     <select id="acc-list" name="acc-list"></select>
                //                                 </td>
                //                                 <tr class="scenario-list-row" style="display: none;">
                //                                     <td colspan="2">
                //                                         <button id="scenario-check-acc1">Load ACC</button>
                //                                         <button id="scenario-check-acc-reaload">Clean</button>
                //                                     </td>
                //                                 </tr>
                //                                 <tr class="scenario-tdm-row" style="display: none;">
                //                                     <td>
                //                                         <label for="scenario-tdm-list">tfr Scenarios:</label>
                //                                     </td>
                //                                     <td>
                //                                         <select id="scenario-tdm-list" name="scenario-tdm-list"></select>
                //                                     </td>
                //                                     </td>
                //                                 </tr>
                //                                 <tr class="scenario-tdm-row" style="display: none;">
                //                                     <td>
                //                                         <label for="tdm-list">tfr version:</label>
                //                                     </td>
                //                                     <td>
                //                                         <select id="tdm-list" name="tdm-list"></select>
                //                                     </td>
                //                                 </tr>
                //                                 <tr class="scenario-tdm-row">
                //                                     <td colspan="2">
                //                                         <button id="scenario-check-tdm">Load tfr</button>
                //                                     </td>
                //                                 </tr>
                //                             </table>
                //                         </div>
                //                     </div>
                //                 </div>`;
                            
                //             // Disabilita l'interazione di questo div con la mappa per evitare conflitti
                //             if (L.Browser.touch) {
                //                 L.DomEvent.disableClickPropagation(div3);
                //                 L.DomEvent.on(div3, 'mousewheel', L.DomEvent.stopPropagation);
                //             } else {
                //                 L.DomEvent.on(div3, 'click', L.DomEvent.stopPropagation);
                //             }
                //             return div3;
                //             ////   
                //         }
                //         scenaryControl3.addTo(map.defaultMapRef);
                        
                //         getInits();
                    

                //         $('#scenario-check-acc-reaload').click(async function () {
                //             console.log('CLICK REALOD');
                //             //window.location.reload();
                //             pulisciTutto();
                //         });
            
                //         $('#scenario-init-reload').click(async function () {
                //             console.log('CLICK REALOD');
                //             //window.location.reload();
                //             pulisciTutto();
                //         });
            
                //         $('#scenario-load').click(async function () {
                //             loadScenario();
                //         });

                    
                //     }
                // } catch (error) {
                //     console.error("An error occurred:", error.message);
                // }
                // //sparqlQuery = buildSparqlQueryURL(enlargedPolygonWKT);
                // $('#scenario-check-acc1').click(async function () {
                //     console.log('scenario-check-acc1 CHANGED VIEW');
                //     loadACCScenario();
                // });

                // //////////////VIEW CHANGING ///////////
                // $("input[name='scenario-type']").change(async function () {
                //     //var selectedId = $(this).attr("id");
                //     var select_scenario_type = null;
                //     if (document.querySelector('input[name="scenario-type"][value="init"]').checked) {
                //         select_scenario_type = document.querySelector('input[name="scenario-type"][value="init"]').id;
                //     } else if(document.querySelector('input[name="scenario-type"][value="acc"]').checked){
                //         select_scenario_type = document.querySelector('input[name="scenario-type"][value="acc"]').id;
                //     } else if (document.querySelector('input[name="scenario-type"][value="tdm"]').checked) {
                //         select_scenario_type = document.querySelector('input[name="scenario-type"][value="tdm"]').id;
                //     }
                //     changeScenarioTypeToLoad(select_scenario_type);
                //     // console.log('CHANGE 01');
                //     // console.log('change: ' + selectedId);

                //     // var scenarioType;
                //     // if (selectedId === "acc-type-init") {
                //     //     scenarioType = "init";
                //     //     $(".scenario-list-row").hide();
                //     //     document.getElementById("scenario-init-row").style.display = "block";
                //     //     $(".scenario-tdm-row").hide();
                //     //     var initScenarios0 = await getScenarios(scenarioType);
                //     //     var initScenarios = [...new Set(initScenarios0)];
                //     //     var scenarioInitList = $("#scenario-init-list");
                //     //     var searchInput = $("#search-scenario-init");
                //     //     searchInput.on("input", function () {
                //     //         var searchTerm = $(this).val().toLowerCase();
                //     //         filterScenarios(initScenarios, searchTerm);
                //     //     });

                //     //     scenarioInitList.empty();
                //     //     initScenarios.sort();
                //     //     initScenarios.forEach(scenario => {
                //     //         var optionValue = scenario.replace("deviceName", "");
                //     //         var optionText = optionValue;
                //     //         var listItem = $("<option>").val(scenario).text(optionText);
                //     //         scenarioInitList.append(listItem);
                //     //     });

                //     //     function filterScenarios(scenarios, searchTerm) {
                //     //         var scenarioInitList = $("#scenario-init-list");
                //     //         scenarioInitList.empty();
                //     //         initScenarios.sort();
                //     //         scenarios.forEach(scenario => {
                //     //             if (scenario.toLowerCase().includes(searchTerm)) {
                //     //                 var optionValue = scenario.replace("deviceName", "");
                //     //                 var optionText = optionValue;
                //     //                 var listItem = $("<option>").val(scenario).text(optionText);
                //     //                 scenarioInitList.append(listItem);
                //     //             }
                //     //         });
                //     //     }
                //     // } else if (selectedId === "acc-type-acc") {
                //     //     scenarioType = "acc";
                //     //     $(".scenario-list-row").show();
                //     //     document.getElementById("scenario-init-row").style.display = "none";
                //     //     $(".scenario-tdm-row").hide();
                //     //     var accScenarios0 = await getScenarios(scenarioType);
                //     //     var scenarioList = $("#scenario-list");
                //     //     scenarioList.empty(); // Pulisci eventuali opzioni preesistenti
                //     //     var accScenarios = [...new Set(accScenarios0)];
                //     //     accScenarios.sort();
                //     //     accScenarios.forEach(scenario => {
                //     //         var scenarioName = scenario.replace("deviceName", "");
                //     //         var option = $("<option>").val(scenario).text(scenarioName);
                //     //         scenarioList.append(option);
                //     //     });
                //     // } else if (selectedId === "acc-type-tdm") {
                //     //     scenarioType = "tfr";
                //     //     $(".scenario-list-row").hide();
                //     //     $("#scenario-init-row").hide();
                //     //     $(".scenario-tdm-row").show();

                //     //     var tdmScenarios0 = await getScenarios(scenarioType);
                //     //     var scenarioTDMList = $("#scenario-tdm-list");

                //     //     scenarioTDMList.empty();
                //     //     var tdmScenarios = [...new Set(tdmScenarios0)];
                //     //     tdmScenarios.forEach(scenario => {

                //     //         var optionValue = scenario.replace("deviceName", "");
                //     //         var optionText = optionValue + " -> " + ilbrokerdellorganizzazione + "_" + lorganizzazione + "_" + scenario;
                //     //         var listItem = $("<option>").val(scenario).text(optionValue);
                //     //         scenarioTDMList.append(listItem);
                //     //     });
                //     //     function filterScenariosTDM(scenarios, searchTerm) {
                //     //         var scenarioTDMList = $("#scenario-tdm-list");
                //     //         scenarioTDMList.empty();
                //     //         scenarios.forEach(scenario => {
                //     //             if (scenario.toLowerCase().includes(searchTerm) || scenario.toLowerCase().includes('acc')) {
                //     //                 var optionValue = scenario.replace("deviceName", "");
                //     //                 var optionText = optionValue + " -> " + ilbrokerdellorganizzazione + "_" + lorganizzazione + "_" + scenario;
                //     //                 var listItem = $("<option>").val(scenario).text(optionText);
                //     //                 scenarioTDMList.append(listItem);
                //     //             }
                //     //         });
                //     //     }
                //     // }

                //     // if (scenarioType) {
                //     //     console.log("Scenario type selected: " + scenarioType);
                //     // } else {
                //     //     console.error("Errore nel determinare il tipo di scenario.");
                //     // }
                // });
                ///END VIEW CHANGING

                // console.error("WHY I AM HERE??? [14703]");
                // fetchSparqlData(sparqlQuery, null, polygonWKT, null, null, 'create');
            });

            // //////////////VIEW CHANGING ///////////
            $("input[name='scenario-type']").change(() => {
                var select_scenario_type = null;
                if (document.querySelector('input[name="scenario-type"][value="init"]').checked) {
                    select_scenario_type = document.querySelector('input[name="scenario-type"][value="init"]').id;
                } else if(document.querySelector('input[name="scenario-type"][value="acc"]').checked){
                    select_scenario_type = document.querySelector('input[name="scenario-type"][value="acc"]').id;
                } else if (document.querySelector('input[name="scenario-type"][value="tdm"]').checked) {
                    select_scenario_type = document.querySelector('input[name="scenario-type"][value="tdm"]').id;
                }
                changeScenarioTypeToLoad(select_scenario_type);
            });
        }

        

    });

    //##################################################################################################
    //################### REMOVE TRAFFIC SCENARY BUILDER EVENT #########################################
    //##################################################################################################       
    //rimuovo tutto
    $(document).on('removeTrafficScenary', function (event) {
        // gestisco quando l'utente clicca sul rimuovi lo scenario builder
        console.log("removeTrafficScenary sent!");
        if (event.target === map.mapName) {
            //levo il drawer control
            map.defaultMapRef.removeControl(drawerControl);
            // levo i disegni sulla mappa 
            map.defaultMapRef.removeLayer(scenaryDrawnItems);
            // mi ero scordato di levare i markers ma li levo subito
            map.defaultMapRef.removeLayer(scenaryMarkers);
            // levo anche il grafo
            map.defaultMapRef.removeLayer(scenaryGrafo);
            //levo il pannello di controllo per lo scenario
            //map.defaultMapRef.removeControl(scenaryControl);
            map.defaultMapRef.off('draw:created');

            //var modalityToRemove = document.getElementById("scenario-div");
            var modalityToRemove = document.getElementById("modality-load");
            if (modalityToRemove) {
                modalityToRemove.remove();
                isSaveFinalSet = false;
            }
            //
            var scenarioToRemove = document.getElementById("select-modality");
            //var modalityToRemove = document.getElementById("modality-load");
            var scenarioEditRemove = document.getElementById("scenario-edit-form");
            var scenary_selectorRemove = document.getElementById("scenary_selector");
            //
            var menulines = document.getElementById("menu-lines");

            var jsonIstanze = document.getElementById("jsonIstanze");
            //
            var drawControl = document.querySelector('.leaflet-draw');
            //
            var filterList = document.getElementById("filter-list");
            //
            if (scenarioToRemove) {
                scenarioToRemove.remove();
                isSaveFinalSet = false;
            }

            if (modalityToRemove) {
                modalityToRemove.remove();
                isSaveFinalSet = false;
            }

            if (scenarioEditRemove) {
                scenarioEditRemove.remove();
                isSaveFinalSet = false;
            }

            if (menulines) {
                menulines.remove();
                isSaveFinalSet = false;
            }

            if (filterList) {
                filterList.remove();
                isSaveFinalSet = false;
            }

            if (roadElementGraph) {
                //roadElementGraph.clearSegments();
                //roadElementGraph.clearNodes();
                roadElementGraph.reset();
                $('#jsonIstanze').text('');
                //istanzedelgrafochestoconsiderando = []; 
                console.log('r3eset roadElements');
            }
            //
            if (drawControl) {
                drawControl.parentNode.removeChild(drawControl);
                isSaveFinalSet = false;
            }
            //
            if (jsonIstanze) {
                jsonIstanze.remove();
                delete roadElementGraph;
                isSaveFinalSet = false;
            } else {
                console.log('No Road Element Graph');
            }

            if (scenary_selectorRemove) {
                scenary_selectorRemove.remove();
                isSaveFinalSet = false;
            }

            pulisciTutto();
        }
        //
    });

    //####################################################################################################################
    //####################################################################################################################
    //###################################### END TRAFFIC SCENARY BUILDER SECTION #########################################
    //####################################################################################################################
    //####################################################################################################################

    //Collini
    function delay(milliseconds) {
        return new Promise(resolve => {
            setTimeout(resolve, milliseconds);
        });
    }
    $(document).on('addCustomTrajectory', function (event) {
        if (event.target === map.mapName) {
            async function addCustomTrajectoryToMap() {
                // prendo i passed data
                let passedData = event.passedData;
                // creo array in cui salvare risorse che mi servono per lanciare l'evento sulla mappa
                let traj_markers = new Array();
                let traj_trajects = new Array();
                let traj_controls = new Array();
                //ancora parsing dei dati
                for (let j = 0; j < passedData.length; j++) {

                    let eventType = passedData[j].eventType;
                    let id = passedData[j].id;
                    let points = passedData[j].points
                    let prevlat = -1;
                    let prevlng = -1;

                    for (let o = 0; o < points.length; o++) { // per ogni punto 
                        await delay(0.1).then(() => {
                            let position = points[o].position;
                            let mode = points[o].mode;
                            let colore = points[o].color;
                            let icona = points[o].icon;
                            let optionalhtmltrajpopup = points[o].optionalhtmltrajpopup;
                            if (optionalhtmltrajpopup.length < 2) {
                                optionalhtmltrajpopup = "<p>Trajectory Segment</p>";

                            }
                            let vehicle = "car";
                            //console.log("icona" + colore)
                            let lat = -1;  //inizializzo alcune variabili
                            let lng = -1;
                            let name = "";
                            let iconSUrl = "";
                            var LeafIcon = L.Icon.extend({
                                options: {
                                    iconSize: [38, 95],
                                    shadowSize: [50, 64],
                                    iconAnchor: [22, 94],
                                    shadowAnchor: [4, 62],
                                    popupAnchor: [-3, -76]
                                }
                            });

                            //add marker given position...
                            //console.log(position.serviceUri.length);
                            if (position.serviceUri.length < 1) { //no suri -> lat,lon
                                //console.log("object" + o + " no suri")
                                lat = parseFloat(position.gps.lat);
                                lng = parseFloat(position.gps.lng);
                                name = "Trajectory point " + o;
                                //console.log(icona);
                                if (icona.length > 1) {
                                    var greenIcon = new LeafIcon({
                                        iconUrl: icona,
                                        //shadowUrl: 'http://leafletjs.com/examples/custom-icons/leaf-shadow.png'
                                        iconSize: [35, 35],
                                        iconAnchor: [5, 5],
                                        popupAnchor: [0, -5]
                                    })
                                }

                                //console.log(lat,lng)
                                let markerLocation = new L.LatLng(lat, lng); //mi creo il marker
                                let marker = new L.Marker(markerLocation, { icon: greenIcon });
                                //passedData[j].marker = marker;
                                //Creazione del popup per il pin appena creato
                                popupText = "<div>" + name + "</div>";
                                map.defaultMapRef.addLayer(marker.bindPopup(popupText, { offset: [0, 0] }));
                                traj_markers.push(marker);
                                //console.log("added marker");
                            } else {
                                //console.log("object" + o + " suri") // si usa la service uri
                                let suri = position.serviceUri;
                                //console.log(suri);
                                $.ajax({
                                    type: 'GET',
                                    url: suri,
                                    dataType: "json",
                                    contentType: 'application/json; charset=utf-8',
                                    async: false,
                                    success: function (data) {
                                        //console.log(data);
                                        // 3 casi (Service - Sensor - niente)
                                        if (typeof data.Service !== 'undefined') {
                                            lat = data.Service.features[0].geometry.coordinates[1];
                                            lng = data.Service.features[0].geometry.coordinates[0];
                                            //console.log(data.Service.features[0].geometry.coordinates)
                                            name = data.Service.features[0].properties.name;
                                            iconSUrl = "../img/gisMapIcons/" + data.Service.features[0].properties.subnature + ".png";
                                            data.Service.features[0].properties.color1 = colore;
                                            data.Service.features[0].properties.color2 = "#f5f5f5";
                                            console.log(data.Service.features[0]);
                                            var newMarker = gisPrepareCustomMarker(data.Service.features[0], { "lng": lng, "lat": lat });
                                        } else {
                                            if (typeof data.Sensor !== 'undefined') {
                                                lat = data.Sensor.features[0].geometry.coordinates[1];
                                                lng = data.Sensor.features[0].geometry.coordinates[0];
                                                name = data.Sensor.features[0].properties.name;
                                                iconSUrl = "../img/gisMapIcons/" + data.Sensor.features[0].properties.subnature + ".png";
                                                data.Sensor.features[0].properties.color1 = colore;
                                                data.Sensor.features[0].properties.color2 = "#f5f5f5";
                                                console.log(data.Sensor.features[0]);
                                                var newMarker = gisPrepareCustomMarker(data.Sensor.features[0], { "lng": lng, "lat": lat });
                                            } else {
                                                lat = data.features[0].geometry.coordinates[1];
                                                lng = data.features[0].geometry.coordinates[0];
                                                name = data.features[0].properties.name;
                                                iconSUrl = "../img/gisMapIcons/" + data.features[0].properties.subnature + ".png";
                                                data.features[0].properties.color1 = colore;
                                                data.features[0].properties.color2 = "#f5f5f5";
                                                console.log(data.features[0]);
                                                var newMarker = gisPrepareCustomMarker(data.features[0], { "lng": lng, "lat": lat });
                                            }
                                        }

                                        //console.log(newMarker);
                                        map.defaultMapRef.addLayer(newMarker);
                                        traj_markers.push(newMarker);
                                    },
                                    error: function (errorData) {
                                        console.log(errorData);
                                    }
                                });
                            }

                            //add trajectory
                            if (o == 0) {
                                //console.log("initprevlatelong")
                                prevlat = lat;
                                prevlng = lng;
                            } else {//controllo che non sia il primo punto passato
                                if (mode.routing.manual) { // se viene sceleta la modalità manuale
                                    var polyline = L.polyline([
                                        [prevlat, prevlng],
                                        [lat, lng]
                                    ]);
                                    map.defaultMapRef.addLayer(polyline.setStyle({ color: points[o].color }).bindPopup(optionalhtmltrajpopup, { offset: [0, 0] }));
                                    traj_trajects.push(polyline);
                                    prevlat = lat;
                                    prevlng = lng;
                                } else { //vai col graphopper
                                    vehicle = mode.routing.graphhopper.type;
                                    weighting = $('#whatIf-weighting').val();   // Get the selected weighting
                                    startDatetime = $('#whatIf-startDatetime').val();   // Get the selected datetime
                                    //console.log("prev" + prevlat + " " +prevlng)
                                    //console.log("current" + lat + " " +lng)
                                    serviceUrl = setServiceUrl(orgParams, map.defaultMapRef.getBounds()["_northEast"]);
                                    var lrmtraj = L.Routing.control({
                                        // Servlet params
                                        serviceUrl: serviceUrl,
                                        waypoints: [L.latLng(prevlat, prevlng),
                                        L.latLng(lat, lng)],
                                        avoid_area: "%7B%22type%22%3A%22FeatureCollection%22%2C%22features%22%3A%5B%7B%22type%22%3A%22Feature%22%2C%22properties%22%3A%7B%7D%2C%22geometry%22%3A%7B%22type%22%3A%22Polygon%22%2C%22coordinates%22%3A%5B%5B%5B11.279826%2C43.770474%5D%2C%5B11.276307%2C43.767561%5D%2C%5B11.27871%2C43.766135%5D%2C%5B11.281285%2C43.768491%5D%2C%5B11.279826%2C43.770474%5D%5D%5D%7D%7D%5D%2C%22scenarioName%22%3A%22prova%22%2C%22isPublic%22%3Atrue%7D",
                                        vehicle: vehicle,
                                        weighting: weighting,
                                        startDatetime: startDatetime,
                                        // end Servlet params
                                        geocoder: "",    //L.Control.Geocoder.nominatim(),
                                        routeWhileDragging: false,
                                        reverseWaypoints: false,
                                        showAlternatives: false,
                                        show: false,
                                        waypointMode: 'snap',
                                        createMarker: function () { }
                                    });

                                    //console.log(points[0].color);
                                    lrmtraj.on('routeselected', function (e) {
                                        let traie = L.polyline(e.route.coordinates).setStyle({ color: points[o].color }).bindPopup(optionalhtmltrajpopup, { offset: [0, 0] });
                                        traie.addTo(map.defaultMapRef);
                                        traj_trajects.push(traie);
                                        //map.removeControl(control);
                                    });
                                    lrmtraj.addTo(map.defaultMapRef);
                                    traj_controls.push(lrmtraj);
                                    // e aggiorno le nuove precendenti latitudine e longitudine
                                    prevlat = lat;
                                    prevlng = lng;

                                    if ($('.leaflet-routing-container').length) {
                                        $(".leaflet-routing-container").remove();//Class()
                                    }

                                }
                            }
                        });
                    }
                }
                passedData.markers = traj_markers;
                passedData.trajects = traj_trajects
                passedData.controls = traj_controls;
                map.eventsOnMap.push(passedData); // mando il fire degli eventi sulla mappa per poi rimuoverli successivamente (removecustomtraject...
                //console.log("event sent");
            }

            if (addMode === 'additive') {
                addCustomTrajectoryToMap();

            }

            if (addMode === 'exclusive') {
                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if (map.eventsOnMap[i].eventType !== 'Trajectory') {
                        map.defaultMapRef.eachLayer(function (layer) {
                            map.defaultMapRef.removeLayer(layer);
                        });
                        map.eventsOnMap.length = 0;
                        break;
                    }
                }
                //Remove WidgetAlarm active pins
                $.event.trigger({
                    type: "removeAlarmPin",
                });
                //Remove WidgetEvacuationPlans active pins
                $.event.trigger({
                    type: "removeEvacuationPlanPin",
                });
                //Remove WidgetSelector active pins
                $.event.trigger({
                    type: "removeSelectorEventPin",
                });
                //Remove WidgetEvents active pins
                $.event.trigger({
                    type: "removeEventFIPin",
                });
                //Remove WidgetResources active pins
                $.event.trigger({
                    type: "removeResourcePin",
                });
                //Remove WidgetTrafficEvents active pins
                $.event.trigger({
                    type: "removeTrafficEventPin",
                });
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                    maxZoom: leafletMaxZoom,
                    maxNativeZoom: leafletNativeMaxZoom
                }).addTo(map.defaultMapRef);

                addOperatorEventToMap();
            }

            //console.log(map.eventsOnMap.length);

            // resizeMapView(map.defaultMapRef);
        }
    });




    $(document).on('addTrafficEvent', function (event) {
        if (event.target === map.mapName) {
            function addTrafficEventToMap() {
                let passedData = event.passedData;

                for (let j = 0; j < passedData.length; j++) {

                    let lat = passedData[j].lat;
                    let lng = passedData[j].lng;
                    let eventType = passedData[j].eventType;
                    let eventSubtype = passedData[j].eventSubtype;
                    let eventName = passedData[j].eventName;
                    let eventStartDate = passedData[j].eventStartDate;
                    let eventStartTime = passedData[j].eventStartTime;
                    let eventSeverity = passedData[j].eventSeverity;
                    let eventseveritynum = passedData[j].eventseveritynum;
                    passedData[j].type = "trafficEvent";

                    //Creazione dell'icona custom per il pin
                    switch (eventSeverity) {
                        case "Low":
                            mapPinImg = '../img/trafficIcons/' + trafficEventTypes["type" + eventType].mapIconLow;
                            severityColor = "#ffcc00";
                            break;

                        case "Med":
                            mapPinImg = '../img/trafficIcons/' + trafficEventTypes["type" + eventType].mapIconMed;
                            severityColor = "#ff9900";
                            break;

                        case "High":
                            mapPinImg = '../img/trafficIcons/' + trafficEventTypes["type" + eventType].mapIconHigh;
                            severityColor = "#ff6666";
                            break;
                    }

                    let pinIcon = new L.DivIcon({
                        className: null,
                        html: '<img src="' + mapPinImg + '" class="leafletPin" />',
                        iconAnchor: [18, 36]
                    });

                    let markerLocation = new L.LatLng(lat, lng);
                    let marker = new L.Marker(markerLocation, { icon: pinIcon });
                    passedData[j].marker = marker;

                    //Creazione del popup per il pin appena creato
                    popupText = "<span class='mapPopupTitle'>" + eventName + "</span>" +
                        "<span class='mapPopupLine'><i>Start date</i>: " + eventStartDate + " - " + eventStartTime + "</span>" +
                        "<span class='mapPopupLine'><i>Event type</i>: " + trafficEventTypes["type" + eventType].desc.toUpperCase() + "</span>" +
                        "<span class='mapPopupLine'><i>Event subtype</i>: " + trafficEventSubTypes["subType" + eventSubtype].toUpperCase() + "</span>" +
                        "<span class='mapPopupLine'><i>Event severity</i>: " + eventseveritynum + " - <span style='background-color: " + severityColor + "'>" + eventSeverity.toUpperCase() + "</span></span>";

                    map.defaultMapRef.addLayer(marker);
                    lastPopup = marker.bindPopup(popupText, { offset: [-5, -40], maxWidth: 600 }).openPopup();

                    map.eventsOnMap.push(passedData[j]);
                }
            }

            if (addMode === 'additive') {
                addTrafficEventToMap();
            }

            if (addMode === 'exclusive') {
                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if (map.eventsOnMap[i].type !== "trafficEvent") {
                        map.defaultMapRef.eachLayer(function (layer) {
                            map.defaultMapRef.removeLayer(layer);
                        });
                        map.eventsOnMap.length = 0;
                        break;
                    }
                }
                //Remove WidgetAlarm active pins
                $.event.trigger({
                    type: "removeAlarmPin",
                });
                //Remove WidgetEvacuationPlans active pins
                $.event.trigger({
                    type: "removeEvacuationPlanPin",
                });
                //Remove WidgetSelector active pins
                $.event.trigger({
                    type: "removeSelectorEventPin",
                });
                //Remove WidgetEvents active pins
                $.event.trigger({
                    type: "removeEventFIPin",
                });
                //Remove WidgetResources active pins
                $.event.trigger({
                    type: "removeResourcePin",
                });
                //Remove WidgetOperatorEvents active pins
                $.event.trigger({
                    type: "removeOperatorEventPin",
                });
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                    maxZoom: leafletMaxZoom,
                    maxNativeZoom: leafletNativeMaxZoom
                }).addTo(map.defaultMapRef);

                addTrafficEventToMap();
            }

            //console.log(map.eventsOnMap.length);
            //  resizeMapView(map.defaultMapRef);
        }
    });

    // Cristiano : Dynamic Routing
    var scenarioLayer = null;
    var scenarioControl = null;
    var drawerControl = null;
    var geocoderControl = null;
    var scenarioDrawnItems = null;
    var scenarioData = new L.geoJSON();
    scenarioData.type = "FeatureCollection";
    scenarioData.features = [];
    $(document).on('addScenario', function (event) {
        if (event.target === map.mapName) {
            // create scenario layer and add to map
            scenarioLayer = new L.FeatureGroup();
            map.defaultMapRef.addLayer(scenarioLayer);
            // create drawer layer/control and add them to map
            scenarioDrawnItems = new L.FeatureGroup();
            map.defaultMapRef.addLayer(scenarioDrawnItems);
            drawerControl = new L.Control.Draw({
                edit: {
                    featureGroup: scenarioDrawnItems,
                    edit: false,
                    remove: false
                },
                draw: {
                    circle: {
                        metric: 'metric'
                    },
                    polyline: false,
                    polygon: {
                        allowIntersection: false,
                        showArea: true
                    }
                }
            });
            map.defaultMapRef.addControl(drawerControl);





            map.defaultMapRef.on('draw:created', function (e) {
                console.log('Re drawing');
                if (saveLoadGraph.length > 0) {
                    saveLoadGraph = [];
                }
                $('#jsonIstanze').text('');
                var type = e.layerType,
                    layer = e.layer;
                var curGeojson = layer.toGeoJSON();

                if (type === 'marker') {
                    console.log(type + " created in " + layer._latlng);
                }
                else if (type === 'circle') {
                    console.log(type + " created in " + layer._latlng + "with radius of " + layer.getRadius() + " m");
                    curGeojson.properties["radius"] = layer.getRadius();
                }
                else if (type === 'polygon' || type === 'rectangle') {
                    console.log(type + " created");
                }
                scenarioData.features.push(curGeojson);
                scenarioDrawnItems.addLayer(layer);
            });

            // create geocoder control and add to map
            var geocoder = L.Control.Geocoder.nominatim();
            geocoderControl = L.Control.geocoder({
                geocoder: geocoder,
                defaultMarkGeocode: false
            }).addTo(map.defaultMapRef)
                .on('markgeocode', function (e) {
                    map.defaultMapRef.panTo(e.geocode.center);
                    map.defaultMapRef.setZoom(18);
                });

            // create scenario control and add to map
            scenarioControl = L.control({ position: 'topleft' });
            scenarioControl.onAdd = function (map) {
                var div = L.DomUtil.create('div');

                div.innerHTML = '<div id="scenario-div">' +
                    '<input id="scenario-name" type="text" placeholder="Scenario name" name="name">' +
                    '<input id="scenario-description" type="text" placeholder="Scenario description" name="description">' +
                    '<span><input id="scenario-visibility" type="checkbox" name="public" value="Public"> Public visibility</span>' +
                    '<label for="scenario-startDatetime">From:</label>' +
                    '<input id="scenario-startDatetime" type="datetime-local" name="datetimeFrom">' +
                    '<label for="scenario-endDatetime">To:</label>' +
                    '<input id="scenario-endDatetime" type="datetime-local" name="datetimeTo">' +
                    '<div>' +
                    '<input type="button" id="scenario-save" value="Save"/>' +
                    '<button id="scenario-cancel" type="button">Cancel</button>' +
                    '</div>' +
                    '</div>';
                // disable interaction of this div with map
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(div);
                    L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
                }

                return div;
            };
            scenarioControl.addTo(map.defaultMapRef);

            // $("#scenario-save").click(function () {
            //     console.error("SAVE SCENARIO 3 [15468]");
            //     if ($("#scenario-name").val() !== "" && scenarioData.features.length > 0 && $("#scenario-name").val().indexOf("(") == -1) {
            //         delete scenarioData.options;
            //         delete scenarioData.layers;
            //         delete scenarioData._initHooksCalled;
            //         delete scenarioData._layers;
            //         scenarioData.scenarioName = $("#scenario-name").val();
            //         scenarioData.scenarioDescription = $("#scenario-description").val();
            //         scenarioData.scenarioDatetimeStart = $("#scenario-startDatetime").val();
            //         scenarioData.scenarioDatetimeEnd = $("#scenario-endDatetime").val();
            //         scenarioData.isPublic = $("#scenario-visibility").is(':checked');

            //         var ajaxData = {
            //             "method": "POST",
            //             "geojson": JSON.stringify(scenarioData)
            //         };

            //         $.ajax({
            //             type: 'GET',
            //             url: '../controllers/scenarioProxy.php',
            //             dataType: "json",
            //             contentType: 'application/json; charset=utf-8',
            //             async: true,
            //             data: ajaxData,
            //             success: function (resp) {
            //                 if (resp == "-1") {
            //                     alert("Scenario name already exists.");
            //                 }
            //                 else if (resp == "-2") {
            //                     alert("You must be logged in in order to create new scenarios.");
            //                 }
            //                 else {
            //                     alert("Scenario '" + $("#scenario-name").val() + "' saved");
            //                     $("#scenario-cancel").trigger("click");
            //                 }
            //             },
            //             error: function (errorData) {
            //                 console.log(errorData);
            //             }
            //         });
            //     }
            //     else if ($("#scenario-name").val() === "") {
            //         alert("You must enter a name for the current scenario.")
            //     }
            //     else if (scenarioData.features.length == 0) {
            //         alert("You must add at least one barrier for the current scenario.")
            //     }
            //     else if ($("#scenario-name").val().indexOf("(") > -1) {
            //         alert("You cannot enter special char '(' in the current scenario's name.");
            //     }
            // });

            // $("#scenario-cancel").click(function () {
            //     console.log("#scenario-cancel 4")
            //     map.defaultMapRef.removeLayer(scenarioDrawnItems);
            //     scenarioDrawnItems = new L.FeatureGroup();
            //     map.defaultMapRef.addLayer(scenarioDrawnItems);
            //     $("#scenario-name").val("");
            //     $("#scenario-description").val("");
            //     $("#scenario-startDatetime").val("");
            //     $("#scenario-endDatetime").val("");
            //     $("#scenario-visibility").prop('checked', false);

            //     scenarioData = new L.geoJSON();
            //     scenarioData.type = "FeatureCollection";
            //     scenarioData.features = [];
            // });
        }
    });

    $(document).on('removeScenario', function (event) {
        if (event.target === map.mapName) {
            map.defaultMapRef.removeLayer(scenarioLayer);
            map.defaultMapRef.removeControl(scenarioControl);
            map.defaultMapRef.removeControl(geocoderControl);
            map.defaultMapRef.removeControl(drawerControl);
            map.defaultMapRef.removeLayer(scenarioDrawnItems);
        }
    });

    var whatifLayer = null;
    var whatifControl = null;
    var whatifDrawnItems = null;
    var lrmControl = null;
    var vehicle = "car";
    var waypoints = null;
    var weighting = "fastest";
    var startDatetime = null;
    var studioControl = null;
    $(document).on('addWhatif', function (event) {
        if (event.target === map.mapName) {
            // create whatif layer and add to map
            whatifLayer = new L.FeatureGroup();
            map.defaultMapRef.addLayer(whatifLayer);
            // create what-if drawn items layer
            whatifDrawnItems = new L.FeatureGroup();
            map.defaultMapRef.addLayer(whatifDrawnItems);
            // create what-if control and add to map, populate scenarios
            whatifControl = L.control({ position: 'topright' });
            whatifControl.onAdd = function (map) {
                var div = L.DomUtil.create('div');

                div.innerHTML = '<div id="selection">' +
                    '<input type="radio" name="choice" value="scenario" checked> Select scenario<br>' +
                    '<input type="radio" name="choice" value="studio"> Select studio<br>' +
                    '<select style="margin-top:6px" class="form-control" id="choice-select"></select>' +
                    '<div style="margin-top:6px" id="resultDescription"></div>' +
                    '<div style="margin-top:6px" id="resultTimerange"></div>' +
                    '<div style="margin-top:6px" id="weighting">' +
                    '<label for="whatIf-weighting">Weighting</label>' +
                    '<select id="whatIf-weighting" class="form-control">' +
                    '<option value="fastest" selected="selected">Fastest</option>' +
                    '<option value="fastest_with_traffic">Fastest with traffic</option>' +
                    '<option value="shortest">Shortest</option>' +
                    '<option value="short_fastest">Short/Fastest</option>' +
                    '<option value="curvature">Curvature</option>' +
                    '</select></div>' +
                    '<div style="margin-top:6px" id="routing-datetime">' +
                    '<label for="whatIf-startDatetime" style="display: block">Start date & time</label>' +
                    '<input id="whatIf-startDatetime" type="datetime-local" class="form-control" name="datetimeFrom">' +
                    '</div>' +
                    '</div>' +
                    '<div id="options">' +
                    '<span id="vehicles">' +
                    '<button class="vehicle-btn selectedvehicle" title="Driving" id="car">' +
                    '<img src="../img/dynamic_routing/car.png" alt="Auto">' +
                    '</button>' +
                    '<button class="vehicle-btn" title="Walking" id="foot">' +
                    '<img src="../img/dynamic_routing/foot.png" alt="Foot">' +
                    '</button>' +
                    '<button class="vehicle-btn" title="Cycling" id="bike">' +
                    '<img src="../img/dynamic_routing/bike.png" alt="Bike">' +
                    '</button>' +
                    '<button class="vehicle-btn" title="Bus" id="bus">' +
                    '<img id="bus_button" src="../img/dynamic_routing/bus.svg" alt="Bus">' +
                    '</button>' +
                    '</span>' +
                    '</div>';
                // disable interaction of this div with map
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(div);
                    L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
                }

                return div;
            };
            whatifControl.addTo(map.defaultMapRef);
            // Hide datetime picker
            $("#routing-datetime").hide();

            // populate scenarios select (initially scenario choice is checked)
            $.getJSON('../controllers/scenarioProxy.php?method=GET&opt=name', function (data) {
                $("#choice-select").html("<option selected disabled hidden style='display: none' value=''></option>");
                function compareStrings(a, b) {
                    // Assuming you want case-insensitive comparison
                    a = a.toLowerCase();
                    b = b.toLowerCase();

                    return (a < b) ? -1 : (a > b) ? 1 : 0;
                }

                //sort the scenarios in alphabetical order
                data.sort(function (a, b) {
                    return compareStrings(a.name, b.name);
                    //                              return compareStrings(a.variable_value.scenarioName, b.variable_value.scenarioName);
                })

                for (var i = 0; i < data.length; i++)
                    $("#choice-select").html($("#choice-select").html() + '<option>' + data[i]['name'] + '</option>');
            });
            // checkbox (choice) management
            $("input[name='choice']").click(function () {
                //clear scenario description and time range
                $("#resultDescription").html("");
                $("#resultTimerange").html("");
                // reset page:
                // Hide routing mode options
                $("#options").hide();
                // remove lrm
                if (lrmControl) {
                    lrmControl.remove(map);
                    lrmControl = null;
                    waypoints = null;
                }
                // remove previous choice's drawings
                map.defaultMapRef.removeLayer(whatifDrawnItems);
                // remove previous studio div (if present)
                if (studioControl) {
                    map.defaultMapRef.removeControl(studioControl);
                    studioControl = null;
                }
                // end reset 

                // reload select content
                var choice = $(this).val();
                if (choice == "scenario") {
                    $.getJSON('../controllers/scenarioProxy.php?method=GET&opt=name', function (data) {
                        $("#choice-select").html("<option selected disabled hidden style='display: none' value=''></option>");
                        // add the same code for sorting scenarios
                        function compareStrings(a, b) {
                            // Assuming you want case-insensitive comparison
                            a = a.toLowerCase();
                            b = b.toLowerCase();

                            return (a < b) ? -1 : (a > b) ? 1 : 0;
                        }

                        //sort the scenarios in alphabetical order
                        data.sort(function (a, b) {
                            return compareStrings(a.name, b.name);
                            //                                      return compareStrings(a.variable_value.scenarioName, b.variable_value.scenarioName);
                        })
                        for (var i = 0; i < data.length; i++)
                            $("#choice-select").html($("#choice-select").html() + '<option>' + data[i]['name'] + '</option>');
                    });
                }
                else if (choice == "studio") {
                    $.getJSON('../controllers/studioProxy.php?method=GET&opt=name', function (data) {
                        $("#choice-select").html("<option selected disabled hidden style='display: none' value=''></option>");
                        for (var i = 0; i < data.length; i++)
                            $("#choice-select").html($("#choice-select").html() + '<option>' + data[i]['name'] + '</option>');
                    });
                }
            });
            // when the user chooses a scenario/studio, draw it on the map
            $('#choice-select').change(function () {
                var choice = $('input[name=choice]:checked').val();
                if (choice == "scenario") {
                    // scenarioName(visibility) -> we take only scenarioName
                    if ($(this).val().indexOf('(') > -1)
                        var selectedScenario = $(this).val().substr(0, $(this).val().indexOf('('));
                    // for guest visibility is not shown
                    else
                        var selectedScenario = $(this).val();

                    $.getJSON('../controllers/scenarioProxy.php?method=GET&sel=' + selectedScenario, function (selectedScenarioData) {
                        // add scenario description (selectedScenarioData contains the json in column variable_value)
                        if (selectedScenarioData.scenarioDescription)
                            $("#resultDescription").html('<strong>' + "Description: " + '</strong>' + '<span style="font-style:italic">' + selectedScenarioData.scenarioDescription + '</span>');
                        else
                            $("#resultDescription").html('<strong>' + "Description: " + '</strong>' + '<span style="font-style:italic">' + "Not Available." + '</span>');
                        // add scenario time range
                        if (selectedScenarioData.scenarioDatetimeStart)
                            $("#resultTimerange").html('<strong>' + "From: " + '</strong>' + '<span style="font-style:italic">' + selectedScenarioData.scenarioDatetimeStart + '<strong>' + " To " + '</strong>' + selectedScenarioData.scenarioDatetimeEnd + '</span>');
                        else
                            $("#resultTimerange").html('<strong>' + "Time Range: " + '</strong>' + '<span style="font-style:italic">' + "Not Available." + '</span>');

                        // remove previous choice's drawings
                        map.defaultMapRef.removeLayer(whatifDrawnItems);
                        whatifDrawnItems = new L.FeatureGroup();
                        map.defaultMapRef.addLayer(whatifDrawnItems);
                        if (lrmControl)
                            lrmControl.remove(map.defaultMapRef);
                        // draw selected scenario (feature collection)
                        L.geoJson(selectedScenarioData, {
                            onEachFeature: onEachFeature
                        });
                        function onEachFeature(feature, layer) {
                            // radius drawing management
                            if (feature.properties.radius != null)
                                L.circle(L.latLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]),
                                    feature.properties.radius)
                                    .addTo(whatifDrawnItems);
                            else
                                whatifDrawnItems.addLayer(layer);
                        }
                        // centre the map on the first feature
                        var firstShapeType = selectedScenarioData.features[0].geometry.type;
                        switch (firstShapeType) {
                            case 'Polygon':
                                map.defaultMapRef.panTo(new L.LatLng(selectedScenarioData.features[0].geometry.coordinates[0][0][1],
                                    selectedScenarioData.features[0].geometry.coordinates[0][0][0]));
                                break;
                            default:
                                map.defaultMapRef.panTo(new L.LatLng(selectedScenarioData.features[0].geometry.coordinates[1],
                                    selectedScenarioData.features[0].geometry.coordinates[0]));
                        }

                        // Show routing mode options and create related event listener
                        $("#options").show();
                        // remove previous click listener (if present)
                        $(".vehicle-btn").off("click");
                        $("#whatIf-weighting").off("change");
                        $("#whatIf-startDatetime").off("change");
                        var doRoute = function (vehicle) {
                            // Change active button
                            $('.selectedvehicle').removeClass('selectedvehicle');
                            $('#' + vehicle).addClass('selectedvehicle');

                            // TRICK: Reinit lrmControl, but with previous waypoints, in order to refresh the routing process
                            waypoints = lrmControl.getWaypoints();
                            if (lrmControl) {
                                lrmControl.remove(map);
                                lrmControl = null;
                            }

                            weighting = $('#whatIf-weighting').val();   // Get the selected weighting
                            startDatetime = $('#whatIf-startDatetime').val();   // Get the selected datetime

                            serviceUrl = setServiceUrl(orgParams, map.defaultMapRef.getBounds()["_northEast"]);
                            lrmControl = L.Routing.control({
                                // Servlet params
                                serviceUrl: serviceUrl,
                                waypoints: waypoints,
                                avoid_area: encodeURIComponent(JSON.stringify(selectedScenarioData)),
                                vehicle: vehicle,
                                weighting: weighting,
                                startDatetime: startDatetime,
                                // end Servlet params
                                geocoder: L.Control.Geocoder.nominatim(),
                                routeWhileDragging: true,
                                reverseWaypoints: true,
                                showAlternatives: false,
                                createMarker: function (i, wp) {
                                    var icon = L.icon({
                                        iconUrl: '../img/dynamic_routing/marker-icon-red.png',
                                        shadowUrl: '../img/dynamic_routing/marker-shadow.png',
                                        iconAnchor: [12, 41]
                                    });
                                    return L.marker(wp.latLng, {
                                        draggable: true,
                                        icon: icon
                                    });
                                }
                            });
                            lrmControl.addTo(map.defaultMapRef);
                            // MS
                            var lastSelectedRoute = null;
                            if (vehicle == "bus") {
                                $("#bus_button").css("opacity", 0.5);
                                var pwlng = Math.min(map.defaultMapRef.getBounds()["_northEast"]["lng"], map.defaultMapRef.getBounds()["_southWest"]["lng"]) + (Math.abs(map.defaultMapRef.getBounds()["_northEast"]["lng"] - map.defaultMapRef.getBounds()["_southWest"]["lng"]) / 2);
                                var pwlat = map.defaultMapRef.getBounds()["_northEast"]["lat"];
                                L.popup({ offset: L.point(0, 210) }).setLatLng(new L.LatLng(pwlat, pwlng)).setContent("<p><strong>Impact on Public Transport</strong></p><p>Computation in progress.</p><p>It may take some time.</p><p>Please wait...</p>").openOn(map.defaultMapRef);
                                var polygons = [];
                                // console.log(selectedScenarioData);
                                for (var f = 0; f < selectedScenarioData["features"].length; f++) {
                                    if (selectedScenarioData["features"][f]["geometry"]["type"] != "Polygon") {
                                        // a radius of 7684.888648492369 corresponds to a delta of 0.192811 in lat lon coordinates so one unit of radius corresponds to a displacement of 0.192811/7684.888648492369 ~ 0.000025 in lat lon 													
                                        //polygons.push("(("+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+", "+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+", "+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+", "+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+", "+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+"))");													
                                        //console.log("(("+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+", "+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+", "+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+", "+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+", "+selectedScenarioData["features"][f]["geometry"]["coordinates"][0]-0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+ " "+selectedScenarioData["features"][f]["geometry"]["coordinates"][1]+0.000025*selectedScenarioData["features"][f]["properties"]["radius"]+"))");
                                        var r = 0.0001;
                                        if (selectedScenarioData["features"][f]["properties"]["radius"]) r = 0.00001 * selectedScenarioData["features"][f]["properties"]["radius"];
                                        var x = selectedScenarioData["features"][f]["geometry"]["coordinates"][0];
                                        var y = selectedScenarioData["features"][f]["geometry"]["coordinates"][1];
                                        var tlx = x - r;
                                        var tly = y + r;
                                        var trx = x + r;
                                        var try_ = y + r;
                                        var brx = x + r;
                                        var bry = y - r;
                                        var blx = x - r;
                                        var bly = y - r;
                                        var p = "(( " + tlx + " " + tly + ", " + trx + " " + try_ + ", " + brx + " " + bry + ", " + blx + " " + bly + ", " + tlx + " " + tly + "))";
                                        // console.log(p);
                                        if (!polygons.includes(p)) polygons.push(p);
                                    }
                                    else {
                                        var minX = null;
                                        var maxX = null;
                                        var minY = null;
                                        var maxY = null;
                                        for (var c = 0; c < selectedScenarioData["features"][f]["geometry"]["coordinates"][0].length; c++) {
                                            var x = selectedScenarioData["features"][f]["geometry"]["coordinates"][0][c][0];
                                            var y = selectedScenarioData["features"][f]["geometry"]["coordinates"][0][c][1];
                                            if (minX == null || x < minX) minX = x;
                                            if (maxX == null || x > maxX) maxX = x;
                                            if (minY == null || y < minY) minY = y;
                                            if (maxY == null || y > maxY) maxY = y;
                                        }
                                        var tlx = minX;
                                        var blx = minX;
                                        var trx = maxX;
                                        var brx = maxX;
                                        var tly = maxY;
                                        var try_ = maxY;
                                        var bly = minY;
                                        var bry = minY;
                                        var polygon = " (( " + tlx + " " + tly + ", " + trx + " " + try_ + ", " + brx + " " + bry + ", " + blx + " " + bly + ", " + tlx + " " + tly + " )) ";
                                        if (!polygons.includes(polygon)) polygons.push(polygon);
                                    }
                                }
                                var closedZones = null;
                                if (polygons.length == 1) closedZones = "POLYGON" + polygons[0];
                                else if (polygons.length > 1) closedZones = "MULTIPOLYGON(" + polygons.join() + ")";
                                Date.prototype.getStandardTimezoneOffset = function () {
                                    var jan = new Date(this.getFullYear(), 0, 1);
                                    var jul = new Date(this.getFullYear(), 6, 1);
                                    return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
                                };
                                var fromDateTime = selectedScenarioData["scenarioDatetimeStart"] + ":00" + (new Date().getStandardTimezoneOffset() > 0 ? "-" : "+") + (("" + (Math.abs(new Date().getStandardTimezoneOffset() / 60))).padStart(2, "0")) + ":00";
                                var toDateTime = selectedScenarioData["scenarioDatetimeEnd"] + ":00" + (new Date().getStandardTimezoneOffset() > 0 ? "-" : "+") + (("" + (Math.abs(new Date().getStandardTimezoneOffset() / 60))).padStart(2, "0")) + ":00";
                                var whatifptiendpt = $.getJSON('<?= $whatifptiendpt ?>?closedZones=' + encodeURIComponent(closedZones) + '&fromDateTime=' + encodeURIComponent(fromDateTime) + '&toDateTime=' + encodeURIComponent(toDateTime), function (impact) {
                                    $("#bus_button").css("opacity", 1);
                                    var olng = Math.min(map.defaultMapRef.getBounds()["_northEast"]["lng"], map.defaultMapRef.getBounds()["_southWest"]["lng"]) + (Math.abs(map.defaultMapRef.getBounds()["_northEast"]["lng"] - map.defaultMapRef.getBounds()["_southWest"]["lng"]) / 2);
                                    var olat = map.defaultMapRef.getBounds()["_northEast"]["lat"];
                                    L.popup({ offset: L.point(0, 210) }).setLatLng(new L.LatLng(olat, olng)).setContent("<p><strong>Impact on Public Transport</strong></p><p>Affected Agencies: " + impact["metrics"]["agencies"] + "<br>Affected Routes: " + impact["metrics"]["routes"] + "<br>Affected Trips: " + impact["metrics"]["trips"] + (impact["metrics"]["ndr_trips"] > 0 ? " (<a href=\"#\" class=\"ndrTripsLink\" \">" + impact["metrics"]["ndr_trips"] + " mere crossings</a>)" : "") + "<br>Affected Stops: " + impact["metrics"]["stops"] + " (click on markers)<br>Eventual Traps: " + impact["metrics"]["traps"] + "</p>").openOn(map.defaultMapRef);
                                    var summary = { "offset": L.point(0, 210), "latlng": new L.LatLng(olat, olng), "content": "<p><strong>Impact on Public Transport</strong></p><p>Affected Agencies: " + impact["metrics"]["agencies"] + "<br>Affected Routes: " + impact["metrics"]["routes"] + "<br>Affected Trips: " + impact["metrics"]["trips"] + (impact["metrics"]["ndr_trips"] > 0 ? " (<a href=\"#\" class=\"ndrTripsLink\" \">" + impact["metrics"]["ndr_trips"] + " mere crossings</a>)" : "") + "<br>Affected Stops: " + impact["metrics"]["stops"] + " (click on markers)<br>Eventual Traps: " + impact["metrics"]["traps"] + "</p>" };
                                    $(".ndrTripsLink").click(function () {
                                        $(".whatifPolyline").hide();
                                        $(".whatifCrossingPolyline").hide();
                                        $(".affectedStopMarker").hide();
                                        var markup = "<p class=\"ndrt_stopHead\" style=\"width:300px;\"><strong style=\"font-size:larger;\">Crossing Trips</strong><br><span style=\"font-style:italic;\">Without affected stops</span></p>";
                                        var getDates = function (startDate, stopDate) {
                                            Date.prototype.addDays = function (days) {
                                                var date = new Date(this.valueOf());
                                                date.setDate(date.getDate() + days);
                                                return date;
                                            };
                                            var dateArray = new Array();
                                            var currentDate = startDate;
                                            while (currentDate <= stopDate) {
                                                dateArray.push(new Date(currentDate));
                                                currentDate = currentDate.addDays(1);
                                            }
                                            return dateArray;
                                        };
                                        var crosstrips = [];
                                        var crossmenu = {};
                                        var crosspolylines = [];
                                        for (var agency in impact["details"])
                                            for (var route in impact["details"][agency]["routes"])
                                                for (var trip in impact["details"][agency]["routes"][route]["trips"])
                                                    if ("Medium - Mere crossing" == impact["details"][agency]["routes"][route]["trips"][trip]["criticality"]) {
                                                        crosstrips.push(encodeURIComponent(trip));
                                                        if (!crossmenu[agency]) crossmenu[agency] = [];
                                                        impact["details"][agency]["routes"][route]["trips"][trip]["dates"].forEach(function (date) { if (!crossmenu[agency].includes(date)) crossmenu[agency].push(date); });
                                                        var path = impact["details"][agency]["routes"][route]["trips"][trip]["path"];
                                                        var latlngs = [];
                                                        path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                                            latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                                        });
                                                        var polyline = new L.Polyline(latlngs, { color: "#" + impact["details"][agency]["routes"][route]["color"], className: "whatifCrossingPolyline" });
                                                        crosspolylines.push({ "latlngs": latlngs, "color": impact["details"][agency]["routes"][route]["color"] });
                                                        polyline.addTo(whatifDrawnItems);
                                                    }
                                        for (var agency in crossmenu) {
                                            markup += "<p style=\"font-weight:bold;\">" + agency + "</p>";
                                            crossmenu[agency].forEach(function (date) {
                                                var btnUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(impact["details"][agency]["dataset"]) + '&crosstrip=' + crosstrips.join("&crosstrip=") + '&date=' + encodeURIComponent(getDates(new Date(date), new Date(date))[0].toISOString().split('T')[0]) + "&list=routes";
                                                markup += "<p class=\"ndrt_wifstpdt\"><button style=\"width:100%;\" data-url=\"" + btnUrl + "\" data-date=\"" + getDates(new Date(date), new Date(date))[0].toISOString().split('T')[0] + "\">" + getDates(new Date(date), new Date(date))[0].toLocaleDateString("en", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) + "</button></p>";
                                            });
                                        }
                                                    /*
                                                                                                        getDates(new Date(selectedScenarioData["scenarioDatetimeStart"].substring(0,10)),new Date(selectedScenarioData["scenarioDatetimeEnd"].substring(0,10))).forEach(function(oneDate){
                                                                                                            if(crossdates.includes(oneDate.toISOString().split('T')[0])) {					
                                                                                                                var btnUrl = '<?= $whatifmdtendpt ?>? agency = '+encodeURIComponent(impact["details"][agency]["dataset"])+' & crosstrip='+crosstrips.join("&crosstrip=")+' & date='+encodeURIComponent(oneDate.toISOString().split('T')[0])+"&list=routes";
                                                                                                                markup += "<p class=\"ndrt_wifstpdt\"><button style=\"width:100%;\" data-url=\"" + btnUrl + "\" data-date=\"" + oneDate.toISOString().split('T')[0] + "\"><strong>" + new Date(oneDate).toLocaleDateString("en", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) + "</strong></button></p>";
                                }
                                                                                                            else {
                                var btnUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(impact["details"][agency]["dataset"]) + '&crosstrip=' + crosstrips.join("&crosstrip=") + '&date=' + encodeURIComponent(oneDate.toISOString().split('T')[0]) + "&list=routes";
                                markup = "<p class=\"ndrt_wifstpdt\"><button style=\"width:100%;\" data-url=\"" + btnUrl + "\" data-date=\"" + oneDate.toISOString().split('T')[0] + "\">" + new Date(oneDate).toLocaleDateString("en", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) + "</button></p>";
                            }
                        });	
                                                    */
                    var pwlng = Math.min(map.defaultMapRef.getBounds()["_northEast"]["lng"], map.defaultMapRef.getBounds()["_southWest"]["lng"]) + (Math.abs(map.defaultMapRef.getBounds()["_northEast"]["lng"] - map.defaultMapRef.getBounds()["_southWest"]["lng"]) / 2);
                    var pwlat = map.defaultMapRef.getBounds()["_northEast"]["lat"];
                    markup += "<p class=\"ndrt_backToSummary\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                    L.popup({ offset: L.point(0, 210) }).setLatLng(new L.LatLng(pwlat, pwlng)).setContent(markup).openOn(map.defaultMapRef);
                    $("p.ndrt_backToSummary button").click(function () {
                        //L.popup({offset: summary["offset"]}).setLatLng(summary["latlng"]).setContent(summary["content"]).openOn(map.defaultMapRef);
                        $("#bus").click();
                    });
                    $("p.ndrt_wifstpdt button").click(function () {
                        var wifstpdtbtn = $(this);
                        var wifstpdtbtnhtml = $(this).html();
                        $(this).html("Please wait...");
                        var container = $(this).parent().parent();
                        var date = $(this).data("date");
                        //$.getJSON( $(this).data("url"), function(routes) {
                        $.post($(this).data("url").split("?")[0], $(this).data("url").split("?")[1], function (routes) {
                            container.find("p").hide();
                            wifstpdtbtn.html(wifstpdtbtnhtml);
                            var routesMarkup = "<p class=\"ndrt_routesSubHead\" style=\"background-color:black; color:white; padding:0.5em;\"><strong>Date:</strong>&nbsp;" + new Date(date).toLocaleDateString("en", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) + "</p>";
                            Object.keys(routes).forEach(function (key) {
                                var route = routes[key];
                                                                /*var affected = Object.keys(impact["details"][agency]["routes"]).includes(route["type"]+" "+route["short_name"]+" "+route["long_name"]);
                                                                if(false && affected) {
                                                                    var rteBtnUrl='<?= $whatifmdtendpt ?>?agency = '+encodeURIComponent(route["dataset"])+"&route="+encodeURIComponent(route["uri"])+"&crosstrip="+crosstrips.join("&crosstrip=")+"&date="+encodeURIComponent(date)+"&list=trips";
                                routesMarkup += "<p class=\"ndrt_wifstprte\"><button data-url=\"" + rteBtnUrl + "\" data-geoms=\"" + route["geoms"].join("|") + "\" data-key=\"" + key + "\" style=\"width:100%; background-color:#" + route["color"] + "; color:#" + route["text_color"] + "\"><strong>" + route["type"] + " " + route["short_name"] + " " + route["long_name"] + "</strong></button></p>";
                            }
                                                                else { */
                                                                    var rteBtnUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(route["dataset"]) + "&route=" + encodeURIComponent(route["uri"]) + "&crosstrip=" + crosstrips.join("&crosstrip=") + "&date=" + encodeURIComponent(date) + "&list=trips";
                            routesMarkup += "<p class=\"ndrt_wifstprte\"><button data-url=\"" + rteBtnUrl + "\" data-geoms=\"" + route["geoms"].join("|") + "\" data-key=\"" + key + "\" style=\"width:100%; background-color:#" + route["color"] + "; color:#" + route["text_color"] + "\">" + route["type"] + " " + route["short_name"] + " " + route["long_name"] + "</button></p>";
                            // }

                        });
                        routesMarkup += "<p class=\"ndrt_backToHome\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                        container.find("p.ndrt_stopHead").show();
                        container.find("p.ndrt_routesSubHead").remove();
                        container.find("p.ndrt_wifstprte").remove();
                        container.find("p.ndrt_backToHome").remove();
                        container.append($(routesMarkup));
                        $("p.ndrt_backToHome button").click(function () {
                            container.find("p").hide();
                            container.find("p.ndrt_stopHead").show();
                            container.find("p.ndrt_wifstpdt").show();
                            container.find("p.ndrt_backToSummary").show();
                        });
                        $("p.ndrt_wifstprte button").click(function () {
                            var wifstprtebtn = $(this);
                            var wifstprtebtnhtml = $(this).html();
                            $(this).html("Please wait...");
                            $(".whatifPolyline").hide();
                            $(".whatifCrossingPolyline").hide();
                            $(this).data("geoms").split("|").forEach(function (path) {
                                var latlngs = [];
                                path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                    latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                });
                                var polyline = new L.Polyline(latlngs, { color: wifstprtebtn.css("background-color"), className: "whatifCrossingPolyline" });
                                polyline.addTo(whatifDrawnItems);
                            });
                            var hrRouteTxt = $(this).data("key");
                            if (hrRouteTxt != lastSelectedRoute) $(".currentTripMarkers").hide();
                            lastSelectedRoute = hrRouteTxt;

                            var bg = $(this).css("background-color");
                            var fg = $(this).css("color");
                            $.post($(this).data("url").split("?")[0], $(this).data("url").split("?")[1], function (trips) {
                                container.find("p").hide();
                                wifstprtebtn.html(wifstprtebtnhtml);
                                container.find("p.ndrt_stopHead").show();
                                var affectedTripsMarkup = "";
                                var tripsMarkup = "<p class=\"ndrt_tripsSubHead\" style=\"background-color:black; color:white; padding:0.5em;\"><strong>Date:</strong>&nbsp;" + new Date(date).toLocaleDateString("en", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) + "<br><strong>Route:</strong>&nbsp;" + hrRouteTxt + "</p><div style=\"height:200px; max-height:200px; overflow:scroll; border: medium solid black; padding:0.5em;\" class=\"ndrt_tripsDivInRoute\"><p class=\"ndrt_preserveplease\" style=\"margin:0px 0; display:none;\"><strong>Affected Trips:</strong></p><div id=\"affectedtrips\"></div><p class=\"ndrt_preserveplease\" style=\"margin:0px 0;\"><strong style=\"display:none;\">All Trips:</strong></p>";
                                Object.keys(trips).sort(function (a, b) {
                                    if (trips[a]["start"] > trips[b]["start"]) return 1; else return -1;
                                }).forEach(function (tripkey) {
                                    var trip = trips[tripkey];
                                                                        /*var affectedtrip = Object.keys(impact["details"][agency]["routes"][hrRouteTxt]["trips"]).includes(tripkey);
                                                                        if(false && affectedtrip) { 
                                                                            var theTripUrl = '<?= $whatifmdtendpt ?>?agency = '+encodeURIComponent(trip["dataset"])+"&trip="+encodeURIComponent(trip["uri"])+"&list=stops";
                                    addToTripsMarkup = "<p class=\"ndrt_wifstptrp\"><button style=\"padding:0.2em; text-align:left; font-size:larger; width:100%; background-color:" + bg + "; color: " + fg + ";\" data-tripkey=\"" + tripkey + "\" data-path=\"" + trip["path"] + "\" data-url=\"" + theTripUrl + "\" data-routebgcolor=\"" + trip["route"]["bg_color"] + "\" data-routefgcolor=\"" + trip["route"]["fg_color"] + "\" data-routeshortname=\"" + trip["route"]["short_name"] + "\" data-routelongname=\"" + trip["route"]["long_name"] + "\" data-routetype=\"" + trip["route"]["type"] + "\" data-agencyname=\"" + trip["route"]["agency"] + "\"><strong>" + trip["start"].substring(0, 5) + "&nbsp;<span style=\"border:thin solid " + fg + "; padding:0.2em; font-size:smaller;\">" + (trip["direction"] == "0" ? "&rharu;" : "&lhard;") + "</span>&nbsp;" + trip["headsign"] + "</strong></button></p>";
                                    tripsMarkup += addToTripsMarkup;
                                    affectedTripsMarkup += addToTripsMarkup;
                                }
                                                                        else { */
                                                                            var theTripUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(trip["dataset"]) + "&trip=" + encodeURIComponent(trip["uri"]) + "&list=stops";
                                tripsMarkup += "<p class=\"ndrt_wifstptrp\"><button style=\"text-align:left; font-size:smaller; width:100%; background-color:" + bg + "; color:" + fg + ";\" data-tripkey=\"" + tripkey + "\" data-path=\"" + trip["path"] + "\" data-url=\"" + theTripUrl + "\" data-routebgcolor=\"" + trip["route"]["bg_color"] + "\" data-routefgcolor=\"" + trip["route"]["fg_color"] + "\" data-routeshortname=\"" + trip["route"]["short_name"] + "\" data-routelongname=\"" + trip["route"]["long_name"] + "\" data-routetype=\"" + trip["route"]["type"] + "\" data-agencyname=\"" + trip["route"]["agency"] + "\">" + trip["start"].substring(0, 5) + "&nbsp;<span style=\"border:thin solid " + fg + "; padding:0.2em;\">" + (trip["direction"] == "0" ? "&rharu;" : "&lhard;") + "</span>&nbsp;" + trip["headsign"] + "</button></p>";
                                //}

                            });
                            tripsMarkup += "</div>";
                            tripsMarkup += "<p class=\"ndrt_backToRoutes\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                            container.find("p.ndrt_tripsSubHead").remove();
                            container.find("div.ndrt_tripsDivInRoute").remove();
                            container.find("p.ndrt_backToRoutes").remove();
                            container.append($(tripsMarkup));
                            $("div#ndrt_affectedtrips").append($(affectedTripsMarkup));
                            $("p.ndrt_backToRoutes button").click(function () {
                                container.find("p").hide();
                                container.find("div.ndrt_tripsDivInRoute").hide();
                                $(".whatifPolyline").hide();
                                $(".whatifCrossingPolyline").hide();
                                $(".currentTripMarkers").hide();
                                container.find("p.ndrt_stopHead").show();
                                container.find("p.ndrt_routesSubHead").show();
                                container.find("p.ndrt_wifstprte").show();
                                container.find("p.ndrt_backToHome").show();
                                crosspolylines.forEach(function (polydata) {
                                    var polyline = new L.Polyline(polydata.latlngs, { color: "#" + polydata.color, className: "whatifCrossingPolyline" });
                                    polyline.addTo(whatifDrawnItems);
                                });
                            });
                            $("p.ndrt_wifstptrp button").click(function () {
                                var wifstptrpbtn = $(this);
                                var wifstptrpbtnhtml = $(this).html();
                                /*container.find("p.tripsSubHead").hide();
                                container.find("p.wifstptrp").hide();
                                container.find("p.backToRoutes").hide();
                                container.find("div.tripsDivInRoute").hide();
                                $(".currentTripMarkers").hide();*/
                                var theaffectedstopsMarkup = "";
                                var theTripMarkup = "<p class=\"ndrt_theTripSubhead\" style=\"background-color:black; color:white;  padding:0.5em;\"><strong>Agency:</strong>&nbsp;" + $(this).data("agencyname") + "<br><strong>Route:</strong>&nbsp;" + $(this).data("routetype") + " " + $(this).data("routeshortname") + " " + $(this).data("routelongname") + "<br><strong>Trip:</strong>&nbsp;" + $(this).html().replace("<strong>", "").replace("</strong>", "") + "</p><div class=\"ndrt_fullTripData\" style=\"height:150px; max-height:150px; overflow:scroll; font-size:smaller; border: medium solid black; padding:0.5em;\"><p style=\"margin:0px 0;\"><strong>Affected Stops:</strong></p><div id=\"ndrt_affectedstops\"></div><p style=\"margin:0px 0;\"><strong>All Stops:</strong><br>&nbsp;</p>";
                                $(this).html("Please wait...");
                                var bgcolor = $(this).data("routebgcolor");
                                var fgcolor = $(this).data("routefgcolor");
                                var routetype = $(this).data("routetype");
                                var path = $(this).data("path");
                                var tripkey = $(this).data("tripkey");
                                /*$(".whatifPolyline").hide();
                                var latlngs = [];
                                path.split("((")[1].split("))")[0].split(",").forEach(function(node){
                                    latlngs.push(new L.LatLng(node.trim().split(" ")[1],node.trim().split(" ")[0]));
                                });
                                var polyline = new L.Polyline(latlngs,{color:"#"+bgcolor,className:"whatifPolyline"});
                                polyline.addTo(whatifDrawnItems);*/


                                $.getJSON($(this).data("url"), function (tripdata) {
                                    //
                                    container.find("p.ndrt_tripsSubHead").hide();
                                    container.find("p.ndrt_wifstptrp").hide();
                                    container.find("p.ndrt_backToRoutes").hide();
                                    container.find("div.ndrt_tripsDivInRoute").hide();
                                    wifstptrpbtn.html(wifstptrpbtnhtml);
                                    $(".currentTripMarkers").hide();
                                    $(".whatifPolyline").hide();
                                    $(".whatifCrossingPolyline").hide();
                                    var latlngs = [];
                                    path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                        latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                    });
                                    var polyline = new L.Polyline(latlngs, { color: "#" + bgcolor, className: "whatifCrossingPolyline" });
                                    polyline.addTo(whatifDrawnItems);
                                    //
                                    tripdata.forEach(function (oneStop) {
                                        var isaffectedstop = false;
                                        try {
                                            isaffectedstop = Object.keys(impact["details"][agency]["routes"][hrRouteTxt]["trips"][tripkey]["stops"]).includes(oneStop["sequence"] + " " + oneStop["code"] + " " + oneStop["name"]);
                                        } catch (nabp) { }

                                        if (isaffectedstop) {
                                            theTripMarkup += "<button style=\"font-size:larger; font-weight:bold; cursor:default; text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + ";\" disabled><strong>Sequence:</strong>&nbsp;" + oneStop["sequence"] + "<br><strong>Code:</strong>&nbsp;" + oneStop["code"] + "<br><strong>Name:</strong>&nbsp;" + oneStop["name"] + "<br><strong>Arrival:</strong>&nbsp;" + oneStop["arrival"].substring(0, 5) + "<br><strong>Departure:</strong>&nbsp;" + oneStop["departure"].substring(0, 5) + "</button>";
                                            theaffectedstopsMarkup += "<button style=\"font-size:larger; font-weight:bold; cursor:default; text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + ";\" disabled><strong>Sequence:</strong>&nbsp;" + oneStop["sequence"] + "<br><strong>Code:</strong>&nbsp;" + oneStop["code"] + "<br><strong>Name:</strong>&nbsp;" + oneStop["name"] + "<br><strong>Arrival:</strong>&nbsp;" + oneStop["arrival"].substring(0, 5) + "<br><strong>Departure:</strong>&nbsp;" + oneStop["departure"].substring(0, 5) + "</button>";
                                        }
                                        else {
                                            theTripMarkup += "<button style=\"cursor:default; text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + ";\" disabled><strong>Sequence:</strong>&nbsp;" + oneStop["sequence"] + "<br><strong>Code:</strong>&nbsp;" + oneStop["code"] + "<br><strong>Name:</strong>&nbsp;" + oneStop["name"] + "<br><strong>Arrival:</strong>&nbsp;" + oneStop["arrival"].substring(0, 5) + "<br><strong>Departure:</strong>&nbsp;" + oneStop["departure"].substring(0, 5) + "</button>";
                                        }
                                        var markerAlreadyThere = false;
                                        map.defaultMapRef.eachLayer(function (layer) { if (layer instanceof L.Marker) { if (layer.getLatLng()["lat"] == oneStop["pos_lat"] && layer.getLatLng()["lng"] == oneStop["pos_lon"] && $(layer._icon).is(":visible")) { markerAlreadyThere = true; } else { } } });
                                        if (!markerAlreadyThere) {
                                            var stopMarker = L.marker([oneStop["pos_lat"], oneStop["pos_lon"]], {
                                                icon: new L.Icon({
                                                    iconUrl: routetype == "Bus" ? 'https://servicemap.disit.org/WebAppGrafo/img/mapicons/TransferServiceAndRenting_BusStop.png' : 'https://servicemap.disit.org/WebAppGrafo/img/mapicons/TransferServiceAndRenting_Tram_stops.png'
                                                }), uri: oneStop["uri"], title: (oneStop["departure"] ? oneStop["departure"] : oneStop["arrival"]).substring(0, 5) + " | " + oneStop["code"] + " " + oneStop["name"], stopname: oneStop["name"]
                                            });
                                            stopMarker.addTo(whatifDrawnItems);
                                            $(stopMarker._icon).addClass("currentTripMarkers");
                                            if (!isaffectedstop) {
                                                $(stopMarker._icon).css("width", "24px");
                                            }
                                        }
                                    });
                                    theTripMarkup += "</div>";
                                    theTripMarkup += "<p class=\"ndrt_backToTrips\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                                    container.find("p.ndrt_theTripSubhead").remove();
                                    container.find("div.ndrt_fullTripData").remove();
                                    container.find("p.ndrt_backToTrips").remove();
                                    container.append($(theTripMarkup));
                                    if (theaffectedstopsMarkup == "") {
                                        theaffectedstopsMarkup = "<p>No stops of this specific trip are affected by the current scenario.</p>";
                                    }
                                    $("div#ndrt_affectedstops").append($(theaffectedstopsMarkup));
                                    $("p.ndrt_backToTrips button").click(
                                        function () {
                                            container.find("p").hide();
                                            container.find("div.ndrt_fullTripData").hide();
                                            container.find("p.ndrt_stopHead").show();
                                            container.find("p.ndrt_tripsSubHead").show();
                                            container.find("div.ndrt_tripsDivInRoute").show();
                                            container.find("p.ndrt_preserveplease").show();
                                            container.find("p.ndrt_wifstptrp").show();
                                            container.find("p.ndrt_backToRoutes").show();
                                            $(".currentTripMarkers").hide(); // it was commented
                                        }


                                    );
                                });

                            });

                        }, "json");

                    });
                }, "json");
        });
    return;
                                                });

    var stopdates = {};
    Object.keys(impact["details"]).forEach(function (agency) {
        if (agency != "traps") {
            var agencyPolylines = [];
            Object.keys(impact["details"][agency]["routes"]).forEach(function (route) {
                var color = impact["details"][agency]["routes"][route]["color"];
                var type = impact["details"][agency]["routes"][route]["type"];
                Object.keys(impact["details"][agency]["routes"][route]["trips"]).forEach(function (trip) {
                    var path = impact["details"][agency]["routes"][route]["trips"][trip]["path"];
                    var criticality = impact["details"][agency]["routes"][route]["trips"][trip]["criticality"];
                    var latlngs = [];
                    path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                        latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                    });
                    var polyline = new L.Polyline(latlngs, { className: criticality == "Medium - Mere crossing" ? "whatifCrossingPolyline" : "whatifPolyline", color: "#" + color });
                    //polyline.bindTooltip(impact["details"][agency]["routes"][route]["short_name"], {permanent: true});
                    agencyPolylines.push({ "latlngs": latlngs, "criticality": criticality, "color": color });
                    polyline.addTo(whatifDrawnItems);
                    if ("stops" in impact["details"][agency]["routes"][route]["trips"][trip]) Object.keys(impact["details"][agency]["routes"][route]["trips"][trip]["stops"]).forEach(function (stop) {
                        /*var icon = new L.Icon({
                          iconUrl: type=="Bus"?'https://servicemap.disit.org/WebAppGrafo/img/mapicons/TransferServiceAndRenting_BusStop.png':'https://servicemap.disit.org/WebAppGrafo/img/mapicons/TransferServiceAndRenting_Tram_stops.png'
                        });*/
                        //
                        if (!stopdates[stop]) stopdates[stop] = impact["details"][agency]["routes"][route]["trips"][trip]["dates"]; else stopdates[stop] = stopdates[stop].concat(impact["details"][agency]["routes"][route]["trips"][trip]["dates"]);
                        var mapBusStopPinImg = '../img/gisMapIcons/TransferServiceAndRenting_BusStop.png';
                        if (impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["busStopCategory"]) {
                            mapBusStopPinImg = '../img/gisMapIcons/' + impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["busStopCategory"] + '.png';
                        }
                        else {
                            if (agency == "ATAF&LINEA" || agency == "GEST") {
                                mapBusStopPinImg = '../img/gisMapIcons/TransferServiceAndRenting_BusStop_Urban.png'
                            }
                            else {
                                mapBusStopPinImg = '../img/gisMapIcons/TransferServiceAndRenting_BusStop_Suburban.png'
                            }
                        }
                        var icon = L.icon({
                            iconUrl: mapBusStopPinImg,
                            iconAnchor: [16, 37]
                        });
                        //
                        var marker = L.marker([impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["pos_lat"], impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["pos_lon"]], { icon: icon, title: impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["code"] + " " + impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["name"], uri: impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["uri"] });
                        // Preparing the popup content (old way commented)																	
                        /*
                        
                        var arrivals = [];
                        var departures = [];
                        Object.keys(impact["details"][agency]["routes"]).forEach(function(iroute){
                            Object.keys(impact["details"][agency]["routes"][iroute]["trips"]).forEach(function(itrip){
                                if("stops" in impact["details"][agency]["routes"][iroute]["trips"][itrip]) Object.keys(impact["details"][agency]["routes"][iroute]["trips"][itrip]["stops"]).forEach(function(istop){
                                    if(impact["details"][agency]["routes"][iroute]["trips"][itrip]["stops"][istop]["code"]+" "+impact["details"][agency]["routes"][iroute]["trips"][itrip]["stops"][istop]["name"] == impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["code"]+" "+impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["name"]) {
                                        arrivals.push(impact["details"][agency]["routes"][iroute]["trips"][itrip]["stops"][istop]["arrival"].substring(0,5));
                                        departures.push(impact["details"][agency]["routes"][iroute]["trips"][itrip]["stops"][istop]["departure"].substring(0,5));
                                    }
                                });
                            });
                        });																	
                        marker.bindPopup("<p><strong style=\"font-size:larger;\">"+impact["details"][agency]["name"]+" - "+impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["name"]+"</strong></p><p><strong style=\"font-size:smaller;\">Affected arrivals: </strong>"+arrivals.sort().join(" ")+"</p><p><strong style=\"font-size:smaller;\">Affected departures: </strong>"+departures.sort().join(" ")+"</p>");
                        
                        */

                        marker.on('click', function (e) {

                            $(".whatifCrossingPolyline").hide();
                            var stopUri = e.target.options.uri;

                            if (!e.target._popup) {
                                var markup = "<p class=\"stopHead\"><strong style=\"font-size:larger;\">" + impact["details"][agency]["name"] + " - " + impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["name"] + "</strong></p>";
                                var getDates = function (startDate, stopDate) {
                                    Date.prototype.addDays = function (days) {
                                        var date = new Date(this.valueOf());
                                        date.setDate(date.getDate() + days);
                                        return date;
                                    };
                                    var dateArray = new Array();
                                    var currentDate = startDate;
                                    while (currentDate <= stopDate) {
                                        dateArray.push(new Date(currentDate));
                                        currentDate = currentDate.addDays(1);
                                    }
                                    return dateArray;
                                };
                                getDates(new Date(selectedScenarioData["scenarioDatetimeStart"].substring(0, 10)), new Date(selectedScenarioData["scenarioDatetimeEnd"].substring(0, 10))).forEach(function (oneDate) {
                                    if (stopdates[stop].includes(oneDate.toISOString().split('T')[0])) {
                                        var btnUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(impact["details"][agency]["dataset"]) + '&stop=' + encodeURIComponent(impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["uri"]) + '&date=' + encodeURIComponent(oneDate.toISOString().split('T')[0]) + "&list=routes";
                                        markup += "<p class=\"wifstpdt\"><button style=\"width:100%;\" data-url=\"" + btnUrl + "\" data-stop=\"" + stopUri + "\" data-date=\"" + oneDate.toISOString().split('T')[0] + "\"><strong>" + new Date(oneDate).toLocaleDateString("en", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) + "</strong></button></p>";
                                    }
                                    else {
                                        var btnUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(impact["details"][agency]["dataset"]) + '&stop=' + encodeURIComponent(impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["uri"]) + '&date=' + encodeURIComponent(oneDate.toISOString().split('T')[0]) + "&list=routes";
                                        markup += "<p class=\"wifstpdt\"><button style=\"width:100%;\" data-url=\"" + btnUrl + "\" data-stop=\"" + stopUri + "\" data-date=\"" + oneDate.toISOString().split('T')[0] + "\">" + new Date(oneDate).toLocaleDateString("en", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) + "</button></p>";
                                    }
                                });
                                markup += "<p class=\"backToSummary\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                                e.target.bindPopup(markup);
                                e.target.fire("click");
                                $("p.backToSummary button").click(function () {
                                    $("#bus").click();
                                });
                                $("p.wifstpdt button").click(function () {
                                    var wifstpdtbtn = $(this);
                                    var wifstpdtbtnhtml = $(this).html();
                                    $(this).html("Please wait...");
                                    var container = $(this).parent().parent();
                                    var date = $(this).data("date");
                                    $.getJSON($(this).data("url"), function (routes) {
                                        container.find("p").hide();
                                        wifstpdtbtn.html(wifstpdtbtnhtml);
                                        var routesMarkup = "<p class=\"routesSubHead\" style=\"background-color:black; color:white; padding:0.5em;\"><strong>Date:</strong>&nbsp;" + new Date(date).toLocaleDateString("en", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) + "</p>";
                                        Object.keys(routes).forEach(function (key) {
                                            var route = routes[key];
                                            var affected = Object.keys(impact["details"][agency]["routes"]).includes(route["type"] + " " + route["short_name"] + " " + route["long_name"]);
                                            if (affected) {
                                                var rteBtnUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(route["dataset"]) + "&route=" + encodeURIComponent(route["uri"]) + "&stop=" + stopUri + "&date=" + encodeURIComponent(date) + "&list=trips";
                                                routesMarkup += "<p class=\"wifstprte\"><button data-url=\"" + rteBtnUrl + "\" data-geoms=\"" + route["geoms"].join("|") + "\" data-key=\"" + key + "\" style=\"width:100%; background-color:#" + route["color"] + "; color:#" + route["text_color"] + "\"><strong>" + route["type"] + " " + route["short_name"] + " " + route["long_name"] + "</strong></button></p>";
                                            }
                                            else {
                                                var rteBtnUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(route["dataset"]) + "&route=" + encodeURIComponent(route["uri"]) + "&stop=" + stopUri + "&date=" + encodeURIComponent(date) + "&list=trips";
                                                routesMarkup += "<p class=\"wifstprte\"><button data-url=\"" + rteBtnUrl + "\" data-geoms=\"" + route["geoms"].join("|") + "\" data-key=\"" + key + "\" style=\"width:100%; background-color:#" + route["color"] + "; color:#" + route["text_color"] + "\">" + route["type"] + " " + route["short_name"] + " " + route["long_name"] + "</button></p>";
                                            }

                                        });
                                        routesMarkup += "<p class=\"backToHome\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                                        container.find("p.stopHead").show();
                                        container.find("p.routesSubHead").remove();
                                        container.find("p.wifstprte").remove();
                                        container.find("p.backToHome").remove();
                                        container.append($(routesMarkup));
                                        $("p.backToHome button").click(function () {
                                            container.find("p").hide();
                                            container.find("p.stopHead").show();
                                            container.find("p.wifstpdt").show();
                                            container.find("p.backToSummary").show();
                                        });
                                        $("p.wifstprte button").click(function () {
                                            var wifstprtebtn = $(this);
                                            var wifstprtebtnhtml = $(this).html();
                                            $(this).html("Please wait...");
                                            $(".whatifPolyline").hide();
                                            $(".whatifCrossingPolyline").hide();
                                            $(this).data("geoms").split("|").forEach(function (path) {
                                                var latlngs = [];
                                                path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                                    latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                                });
                                                var polyline = new L.Polyline(latlngs, { color: "#" + color, className: "whatifPolyline" });
                                                polyline.addTo(whatifDrawnItems);

                                            });
                                            var hrRouteTxt = $(this).data("key");
                                            if (hrRouteTxt != lastSelectedRoute) $(".currentTripMarkers").hide();
                                            lastSelectedRoute = hrRouteTxt;

                                            var bg = $(this).css("background-color");
                                            var fg = $(this).css("color");
                                            $.getJSON($(this).data("url"), function (trips) {
                                                container.find("p").hide();
                                                wifstprtebtn.html(wifstprtebtnhtml);
                                                container.find("p.stopHead").show();
                                                var affectedTripsMarkup = "";
                                                var tripsMarkup = "<p class=\"tripsSubHead\" style=\"background-color:black; color:white; padding:0.5em;\"><strong>Date:</strong>&nbsp;" + new Date(date).toLocaleDateString("en", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) + "<br><strong>Route:</strong>&nbsp;" + hrRouteTxt + "</p><div style=\"height:200px; max-height:200px; overflow:scroll; border: medium solid black; padding:0.5em;\" class=\"tripsDivInRoute\"><p class=\"preserveplease\" style=\"margin:0px 0;\"><strong>Affected Trips:</strong></p><div id=\"affectedtrips\"></div><p class=\"preserveplease\" style=\"margin:0px 0;\"><strong>All Trips:</strong></p>";
                                                Object.keys(trips).sort(function (a, b) {
                                                    if (trips[a]["start"] > trips[b]["start"]) return 1; else return -1;
                                                }).forEach(function (tripkey) {
                                                    var trip = trips[tripkey];
                                                    var affectedtrip = Object.keys(impact["details"][agency]["routes"][hrRouteTxt]["trips"]).includes(tripkey);
                                                    if (affectedtrip) {
                                                        var theTripUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(trip["dataset"]) + "&trip=" + encodeURIComponent(trip["uri"]) + "&list=stops";
                                                        addToTripsMarkup = "<p class=\"wifstptrp\"><button style=\"padding:0.2em; text-align:left; font-size:larger; width:100%; background-color:" + bg + "; color: " + fg + ";\" data-tripkey=\"" + tripkey + "\" data-path=\"" + trip["path"] + "\" data-url=\"" + theTripUrl + "\" data-routebgcolor=\"" + trip["route"]["bg_color"] + "\" data-routefgcolor=\"" + trip["route"]["fg_color"] + "\" data-routeshortname=\"" + trip["route"]["short_name"] + "\" data-routelongname=\"" + trip["route"]["long_name"] + "\" data-routetype=\"" + trip["route"]["type"] + "\" data-agencyname=\"" + trip["route"]["agency"] + "\"><strong>" + trip["start"].substring(0, 5) + "&nbsp;<span style=\"border:thin solid " + fg + "; padding:0.2em; font-size:smaller;\">" + (trip["direction"] == "0" ? "&rharu;" : "&lhard;") + "</span>&nbsp;" + trip["headsign"] + "</strong></button></p>";
                                                        tripsMarkup += addToTripsMarkup;
                                                        affectedTripsMarkup += addToTripsMarkup;
                                                    }
                                                    else {
                                                        var theTripUrl = '<?= $whatifmdtendpt ?>?agency=' + encodeURIComponent(trip["dataset"]) + "&trip=" + encodeURIComponent(trip["uri"]) + "&list=stops";
                                                        tripsMarkup += "<p class=\"wifstptrp\"><button style=\"text-align:left; font-size:smaller; width:100%; background-color:" + bg + "; color:" + fg + ";\" data-tripkey=\"" + tripkey + "\" data-path=\"" + trip["path"] + "\" data-url=\"" + theTripUrl + "\" data-routebgcolor=\"" + trip["route"]["bg_color"] + "\" data-routefgcolor=\"" + trip["route"]["fg_color"] + "\" data-routeshortname=\"" + trip["route"]["short_name"] + "\" data-routelongname=\"" + trip["route"]["long_name"] + "\" data-routetype=\"" + trip["route"]["type"] + "\" data-agencyname=\"" + trip["route"]["agency"] + "\">" + trip["start"].substring(0, 5) + "&nbsp;<span style=\"border:thin solid " + fg + "; padding:0.2em;\">" + (trip["direction"] == "0" ? "&rharu;" : "&lhard;") + "</span>&nbsp;" + trip["headsign"] + "</button></p>";
                                                    }

                                                });
                                                tripsMarkup += "</div>";
                                                tripsMarkup += "<p class=\"backToRoutes\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                                                container.find("p.tripsSubHead").remove();
                                                container.find("div.tripsDivInRoute").remove();
                                                container.find("p.backToRoutes").remove();
                                                container.append($(tripsMarkup));
                                                $("div#affectedtrips").append($(affectedTripsMarkup));
                                                $("p.backToRoutes button").click(function () {
                                                    container.find("p").hide();
                                                    container.find("div.tripsDivInRoute").hide();
                                                    $(".whatifPolyline").hide();
                                                    $(".whatifCrossingPolyline").hide();
                                                    $(".currentTripMarkers").hide();
                                                    container.find("p.stopHead").show();
                                                    container.find("p.routesSubHead").show();
                                                    container.find("p.wifstprte").show();
                                                    container.find("p.backToHome").show();
                                                    agencyPolylines.forEach(function (polydata) {
                                                        var polyline = new L.Polyline(polydata["latlngs"], { className: polydata["criticality"] == "Medium - Mere crossing" ? "whatifCrossingPolyline" : "whatifPolyline", color: "#" + polydata["color"] });
                                                        polyline.addTo(whatifDrawnItems);
                                                    });
                                                    $(".whatifCrossingPolyline").hide();
                                                });
                                                $("p.wifstptrp button").click(function () {
                                                    var wifstptrpbtn = $(this);
                                                    var wifstptrpbtnhtml = $(this).html();
                                                    /*container.find("p.tripsSubHead").hide();
                                                    container.find("p.wifstptrp").hide();
                                                    container.find("p.backToRoutes").hide();
                                                    container.find("div.tripsDivInRoute").hide();
                                                    $(".currentTripMarkers").hide();*/
                                                    var theaffectedstopsMarkup = "";
                                                    var theTripMarkup = "<p class=\"theTripSubhead\" style=\"background-color:black; color:white;  padding:0.5em;\"><strong>Agency:</strong>&nbsp;" + $(this).data("agencyname") + "<br><strong>Route:</strong>&nbsp;" + $(this).data("routetype") + " " + $(this).data("routeshortname") + " " + $(this).data("routelongname") + "<br><strong>Trip:</strong>&nbsp;" + $(this).html().replace("<strong>", "").replace("</strong>", "") + "</p><div class=\"fullTripData\" style=\"height:150px; max-height:150px; overflow:scroll; font-size:smaller; border: medium solid black; padding:0.5em;\"><p style=\"margin:0px 0;\"><strong>Affected Stops:</strong></p><div id=\"affectedstops\"></div><p style=\"margin:0px 0;\"><strong>All Stops:</strong><br>&nbsp;</p>";
                                                    $(this).html("Please wait...");
                                                    var bgcolor = $(this).data("routebgcolor");
                                                    var fgcolor = $(this).data("routefgcolor");
                                                    var routetype = $(this).data("routetype");
                                                    var path = $(this).data("path");
                                                    var tripkey = $(this).data("tripkey");
                                                    /*$(".whatifPolyline").hide();
                                                    var latlngs = [];
                                                    path.split("((")[1].split("))")[0].split(",").forEach(function(node){
                                                        latlngs.push(new L.LatLng(node.trim().split(" ")[1],node.trim().split(" ")[0]));
                                                    });
                                                    var polyline = new L.Polyline(latlngs,{color:"#"+bgcolor,className:"whatifPolyline"});
                                                    polyline.addTo(whatifDrawnItems);*/


                                                    $.getJSON($(this).data("url"), function (tripdata) {
                                                        //
                                                        container.find("p.tripsSubHead").hide();
                                                        container.find("p.wifstptrp").hide();
                                                        container.find("p.backToRoutes").hide();
                                                        container.find("div.tripsDivInRoute").hide();
                                                        wifstptrpbtn.html(wifstptrpbtnhtml);
                                                        $(".currentTripMarkers").hide();
                                                        $(".whatifPolyline").hide();
                                                        $(".whatifCrossingPolyline").hide();
                                                        var latlngs = [];
                                                        path.split("((")[1].split("))")[0].split(",").forEach(function (node) {
                                                            latlngs.push(new L.LatLng(node.trim().split(" ")[1], node.trim().split(" ")[0]));
                                                        });
                                                        var polyline = new L.Polyline(latlngs, { color: "#" + bgcolor, className: "whatifPolyline" });
                                                        polyline.addTo(whatifDrawnItems);
                                                        //
                                                        tripdata.forEach(function (oneStop) {
                                                            var isaffectedstop = false;
                                                            try {
                                                                isaffectedstop = Object.keys(impact["details"][agency]["routes"][hrRouteTxt]["trips"][tripkey]["stops"]).includes(oneStop["sequence"] + " " + oneStop["code"] + " " + oneStop["name"]);
                                                            } catch (nabp) { }

                                                            if (isaffectedstop) {
                                                                theTripMarkup += "<button style=\"font-size:larger; font-weight:bold; cursor:default; text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + ";\" disabled><strong>Sequence:</strong>&nbsp;" + oneStop["sequence"] + "<br><strong>Code:</strong>&nbsp;" + oneStop["code"] + "<br><strong>Name:</strong>&nbsp;" + oneStop["name"] + "<br><strong>Arrival:</strong>&nbsp;" + oneStop["arrival"].substring(0, 5) + "<br><strong>Departure:</strong>&nbsp;" + oneStop["departure"].substring(0, 5) + "</button>";
                                                                theaffectedstopsMarkup += "<button style=\"font-size:larger; font-weight:bold; cursor:default; text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + ";\" disabled><strong>Sequence:</strong>&nbsp;" + oneStop["sequence"] + "<br><strong>Code:</strong>&nbsp;" + oneStop["code"] + "<br><strong>Name:</strong>&nbsp;" + oneStop["name"] + "<br><strong>Arrival:</strong>&nbsp;" + oneStop["arrival"].substring(0, 5) + "<br><strong>Departure:</strong>&nbsp;" + oneStop["departure"].substring(0, 5) + "</button>";
                                                            }
                                                            else {
                                                                theTripMarkup += "<button style=\"cursor:default; text-align:left; width:100%; margin-bottom:1em; color:#" + fgcolor + "; background-color:#" + bgcolor + ";\" disabled><strong>Sequence:</strong>&nbsp;" + oneStop["sequence"] + "<br><strong>Code:</strong>&nbsp;" + oneStop["code"] + "<br><strong>Name:</strong>&nbsp;" + oneStop["name"] + "<br><strong>Arrival:</strong>&nbsp;" + oneStop["arrival"].substring(0, 5) + "<br><strong>Departure:</strong>&nbsp;" + oneStop["departure"].substring(0, 5) + "</button>";
                                                            }
                                                            var markerAlreadyThere = false;
                                                            map.defaultMapRef.eachLayer(function (layer) { if (layer instanceof L.Marker) { if (layer.getLatLng()["lat"] == oneStop["pos_lat"] && layer.getLatLng()["lng"] == oneStop["pos_lon"] && $(layer._icon).is(":visible")) { markerAlreadyThere = true; } else { } } });
                                                            if (!markerAlreadyThere) {
                                                                var stopMarker = L.marker([oneStop["pos_lat"], oneStop["pos_lon"]], {
                                                                    icon: new L.Icon({
                                                                        iconUrl: routetype == "Bus" ? 'https://servicemap.disit.org/WebAppGrafo/img/mapicons/TransferServiceAndRenting_BusStop.png' : 'https://servicemap.disit.org/WebAppGrafo/img/mapicons/TransferServiceAndRenting_Tram_stops.png'
                                                                    }), uri: oneStop["uri"], title: (oneStop["departure"] ? oneStop["departure"] : oneStop["arrival"]).substring(0, 5) + " | " + oneStop["code"] + " " + oneStop["name"], stopname: oneStop["name"]
                                                                });
                                                                stopMarker.addTo(whatifDrawnItems);
                                                                $(stopMarker._icon).addClass("currentTripMarkers");
                                                                if (!isaffectedstop) {
                                                                    $(stopMarker._icon).css("width", "24px");
                                                                }
                                                            }
                                                        });
                                                        theTripMarkup += "</div>";
                                                        theTripMarkup += "<p class=\"backToTrips\"><button  style=\"width:100%;color:white;background-color:black;\">Back</button></p>";
                                                        container.find("p.theTripSubhead").remove();
                                                        container.find("div.fullTripData").remove();
                                                        container.find("p.backToTrips").remove();
                                                        container.append($(theTripMarkup));
                                                        if (theaffectedstopsMarkup == "") {
                                                            theaffectedstopsMarkup = "<p>No stops of this specific trip are affected by the current scenario.</p>";
                                                        }
                                                        $("div#affectedstops").append($(theaffectedstopsMarkup));
                                                        $("p.backToTrips button").click(
                                                            function () {
                                                                container.find("p").hide();
                                                                container.find("div.fullTripData").hide();
                                                                container.find("p.stopHead").show();
                                                                container.find("p.tripsSubHead").show();
                                                                container.find("div.tripsDivInRoute").show();
                                                                container.find("p.preserveplease").show();
                                                                container.find("p.wifstptrp").show();
                                                                container.find("p.backToRoutes").show();
                                                                $(".currentTripMarkers").hide(); // it was commented
                                                            }


                                                        );
                                                    });

                                                });

                                            });

                                        });
                                    });
                                });
                                return;
                                                                            /*$.getJSON( '<?= $whatifmdtendpt ?>?agency = '+encodeURIComponent(impact["details"][agency]["agencygraph"])+' & stop='+encodeURIComponent(impact["details"][agency]["routes"][route]["trips"][trip]["stops"][stop]["uri"])+' & date='+encodeURIComponent(selectedDate)+"&list=routes", function(impact) {


                            }*/
                        }
                                                                        e.target.getPopup().on('remove', function () {
                            e.target.unbindPopup();
                        });
                    });
                    marker.addTo(whatifDrawnItems);
                    $(marker._icon).addClass("affectedStopMarker");

                });
            });
        });
                                                    }
                                                });												
                                            }).fail(function () {
            var olng = Math.min(map.defaultMapRef.getBounds()["_northEast"]["lng"], map.defaultMapRef.getBounds()["_southWest"]["lng"]) + (Math.abs(map.defaultMapRef.getBounds()["_northEast"]["lng"] - map.defaultMapRef.getBounds()["_southWest"]["lng"]) / 2);
            var olat = map.defaultMapRef.getBounds()["_northEast"]["lat"];
            L.popup({ offset: L.point(0, 210) }).setLatLng(new L.LatLng(olat, olng)).setContent("<p><strong>Impact on Public Transport</strong></p><p>This scenario is too complex for a single-step analysis. Please split it in simpler scenarios, as for the extension, the time interval, or both.</p>").openOn(map.defaultMapRef);
            $("#bus_button").css("opacity", 1);
        });
                                            //setTimeout(function(){ whatifptiendpt.abort(); }, 30000); 
                                            
                                        }
                                        // MS
                                    };

    // Set event listeners for vehicle selection and routing mode selection
    $('.vehicle-btn').on('click', function (e) {
        vehicle = e.currentTarget.id;   // Get clicked button's id
        doRoute(vehicle);
    });
    $("#whatIf-weighting").on("change", function (e) {
        // When the user chooses a weighting for the routing, if the weighting is "fastest_with_traffic" also show the datetime picker
        if ($(this).val() == "fastest_with_traffic")
            $("#routing-datetime").show();
        else
            $("#routing-datetime").hide();
        doRoute($('.selectedvehicle').attr('id'));
    });
    $("#whatIf-startDatetime").on("change", function (e) {
        doRoute($('.selectedvehicle').attr('id'));
    });

    // Init GH Leaflet Routing Machine 
    weighting = $('#whatIf-weighting').val();   // Get the selected weighting
    startDatetime = $('#whatIf-startDatetime').val();   // Get the selected datetime

    serviceUrl = setServiceUrl(orgParams, map.defaultMapRef.getBounds()["_northEast"]);
    lrmControl = L.Routing.control({
        // Servlet params
        serviceUrl: serviceUrl,
        waypoints: [],
        avoid_area: encodeURIComponent(JSON.stringify(selectedScenarioData)),
        vehicle: vehicle,
        weighting: weighting,
        startDatetime: startDatetime,
        // end Servlet params
        geocoder: L.Control.Geocoder.nominatim(),
        routeWhileDragging: true,
        reverseWaypoints: true,
        showAlternatives: false,
        createMarker: function (i, wp) {
            var icon = L.icon({
                iconUrl: '../img/dynamic_routing/marker-icon-red.png',
                shadowUrl: '../img/dynamic_routing/marker-shadow.png',
                iconAnchor: [12, 41]
            });
            return L.marker(wp.latLng, {
                draggable: true,
                icon: icon
            });
        }
    });

    lrmControl.on('routesfound', function (e) {
        if (!studioControl) {
            // add studio div (if not present yet)
            //                                            studioControl = L.control({position: 'bottomleft'});
            studioControl = L.control({ position: 'bottomright' });
            studioControl.onAdd = function (map) {
                var div = L.DomUtil.create('div');

                div.innerHTML = '<div id="studio-div">' +
                    '<input id="studio-name" type="text" placeholder="Studio name" name="name">' +
                    '<input id="studio-description" type="text" placeholder="Studio description" name="description-st">' +
                    '<span><input id="studio-visibility" type="checkbox" name="studio-public" value="Public"> Public visibility</span>' +
                    '<div>' +
                    '<input type="button" id="studio-save" value="Save"/>' +
                    '</div>' +
                    '</div>';
                // disable interaction of this div with map
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(div);
                    L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
                }

                return div;
            };
            studioControl.addTo(map.defaultMapRef);

            $("#studio-save").click(function () {
                if ($("#studio-name").val() !== "" && $("#studio-name").val().indexOf(":") == -1) {
                    var ajaxData = {
                        "method": "POST",
                        "studioName": $("#studio-name").val(),
                        "studioDescription": $("#studio-description").val(),
                        "scenarioName": selectedScenario,
                        "waypoints": JSON.stringify(lrmControl.getWaypoints()),
                        "vehicle": vehicle,
                        "public": $("#studio-visibility").is(':checked')
                    };
                    //      console.log(ajaxData);

                    $.ajax({
                        type: 'GET',
                        url: '../controllers/studioProxy.php',
                        dataType: "json",
                        contentType: 'application/json; charset=utf-8',
                        async: true,
                        data: ajaxData,
                        success: function (resp) {
                            if (resp == "-1") {
                                alert("Studio name already exists.");
                            }
                            else if (resp == "-2") {
                                alert("You must be logged in in order to create new studios.");
                            }
                            else {
                                alert("Studio '" + $("#studio-name").val() + "' saved");
                            }
                        },
                        error: function (errorData) {
                            console.log(errorData);
                        }
                    });
                }
                else if ($("#studio-name").val() === "") {
                    alert("You must enter a name for the current scenario.")
                }
                else if ($("#studio-name").val().indexOf(":") > -1) {
                    alert("You cannot enter special char ':' in the current studio's name.");
                }
            });
        }
    });

    lrmControl.addTo(map.defaultMapRef);
                                });
                            }
                            else if (choice == "studio") {
        // Hide routing mode options
        $("#options").hide();
        // hide lrm (if present)
        if (lrmControl) {
            lrmControl.remove(map);
            lrmControl = null;
            waypoints = null;
            weighting = 'fastest';
            startDatetime = null;
        }
        // hide previous drawn items
        map.defaultMapRef.removeLayer(whatifDrawnItems);

        // retrieve selected studio's data
        var selectedStudio = $(this).val();
        // studioName:scenarioName(visibility) -> we take only studioName
        // for guest visibility is not shown
        if (selectedStudio.indexOf(':') > -1)
            var selectedStudio = selectedStudio.substr(0, selectedStudio.indexOf(':'));

        $.getJSON('../controllers/studioProxy.php?method=GET&sel=' + selectedStudio, function (selectedStudioData) {
            // add studio description
            if (selectedStudioData.studioDescription)
                $("#resultDescription").html("Description: " + '<span style="font-style:italic">' + selectedStudioData.studioDescription + '</span>');
            else
                $("#resultDescription").html("Description: " + '<span style="font-style:italic">' + "Not Available." + '</span>');

            var scenarioName = selectedStudioData.scenarioName;
            waypoints = selectedStudioData.waypoints;
            vehicle = selectedStudioData.vehicle;
            weighting = selectedStudioData.weighting;   // Get the selected weighting
            startDatetime = selectedStudioData.startDatetime;   // Get the selected datetime
            if (selectedStudioData.weighting)
                weighting = selectedStudioData.weighting;
            else weighting = 'fastest';
            if (selectedStudioData.startDatetime)
                startDatetime = selectedStudioData.startDatetime;
            else startDatetime = null;
            // get scenario related to the selected studio
            $.getJSON('../controllers/scenarioProxy.php?method=GET&sel=' + scenarioName, function (selectedScenarioData) {
                // remove previous choice's drawings
                map.defaultMapRef.removeLayer(whatifDrawnItems);
                whatifDrawnItems = new L.FeatureGroup();
                map.defaultMapRef.addLayer(whatifDrawnItems);
                if (lrmControl)
                    lrmControl.remove(map.defaultMapRef);

                // draw selected scenario (feature collection)
                L.geoJson(selectedScenarioData, {
                    onEachFeature: onEachFeature
                });
                function onEachFeature(feature, layer) {
                    // radius drawing management
                    if (feature.properties.radius != null)
                        L.circle(L.latLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]),
                            feature.properties.radius)
                            .addTo(whatifDrawnItems);
                    else
                        whatifDrawnItems.addLayer(layer);
                }
                // centre the map on the first feature
                var firstShapeType = selectedScenarioData.features[0].geometry.type;
                switch (firstShapeType) {
                    case 'Polygon':
                        map.defaultMapRef.panTo(new L.LatLng(selectedScenarioData.features[0].geometry.coordinates[0][0][1],
                            selectedScenarioData.features[0].geometry.coordinates[0][0][0]));
                        break;
                    default:
                        map.defaultMapRef.panTo(new L.LatLng(selectedScenarioData.features[0].geometry.coordinates[1],
                            selectedScenarioData.features[0].geometry.coordinates[0]));
                }

                // Show routing mode options and create related event listener
                $('.selectedvehicle').removeClass('selectedvehicle');
                $('#' + vehicle).addClass('selectedvehicle');
                $("#options").show();
                // remove previous click listener (if present)
                $(".vehicle-btn").off("click");
                $('.vehicle-btn').on('click', function (e) {
                    // Get clicked button's id
                    vehicle = e.currentTarget.id;
                    // Change active button
                    $('.selectedvehicle').removeClass('selectedvehicle');
                    $('#' + vehicle).addClass('selectedvehicle');

                    weighting = $('#whatIf-weighting').val();   // Get the selected weighting
                    startDatetime = $('#whatIf-startDatetime').val();   // Get the selected datetime

                    // TRICK: Reinit lrmControl, but with previous waypoints, in order to refresh the routing process
                    waypoints = lrmControl.getWaypoints();
                    if (lrmControl) {
                        lrmControl.remove(map);
                        lrmControl = null;
                    }
                    serviceUrl = setServiceUrl(orgParams, map.defaultMapRef.getBounds()["_northEast"]);
                    lrmControl = L.Routing.control({
                        // Servlet params
                        serviceUrl: serviceUrl,
                        waypoints: waypoints,
                        avoid_area: encodeURIComponent(JSON.stringify(selectedScenarioData)),
                        vehicle: vehicle,
                        weighting: weighting,
                        startDatetime: startDatetime,
                        // end Servlet params
                        geocoder: L.Control.Geocoder.nominatim(),
                        routeWhileDragging: true,
                        reverseWaypoints: true,
                        showAlternatives: false,
                        createMarker: function (i, wp) {
                            var icon = L.icon({
                                iconUrl: '../img/dynamic_routing/marker-icon-red.png',
                                shadowUrl: '../img/dynamic_routing/marker-shadow.png',
                                iconAnchor: [12, 41]
                            });
                            return L.marker(wp.latLng, {
                                draggable: true,
                                icon: icon
                            });
                        }
                    });
                    lrmControl.addTo(map.defaultMapRef);
                });

                // init lrm with retrieved waypoints and avoid_area
                serviceUrl = setServiceUrl(orgParams, map.defaultMapRef.getBounds()["_northEast"]);
                lrmControl = L.Routing.control({
                    // Servlet params
                    serviceUrl: serviceUrl,
                    waypoints: [],
                    avoid_area: encodeURIComponent(JSON.stringify(selectedScenarioData)),
                    vehicle: vehicle,
                    weighting: weighting,
                    startDatetime: startDatetime,
                    // end Servlet params
                    geocoder: L.Control.Geocoder.nominatim(),
                    routeWhileDragging: true,
                    reverseWaypoints: true,
                    showAlternatives: false,
                    createMarker: function (i, wp) {
                        var icon = L.icon({
                            iconUrl: '../img/dynamic_routing/marker-icon-red.png',
                            shadowUrl: '../img/dynamic_routing/marker-shadow.png',
                            iconAnchor: [12, 41]
                        });
                        return L.marker(wp.latLng, {
                            draggable: true,
                            icon: icon
                        });
                    }
                });
                lrmControl.addTo(map.defaultMapRef);
                // add waypoints
                var j = 0;
                waypoints = JSON.parse(waypoints);
                for (var e in waypoints) {
                    lrmControl.spliceWaypoints(j++, 1, waypoints[e].latLng);
                }
            });
        });
    }

    // Function for button creation
    function createButton(label, container) {
        var btn = L.DomUtil.create('div', '', container);
        btn.innerHTML = '<button>' + label + '</button>';
        return btn;
    }

    // MS
    var latlonFilter = function (latlng) {
        try {
            var dist = -1;
            var nearestMarker = null;
            var newlat = latlng["lat"];
            var newlng = latlng["lng"];
            map.defaultMapRef.eachLayer(
                function (layer) {
                    if (layer instanceof L.Marker) {
                        if ($(layer._icon).hasClass("currentTripMarkers") && $(layer._icon).is(":visible")) {
                            if (dist == -1 || dist > Math.pow(latlng["lat"] - layer.getLatLng()["lat"], 2) + Math.pow(latlng["lng"] - layer.getLatLng()["lng"], 2)) {
                                newlat = layer.getLatLng()["lat"];
                                newlng = layer.getLatLng()["lng"];
                                dist = Math.pow(latlng["lat"] - layer.getLatLng()["lat"], 2) + Math.pow(latlng["lng"] - layer.getLatLng()["lng"], 2);
                                nearestMarker = layer;
                                console.log("Reconciliated");
                            }
                        }
                    }
                }
            );
            console.log('<osm-script output="json"><query type="node"><around lat="' + newlat + '" lon="' + newlng + '" radius="100.0"/><has-kv k="bus" v="yes" /><has-kv k="name" v="' + nearestMarker.options.stopname + '" /></query><print /></osm-script>');
            $.getJSON('https://overpass.kumi.systems/api/interpreter?data=' + encodeURIComponent('<osm-script output="json"><query type="node"><around lat="' + newlat + '" lon="' + newlng + '" radius="100.0"/><has-kv k="bus" v="yes"></has-kv><has-kv k="name" v="' + nearestMarker.options.stopname + '"></has-kv></query><print /></osm-script>'), function (overpassResponse) {
                console.log(overpassResponse);
                var lat = null;
                var lng = null;
                var public_transport = null;
                overpassResponse["elements"].forEach(function (element) {
                    if (public_transport != "stop_position" && public_transport != "platform") {
                        public_transport = element["tags"]["public_transport"];
                        lat = element["lat"];
                        lng = element["lon"];
                    }
                });
                if (lat != null && lng != null) {
                    newlat = lat;
                    newlng = lng;
                    console.log("From overpass: " + newlat + ", " + newlng);
                }
            });

            return { lat: newlat, lng: newlng };
        }
        catch (e) {
            return latlng;
        }
    };
    // MS

    // add a popup <from, to> when the map is clicked
    map.defaultMapRef.on('click', function (e) {
        if (lrmControl) {
            var container = L.DomUtil.create('div'),
                startBtn = createButton('Start from this location', container),
                destBtn = createButton('Go to this location', container);
            L.DomUtil.setClass(container, "leaflet-fromto-popup");

            L.popup()
                .setContent(container)
                .setLatLng(latlonFilter(e.latlng))
                .openOn(map.defaultMapRef);
            // replace the first waypoint
            L.DomEvent.on(startBtn, 'click', function () {
                lrmControl.spliceWaypoints(0, 1, latlonFilter(e.latlng));
                map.defaultMapRef.closePopup();
            });
            // replace the last waypoint
            L.DomEvent.on(destBtn, 'click', function () {
                lrmControl.spliceWaypoints(lrmControl.getWaypoints().length - 1, 1, latlonFilter(e.latlng));
                map.defaultMapRef.closePopup();
            });
        }
    });
                        });
                    }
                });

    $(document).on('removeWhatif', function (event) {
        if (event.target === map.mapName) {
            map.defaultMapRef.removeLayer(whatifLayer);
            map.defaultMapRef.removeControl(whatifControl);
            map.defaultMapRef.removeLayer(whatifDrawnItems);
            if (lrmControl) {
                lrmControl.remove(map);
                lrmControl = null;
                waypoints = null;
                weighting = 'fastest';
                startDatetime = null;
            }
            if (studioControl) {
                map.defaultMapRef.removeControl(studioControl);
                studioControl = null;
            }
        }
    });
    // end Cristiano

    $(document).on('addTrafficRealTimeDetails', function (event) {
        if (event.target === map.mapName) {
            var so = map.defaultMapRef.getBounds()._southWest;
            var ne = map.defaultMapRef.getBounds()._northEast;
            var zm = map.defaultMapRef.getZoom();

            var roadsJson = event.passedData + "?sLat=" + so.lat + "&sLong=" + so.lng + "&eLat=" + ne.lat + "&eLong=" + ne.lng + "&zoom=" + zm;

            function addTrafficRTDetailsToMap() {
                var event = {};
                event.eventType = "trafficRealTimeDetails";
                event.maxLat = ne.lat;
                event.minLat = so.lat;
                event.maxLng = ne.lng;
                event.minLng = so.lng;
                event.zm = zm;


                var myMarker = new L.LayerGroup();

                /*    $.ajax({
                    //    url: "../trafficRTDetails/sensorsCoord.json",
                        url: "https://firenzetraffic.km4city.org/trafficRTDetails/sensorsCoord.php",
                        type: "GET",
                        async: false,
                        cache: false,
                        dataType: 'json',
                        success: function (_sensors) {
                            sensors = JSON.parse(_sensors);
                            for (var i = 0; i < sensors.length; i++) {
                                if (sensors[i].sensorLat > so.lat && sensors[i].sensorLat < ne.lat && sensors[i].sensorLong > so.lng && sensors[i].sensorLong < ne.lng) {
                                    var mark = L.circleMarker([sensors[i].sensorLat, sensors[i].sensorLong]);
                                    mark.addTo(myMarker);
                                }
                            }
                            myMarker.addTo(map.defaultMapRef);
                        }
                    }); */

                event.marker = myMarker;

                map.defaultMapRef.on('click', function (e) {
                    var bnds = map.defaultMapRef.getBounds()
                    console.log(bnds.getSouth() + ";" + bnds.getWest() + ";" + bnds.getNorth() + ";" + bnds.getEast());
                    if (roads == null)
                        loadRoads();
                    else {
                    }
                });

                // CORTI - zIndex
                map.defaultMapRef.createPane('trafficFlow');
                map.defaultMapRef.getPane('trafficFlow').style.zIndex = 420;

                var wktLayer = new L.LayerGroup();
                var roads = null;
                var time = 0;

                loadRoads();

                function loadRoads() {
                    defaults = {
                        icon: new L.DivIcon({ className: "geo-icon" }),
                        editable: true,
                        color: '#AA0000',
                        weight: 2.5,
                        opacity: 1,
                        fillColor: '#AA0000',
                        fillOpacity: 1,
                        pane: 'trafficFlow'		// CORTI
                    };

                    $.ajax({
                        url: roadsJson,
                        type: "GET",
                        async: true,
                        dataType: 'json',
                        success: function (_roads) {
                            roads = JSON.parse(JSON.stringify(_roads));

                            loadDensity();
                        },
                        error: function (err) {
                            console.log(err);
                            alert("error see log json");
                        }
                    });
                }

                function loadDensity() {
                    $.ajax({
                        //    url: "http://localhost/dashboardSmartCity/trafficRTDetails/density/read.php" + "?sLat=" + so.lat + "&sLong=" + so.lng + "&eLat=" + ne.lat + "&eLong=" + ne.lng + "&zoom=" + zm,
                        url: "https://firenzetraffic.km4city.org/trafficRTDetails/density/read.php" + "?sLat=" + so.lat + "&sLong=" + so.lng + "&eLat=" + ne.lat + "&eLong=" + ne.lng + "&zoom=" + zm,
                        type: "GET",
                        async: false,
                        cache: false,
                        dataType: 'json',
                        success: function (_density) {
                            density = JSON.parse(JSON.stringify(_density));

                            for (var i = 0; i < roads.length; i++) {
                                if (density.hasOwnProperty((roads[i].road))) {
                                    roads[i].data = density[roads[i].road].data;
                                }
                            }

                            event.roads = roads;

                            time = 0;
                            draw(time);
                            console.log("@time " + time);
                        },
                        error: function (err) {
                            console.log(err);
                            alert("error see log json");
                        }
                    });
                }

                function draw(t) {
                    if (roads == null)
                        return;
                    //wktLayer.clearLayers();
                    for (var i = 0; i < roads.length; i++) {
                        var segs = roads[i].segments;
                        for (var j = 0; j < segs.length; j++) {
                            var seg = segs[j];
                            if (typeof seg.start != "undefined") {
                                var wktPoint = "POINT(" + seg.start.long + " " + seg.start.lat + ")";
                                var wktLine = "LINESTRING(" + seg.start.long + " " + seg.start.lat + "," + seg.end.long + " " + seg.end.lat + ")";

                                try {
                                    if (!jQuery.isEmptyObject(roads[i].data[0])) {
                                        var value = Number(roads[i].data[t][seg.id].replace(",", "."));
                                        //console.log(value);
                                        var green = 0.3;
                                        var yellow = 0.6;
                                        var orange = 0.9;
                                        if (seg.Lanes == 2) {
                                            green = 0.6;
                                            yellow = 1.2;
                                            orange = 1.8;
                                        }
                                        if (seg.FIPILI == 1) {
                                            green = 0.25;
                                            yellow = 0.5;
                                            orange = 0.75;
                                        }
                                        if (seg.Lanes == 3) {
                                            green = 0.9;
                                            yellow = 1.5;
                                            orange = 2;
                                        }
                                        if (seg.Lanes == 4) {
                                            green = 1.2;
                                            yellow = 1.6;
                                            orange = 2;
                                        }
                                        if (seg.Lanes == 5) {
                                            green = 1.6;
                                            yellow = 2;
                                            orange = 2.4;
                                        }
                                        if (seg.Lanes == 6) {
                                            green = 2;
                                            yellow = 2.4;
                                            orange = 2.8;
                                        }
                                        if (value <= green)
                                            defaults.color = "#00ff00";
                                        else if (value <= yellow)
                                            defaults.color = "#ffff00";
                                        else if (value <= orange)
                                            defaults.color = "#ff8c00";
                                        else
                                            defaults.color = "#ff0000";
                                        defaults.fillColor = defaults.color;

                                        if (!seg.obj) {
                                            var wkt = new Wkt.Wkt();
                                            wkt.read(wktLine, "newMap");
                                            obj = wkt.toObject(defaults);
                                            obj.options.trafficFlow = true;
                                            obj.addTo(wktLayer);
                                            seg.obj = obj;

                                        } else {
                                            seg.obj.setStyle(defaults);
                                        }
                                    }
                                } catch (e) {
                                    console.log(e);
                                }
                            }
                        }
                    }
                    wktLayer.addTo(map.defaultMapRef);
                }

                event.trafficLayer = wktLayer;

                //Create legend
                var legend = L.control({ position: 'bottomright' });

                legend.onAdd = function (map) {

                    var div = L.DomUtil.create('div', 'info legend'),
                        grades = ["Legend"],
                        //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
                        labels = ["https://firenzetraffic.km4city.org/trafficRTDetails/legend.png"];

                    // loop through our density intervals and generate a label with a colored square for each interval
                    for (var i = 0; i < grades.length; i++) {
                        div.innerHTML +=
                            grades[i] + (" <img src=" + labels[i] + " height='120' width='80' background='#cccccc'>") + '<br>';
                    }

                    return div;
                };

                legend.addTo(map.defaultMapRef);

                event.legend = legend;
                map.eventsOnMap.push(event);
                //window.setInterval("loadDensity();", 300000);
            }

            if (addMode === 'additive') {
                addTrafficRTDetailsToMap();
            }

            if (addMode === 'exclusive') {
                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if (map.eventsOnMap[i].type !== "trafficRealTimeDetails") {
                        map.defaultMapRef.eachLayer(function (layer) {
                            map.defaultMapRef.removeLayer(layer);
                        });
                        map.eventsOnMap.length = 0;
                        break;
                    }
                }
                //Remove WidgetAlarm active pins
                $.event.trigger({
                    type: "removeAlarmPin",
                });
                //Remove WidgetEvacuationPlans active pins
                $.event.trigger({
                    type: "removeEvacuationPlanPin",
                });
                //Remove WidgetEvents active pins
                $.event.trigger({
                    type: "removeEventFIPin",
                });
                //Remove WidgetResources active pins
                $.event.trigger({
                    type: "removeResourcePin",
                });
                //Remove WidgetOperatorEvents active pins
                $.event.trigger({
                    type: "removeOperatorEventPin",
                });
                //Remove WidgetTrafficEvents active pins
                $.event.trigger({
                    type: "removeTrafficEventPin",
                });
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                    maxZoom: leafletMaxZoom,
                    maxNativeZoom: leafletNativeMaxZoom
                }).addTo(map.defaultMapRef);

                addTrafficRTDetailsToMap();
            }

            //resizeMapView(map.defaultMapRef);
        }
    });

    $(document).on('addHeatmap', function (event) {
        if (event.target === map.mapName) {
            odOnMap = false;
            //   map.defaultMapRef.off('click', heatmapClick);
            //   window.addHeatmapToMap = function() {

            //Crea un layer per la heatmap (i dati gli verranno passati nell'evento)
            //heatmap configuration
            function initHeatmapLayer(heatmapRangeObject) {

                var heatmapCfg = {};
                var colorScale = {};
                var colorGradient = {};
                var gradientString = "";

                map.cfg = JSON.parse(heatmapRangeObject[0].leafletConfigJSON);
                //    map.cfg['blur'] = 0.85;
                if (map.cfg == null) {
                    map.cfg = {};
                }

                if (current_radius != null) {
                    map.cfg['radius'] = current_radius;
                }
                if (current_opacity != null) {
                    map.cfg['maxOpacity'] = current_opacity;
                }

                $.ajax({
                    url: heatmapUrl + "getColorMap.php?metricName=" + map.testMetadata.metadata.metricName,
                    //    url: "https://heatmap.snap4city.org/getColorMap.php?metricName=" + map.testMetadata.metadata.metricName,
                    type: "GET",
                    async: false,
                    dataType: 'json',
                    success: function (dataColorScale) {
                        colorScale = dataColorScale;
                    },
                    error: function (err) {
                        alert("Error in retrieving color map scale: ");
                        console.log(err);
                    }
                });

                if (colorScale && colorScale.length > 0) {
                    var minVal = colorScale[0].min;
                    if (minVal === null || minVal === undefined) {
                        minVal = heatmapRangeObject[0].range1Inf;
                    }

                    var maxVal = colorScale[colorScale.length - 1].min;
                    if (maxVal === null || maxVal === undefined) {
                        maxVal = heatmapRangeObject[0].range10Inf;
                    }
                    colorGradient[0] = 0;
                    colorGradient[colorScale.length - 1] = 1;
                    gradientString = '{ "' + colorGradient[0] + '": "#' + fullColorHex(colorScale[0].rgb.substring(1, colorScale[0].rgb.length - 1)) + '", ';
                    for (let k1 = 1; k1 < colorScale.length - 1; k1++) {
                        colorGradient[k1] = (colorScale[k1].min - minVal) / (maxVal - minVal);
                        gradientString = gradientString + '"' + colorGradient[k1] + '": "#' + fullColorHex(colorScale[k1].rgb.substring(1, colorScale[k1].rgb.length - 1)) + '", ';
                    }
                    gradientString = gradientString + '"' + colorGradient[colorScale.length - 1] + '": "#' + fullColorHex(colorScale[colorScale.length - 1].rgb.substring(1, colorScale[colorScale.length - 1].rgb.length - 1)) + '"}';
                    map.cfg.gradient = JSON.parse(gradientString);
                    map.heatmapLayer = new HeatmapOverlay(map.cfg);
                    //map.heatmapLayer.zIndex = 20;
                    //  map.legendHeatmap = L.control({position: 'topright'});
                }
            }

            if (!map.legendHeatmap) {
                map.legendHeatmap = L.control({ position: 'topright' });
            }

            if (!map.trafficLegendHeatmap) {
                map.trafficLegendHeatmap = L.control({ position: 'bottomright' });
            }

            function changeHeatmapPage(page) {
                var btn_next = document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt");
                var btn_prev = document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt");
                var heatmapDescr = document.getElementById("<?= $_REQUEST['name_w'] ?>_heatMapDescr");

                // Validate page
                if (numHeatmapPages() > 1) {
                    if (page < 1) page = 1;
                    if (page > numHeatmapPages()) page = numHeatmapPages();

                    if (current_page == 0) {
                        btn_next.style.visibility = "hidden";
                    } else {
                        btn_next.style.visibility = "visible";
                    }

                    if (current_page == numHeatmapPages() - 1) {
                        btn_prev.style.visibility = "hidden";
                    } else {
                        btn_prev.style.visibility = "visible";
                    }
                }

                if (current_page < numHeatmapPages()) {
                    //  $("#heatMapDescr").text(heatmapData[current_page].metadata[0].date);  // OLD-API
                    //    heatmapDescr.text(heatmapData[current_page].metadata.date);
                    //heatmapDescr.firstChild.wholeText = heatmapData[current_page].metadata.date;
                    // heatmapData[current_page].metadata[0].date

                    if (heatmapData[current_page].metadata != null) {
                        heatmapDescr.firstChild.wholeText = heatmapData[current_page].metadata.date;
                    } else {
                        heatmapDescr.firstChild.wholeText = heatmapData[current_page].dateTime;
                    }
                }
            }

            function changeTrafficHeatmapPage(page) {
                var btn_next = document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt_traffic");
                var btn_prev = document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt_traffic");
                var heatmapDescr = document.getElementById("<?= $_REQUEST['name_w'] ?>_heatMapDescr_traffic");

                // Validate page
                if (numTrafficHeatmapPages() > 1) {
                    if (page < 1) page = 1;
                    if (page > numTrafficHeatmapPages()) page = numTrafficHeatmapPages();

                    if (current_page_traffic == 0) {
                        btn_next.style.visibility = "hidden";
                    } else {
                        btn_next.style.visibility = "visible";
                    }

                    if (current_page_traffic == numTrafficHeatmapPages() - 1) {
                        btn_prev.style.visibility = "hidden";
                    } else {
                        btn_prev.style.visibility = "visible";
                    }
                }

                if (current_page_traffic < numTrafficHeatmapPages()) {
                    heatmapDescr.firstChild.wholeText = trafficData[current_page_traffic].dateTime;
                }
            }

            function numHeatmapPages() {
                //    return Math.ceil(heatmapData.length / records_per_page);
                return heatmapData.length;
            }

            function numTrafficHeatmapPages() {
                return trafficData.length;
            }


            function setOption(option, value, decimals) {
                if (baseQuery.includes("heatmap.php")) {
                    if (option == "radius") {       // AGGIUNGERE SE FLAG è TRUE SI METTE IL VALORE DI CONFIG
                        if (resetPageFlag) {
                            if (resetPageFlag === true) {
                                current_radius = map.cfg['radius'];
                            } else {
                                current_radius = Math.max(value, 2);
                            }
                        } else {
                            current_radius = Math.max(value, 2);
                        }
                        map.cfg["radius"] = current_radius.toFixed(1);
                        if (decimals) {
                            $("#<?= $_REQUEST['name_w'] ?>_range" + option).text(parseFloat(current_radius).toFixed(parseInt(decimals)));
                            $("#<?= $_REQUEST['name_w'] ?>_slider" + option).attr("value", parseFloat(current_radius).toFixed(parseInt(decimals)));
                        }
                    } else if (option == "maxOpacity") {
                        if (resetPageFlag) {
                            if (resetPageFlag === true) {
                                current_opacity = map.cfg['maxOpacity'];
                            } else {
                                current_opacity = value;
                            }
                        } else {
                            current_opacity = value;
                        }
                        map.cfg["maxOpacity"] = current_opacity;
                        if (decimals) {
                            $("#<?= $_REQUEST['name_w'] ?>_range" + option).text(parseFloat(current_opacity).toFixed(parseInt(decimals)));
                            $("#<?= $_REQUEST['name_w'] ?>_slider" + option).attr("value", parseFloat(current_opacity).toFixed(parseInt(decimals)));
                        }
                    }
                    // update the heatmap with the new configuration
                    map.heatmapLayer.configure(map.cfg);
                } else {
                    if (option == "maxOpacity") {
                        if (wmsLayer) {
                            wmsLayer.setOpacity(value);
                            current_opacity = value;
                            if (decimals) {
                                $("#<?= $_REQUEST['name_w'] ?>_range" + option).text(parseFloat(current_opacity).toFixed(parseInt(decimals)));
                                $("#<?= $_REQUEST['name_w'] ?>_slider" + option).attr("value", parseFloat(current_opacity).toFixed(parseInt(decimals)));
                            }
                        }
                    } else if (option == "maxTrafficOpacity") {
                        if (trafficWmsLayer) {
                            trafficWmsLayer.setOpacity(value);
                        } else if (newTfrLayer) {
                            newTfrLayer.eachLayer(function(layer) {
                                if (layer instanceof L.Polyline) {
                                    layer.setStyle({
                                        opacity: value
                                    });
                                }
                            });
                        }
                        current_traffic_opacity = value;
                        $("#<?= $_REQUEST['name_w'] ?>_range" + option).text(parseFloat(current_traffic_opacity).toFixed(parseInt(decimals)));
                        $("#<?= $_REQUEST['name_w'] ?>_slider" + option).attr("value", parseFloat(current_traffic_opacity).toFixed(parseInt(decimals)));
                    }
                    if (map.heatmapLayer != null) {
                        map.heatmapLayer.configure(map.cfg);
                    }
                }
            }

            function upSlider(color, step, decimals, max) {
                let value = $("#<?= $_REQUEST['name_w'] ?>_slider" + color).attr("value");
                if (parseFloat(parseFloat(value) + parseFloat(step)) <= max) {
                    $("#<?= $_REQUEST['name_w'] ?>_range" + color).text(parseFloat(parseFloat(value) + parseFloat(step)).toFixed(parseInt(decimals)));
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_slider" + color).value = parseFloat(parseFloat(value) + parseFloat(step)).toFixed(parseInt(decimals));
                    $("#<?= $_REQUEST['name_w'] ?>_slider" + color).trigger('change');
                }
            }

            function downSlider(color, step, decimals, min) {
                let value = $("#<?= $_REQUEST['name_w'] ?>_slider" + color).attr("value");
                if (parseFloat(parseFloat(value) - parseFloat(step)) >= min) {
                    $("#<?= $_REQUEST['name_w'] ?>_range" + color).text(parseFloat(parseFloat(value) - parseFloat(step)).toFixed(parseInt(decimals)));
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_slider" + color).value = parseFloat(parseFloat(value) - parseFloat(step)).toFixed(parseInt(decimals));
                    $("#<?= $_REQUEST['name_w'] ?>_slider" + color).trigger('change');
                }
            }

            function removeHeatmap(resetPageFlag) {
                if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
                    if (resetPageFlag == true) {
                        current_page = 0;     // CTR SE VA BENE BISOGNA DISTINGUERE IL CASO CHE SI STIA NAVIGANDO LA STESSA HEATMAP_NAME OPPURE UN'ALTRA NUOVA HEATMP_NAME
                        current_radius = null;
                        current_opacity = null;
                        changeRadiusOnZoom = false;
                        estimateRadiusFlag = false;
                        estimatedRadius = null;
                        wmsDatasetName = null;
                    }
                    map.testData = [];
                    map.heatmapLayer.setData({ data: [] });
                    map.defaultMapRef.removeLayer(map.heatmapLayer);
                    if (resetPageFlag != true) {
                        if (map.cfg["radius"] != current_radius) {
                            setOption('radius', current_radius, 1);
                        }
                        if (map.cfg["maxOpacity"] != current_opacity) {
                            setOption('maxOpacity', current_opacity, 2);
                        }
                    }
                    map.defaultMapRef.removeControl(map.legendHeatmap);
                    /*    if(map.heatmapLegendColors) {
                            map.defaultMapRef.removeControl(map.heatmapLegendColors);
                        }*/
                } else {    // NEW WMS HEATMAP
                    if (resetPageFlag == true) {
                        current_page = 0;
                    }
                    map.defaultMapRef.removeLayer(wmsLayer);
                    map.defaultMapRef.removeControl(map.legendHeatmap);
                }
            }

            function removeHeatmapColorLegend(index, resetPageFlag) {
                if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
                    if (resetPageFlag == true) {
                        current_page = 0;     // CTR SE VA BENE BISOGNA DISTINGUERE IL CASO CHE SI STIA NAVIGANDO LA STESSA HEATMAP_NAME OPPURE UN'ALTRA NUOVA HEATMP_NAME
                        current_radius = null;
                        current_opacity = null;
                        changeRadiusOnZoom = false;
                        estimateRadiusFlag = false;
                        estimatedRadius = null;
                        wmsDatasetName = null;
                    }
                    map.testData = [];
                    map.heatmapLayer.setData({ data: [] });
                    map.defaultMapRef.removeLayer(map.heatmapLayer);
                    if (resetPageFlag != true) {
                        if (map.cfg["radius"] != current_radius) {
                            setOption('radius', current_radius, 1);
                        }
                        if (map.cfg["maxOpacity"] != current_opacity) {
                            setOption('maxOpacity', current_opacity, 2);
                        }
                    }
                    map.defaultMapRef.removeControl(map.eventsOnMap[index].legendColors);
                } else {    // NEW WMS HEATMAP
                    if (resetPageFlag == true) {
                        current_page = 0;
                    }
                    map.defaultMapRef.removeControl(map.eventsOnMap[index].legendColors);
                    map.defaultMapRef.removeLayer(wmsLayer);
                }
            }

            function updateChangeRadiusOnZoom(htmlElement) {
                if (htmlElement.checked) {
                    changeRadiusOnZoom = true;
                    $("#<?= $_REQUEST['name_w'] ?>_estimateRad").attr('disabled', false);
                } else {
                    changeRadiusOnZoom = false;
                    $("#<?= $_REQUEST['name_w'] ?>_estimateRad").attr('disabled', true);
                }
                //  $("#radiusEstCnt").toggle(htmlElement.checked);
            }

            function computeRadiusOnData(htmlElement) {
                if (htmlElement.checked) {
                    estimateRadiusFlag = true;
                    $("#<?= $_REQUEST['name_w'] ?>_changeRad").attr('disabled', true);
                } else {
                    estimateRadiusFlag = false;
                    $("#<?= $_REQUEST['name_w'] ?>_changeRad").attr('disabled', false);
                }
            }

            map.legendHeatmap.onAdd = function () {
                map.legendHeatmapDiv = L.DomUtil.create('div');
                map.legendHeatmapDiv.id = "heatmapLegend";
                // disable interaction of this div with map
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(map.legendHeatmapDiv);
                    L.DomEvent.on(map.legendHeatmapDiv, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(map.legendHeatmapDiv, 'click', L.DomEvent.stopPropagation);
                }
                map.legendHeatmapDiv.style.width = "340px";
                map.legendHeatmapDiv.style.fontWeight = "bold";
                map.legendHeatmapDiv.style.background = "#cccccc";
                //  map.legendHeatmapDiv.style.background = "rgba(255,255,255,0.5)";
                //map.legendHeatmap.style.background = "-webkit-gradient(linear, left top, left bottom, from(#eeeeee), to(#cccccc))";
                map.legendHeatmapDiv.style.padding = "10px";

                //categories = ['blue', 'cyan', 'green', 'yellowgreen', 'yellow', 'gold', 'orange', 'darkorange', 'tomato', 'orangered', 'red'];
                let colors = [];
                colors['blue'] = '#0000FF';
                colors['cyan'] = '#00FFFF';
                colors['green'] = '#008000';
                colors['yellowgreen'] = '#9ACD32';
                colors['yellow'] = '#FFFF00';
                colors['gold'] = '#FFD700';
                colors['orange'] = '#FFA500';
                colors['darkorange'] = '#FF8C00';
                colors['orangered'] = '#FF4500';
                colors['tomato'] = '#FF6347';
                colors['red'] = '#FF0000';
                let colors_value = [];
                colors_value['blue'] = '#0000FF';
                colors_value['cyan'] = '#00FFFF';
                colors_value['green'] = '#008000';
                colors_value['yellowgreen'] = '#9ACD32';
                colors_value['yellow'] = '#FFFF00';
                colors_value['gold'] = '#FFD700';
                colors_value['orange'] = '#FFA500';
                colors_value['darkorange'] = '#FF8C00';
                colors_value['tomato'] = '#FF6347';
                colors_value['orangered'] = '#FF4500';
                colors_value['red'] = '#FF0000';
                //  map.legendHeatmapDiv.innerHTML += '<div class="textTitle" style="text-align:center">' + map.testMetadata.metadata[0].mapName + '</div>';  // OLD-API
                map.legendHeatmapDiv.innerHTML += '<div class="textTitle" style="text-align:center">' + mapName + '</div>';
                if (!baseQuery.includes("heatmap.php")) {
                    map.legendHeatmapDiv.innerHTML += '<div id="<?= $_REQUEST['name_w'] ?>_controlsContainer" style="height:20px"><div class="text"  style="width:50%; float:left">' + '<?php echo ucfirst(isset($_REQUEST["profile"]) ? $_REQUEST["profile"] : "Heatmap Controls:"); ?></div><div class="text" style="width:50%; float:right"><label class="switch"><input type="checkbox" id="<?= $_REQUEST['name_w'] ?>_animation"><div class="slider round"><span class="animationOn"></span><span class="animationOff" style="color: black; text-align: right">24H</span><span class="animationOn" style="color: black; text-align: right">Static</span></div></label></div></div>';
                } else {
                    map.legendHeatmapDiv.innerHTML += '<div class="text">' + '<?php echo ucfirst(isset($_REQUEST["profile"]) ? $_REQUEST["profile"] : "Heatmap Controls:"); ?></div>';
                }
                //    map.legendHeatmapDiv.innerHTML += '</div>';
                // radius
                if (baseQuery.includes("heatmap.php")) {    // OLD HEATMAP
                    map.legendHeatmapDiv.innerHTML +=
                        '<div id="heatmapRadiusControl" style="margin-top:10px">' +
                        '<div style="display:inline-block; vertical-align:super;">Radius (px):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>' +
                        '<div id= "<?= $_REQUEST['name_w'] ?>_downSlider_radius" style="display:inline-block; vertical-align:super; color: #0078A8">&#10094;</div>&nbsp;&nbsp;&nbsp;' +
                        //  '<input id="<?= $_REQUEST['name_w'] ?>_sliderradius" style="display:inline-block; vertical-align:baseline; width:auto" type="range" min="0" max="0.0010" value="0.0008" step="0.00001">' +
                        //  '<input id="<?= $_REQUEST['name_w'] ?>_sliderradius" style="display:inline-block; vertical-align:baseline; width:auto" type="range" min="1" max="' + estimatedRadius * 20 + '" value="' + current_radius + '" step="' + Math.floor((estimatedRadius * 20)/40) + '">' +
                        '<input id="<?= $_REQUEST['name_w'] ?>_sliderradius" style="display:inline-block; vertical-align:baseline; width:auto" type="range" min="1" max="' + estimatedRadius * 30 + '" value="' + current_radius + '" step="2">' +
                        '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<div id="upSlider_radius" style="display:inline-block; vertical-align:super; color: #0078A8">&#10095;</div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
                        '<span id="<?= $_REQUEST['name_w'] ?>_rangeradius" style="display:inline-block; vertical-align:super;">' + current_radius + '</span>' +
                        '</div>';
                }
                // max opacity
                map.legendHeatmapDiv.innerHTML +=
                    '<div id="heatmapOpacityControl">' +
                    '<div style="display:inline-block; vertical-align:super;">Max Opacity: &nbsp;&nbsp;&nbsp;&nbsp;</div>' +
                    '<div id="<?= $_REQUEST['name_w'] ?>_downSlider_opacity" style="display:inline-block; vertical-align:super; color: #0078A8">&#10094;</div>&nbsp;&nbsp;&nbsp;' +
                    '<input id="<?= $_REQUEST['name_w'] ?>_slidermaxOpacity" style="display:inline-block; vertical-align:baseline; width:auto" type="range" min="0" max="1" value="' + current_opacity + '" step="0.01">' +
                    '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<div id="upSlider_opacity" style="display:inline-block;vertical-align:super; color: #0078A8">&#10095;</div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
                    '<span id="<?= $_REQUEST['name_w'] ?>_rangemaxOpacity" style="display:inline-block;vertical-align:super;">' + current_opacity + '</span>' +
                    '</div>';

                // Heatmap Navigation Buttons (prev & next)
                map.legendHeatmapDiv.innerHTML +=
                    '<div id="heatmapNavigationCnt">' +
                    //   '<a href="javascript:prevHeatmapPage()" id="btn_prev">Prev</a>'
                    //   '<a href="javascript:nextHeatmapPage()" id="btn_next">Next</a>'
                    //   '<a onClick="javascript:prevHeatmapPage()" id="btn_prev">Prev</a>'
                    //   '<a onClick="javascript:nextHeatmapPage()" id="btn_next">Next</a>'
                    '<input type="button" id="<?= $_REQUEST['name_w'] ?>_prevButt" value="< Prev" style="float: left"/>' +
                    '<input type="button" id="<?= $_REQUEST['name_w'] ?>_nextButt" value="Next >" style="float: right"/>' +
                    //  '<div id="heatMapDescr" style="text-align: center">' + map.testMetadata.metadata[0].date + '</p>' +   // OLD-API
                    '<div id="<?= $_REQUEST['name_w'] ?>_heatMapDescr" style="text-align: center">' + mapDate + '</p>' +
                    //  '<a href="#" id="prevHeatmapPage">&lt; Prev</a>'
                    //  '<a href="#" id="nextHeatmapPage">Next &gt;</a>'
                    '</div>';
                if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
                    map.legendHeatmapDiv.innerHTML +=
                        '<div id="radiusCnt">' +
                        // '<input type="checkbox" name="checkfield" id="g01-01" onchange="updateChangeRadiusOnZoom(this)"/> Change Radius on Zoom' +
                        '<input type="checkbox" name="checkfield" id="<?= $_REQUEST['name_w'] ?>_changeRad"/> Change Radius on Zoom' +
                        '</div>';
                    map.legendHeatmapDiv.innerHTML +=
                        '<div id="radiusEstCnt"">' +
                        // '<input type="checkbox" name="checkfield" id="g01-01" onchange="updateChangeRadiusOnZoom(this)"/> Change Radius on Zoom' +
                        '<input type="checkbox" name="checkfield" id="<?= $_REQUEST['name_w'] ?>_estimateRad" disabled="true"/> Estimate Radius Based on Data' +
                        '</div>';
                }

                function checkLegend() {
                                /*   if(document.getElementById("<?= $_REQUEST['name_w'] ?>_downSlider_radius") == null){
                    setTimeout(checkLegend, 500);
                }
                        else {   */
                    if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_sliderradius").addEventListener("input", function () { setOption('radius', this.value, 1) }, false);
                    }

                    //document.getElementById("<?= $_REQUEST['name_w'] ?>_downSlider_opacity").addEventListener("click", function(){ downSlider('maxOpacity', 0.1, 2, 0)}, false);
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").addEventListener("input", function () { setOption('maxOpacity', this.value, 2) }, false);
                    //document.getElementById("<?= $_REQUEST['name_w'] ?>_rangemaxOpacity").addEventListener("click", function(){ upSlider('maxOpacity', 0.01, 2, 0.8)}, false);

                    if (!baseQuery.includes("heatmap.php")) {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_animation").addEventListener("click", function () { animateHeatmap() }, false);
                    }
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt").addEventListener("click", function () { prevHeatmapPage() }, false);
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt").addEventListener("click", function () { nextHeatmapPage() }, false);

                    if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_changeRad").addEventListener("change", function () { updateChangeRadiusOnZoom(this) }, false);
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_estimateRad").addEventListener("change", function () { computeRadiusOnData(this) }, false);
                    }

                    if (current_page == 0) {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt").style.visibility = "hidden";
                    } else {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt").style.visibility = "visible";
                    }

                    if (current_page == numHeatmapPages() - 1) {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt").style.visibility = "hidden";
                    } else {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt").style.visibility = "visible";
                    }
                    //    }
                }
                setTimeout(checkLegend, 500);

                return map.legendHeatmapDiv;
            };

            // INIZIO TRAFFICFLOWMANAGER GESTIONE LEGENDA + SLIDER OPACITA', PAGINE E ANIMAZIONE
            map.trafficLegendHeatmap.onAdd = function () {
                map.trafficLegendHeatmapDiv = L.DomUtil.create('div');
                map.trafficLegendHeatmapDiv.id = "trafficHeatmapLegend";
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(map.trafficLegendHeatmapDiv);
                    L.DomEvent.on(map.trafficLegendHeatmapDiv, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(map.trafficLegendHeatmapDiv, 'click', L.DomEvent.stopPropagation);
                }
                map.trafficLegendHeatmapDiv.style.width = "340px";
                map.trafficLegendHeatmapDiv.style.fontWeight = "bold";
                map.trafficLegendHeatmapDiv.style.background = "#cccccc";
                map.trafficLegendHeatmapDiv.style.padding = "10px";

                let colors = [];
                colors['blue'] = '#0000FF';
                colors['cyan'] = '#00FFFF';
                colors['green'] = '#008000';
                colors['yellowgreen'] = '#9ACD32';
                colors['yellow'] = '#FFFF00';
                colors['gold'] = '#FFD700';
                colors['orange'] = '#FFA500';
                colors['darkorange'] = '#FF8C00';
                colors['orangered'] = '#FF4500';
                colors['tomato'] = '#FF6347';
                colors['red'] = '#FF0000';
                let colors_value = [];
                colors_value['blue'] = '#0000FF';
                colors_value['cyan'] = '#00FFFF';
                colors_value['green'] = '#008000';
                colors_value['yellowgreen'] = '#9ACD32';
                colors_value['yellow'] = '#FFFF00';
                colors_value['gold'] = '#FFD700';
                colors_value['orange'] = '#FFA500';
                colors_value['darkorange'] = '#FF8C00';
                colors_value['tomato'] = '#FF6347';
                colors_value['orangered'] = '#FF4500';
                colors_value['red'] = '#FF0000';
                map.trafficLegendHeatmapDiv.innerHTML += '<div class="textTitle" style="text-align:center">' + trafficMapName + '</div>';
                map.trafficLegendHeatmapDiv.innerHTML += '<div id="<?= $_REQUEST['name_w'] ?>_controlsContainer" style="height:20px"><div class="text"  style="width:50%; float:left">' + '<?php echo ucfirst(isset($_REQUEST["profile"]) ? $_REQUEST["profile"] : "Traffic Heatmap Controls:"); ?></div><div class="text" style="width:50%; float:right"><label class="switch"><input type="checkbox" id="<?= $_REQUEST['name_w'] ?>_animation_traffic"><div class="slider round"><span class="animationOn"></span><span class="animationOff" style="color: black; text-align: right">24H</span><span class="animationOn" style="color: black; text-align: right">Static</span></div></label></div></div>';

                // max opacity
                map.trafficLegendHeatmapDiv.innerHTML +=
                    '<div id="trafficHeatmapOpacityControl">' +
                    '<div style="display:inline-block; vertical-align:super;">Max Opacity: &nbsp;&nbsp;&nbsp;&nbsp;</div>' +
                    '<div id="<?= $_REQUEST['name_w'] ?>_downSlider_opacity_traffic" style="display:inline-block; vertical-align:super; color: #0078A8">&#10094;</div>&nbsp;&nbsp;&nbsp;' +
                    '<input id="<?= $_REQUEST['name_w'] ?>_slidermaxTrafficOpacity" style="display:inline-block; vertical-align:baseline; width:auto" type="range" min="0" max="1" value="' + current_traffic_opacity + '" step="0.01">' +
                    '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<div id="upSlider_opacity_traffic" style="display:inline-block;vertical-align:super; color: #0078A8">&#10095;</div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
                    '<span id="<?= $_REQUEST['name_w'] ?>_rangemaxTrafficOpacity" style="display:inline-block;vertical-align:super;">' + current_traffic_opacity + '</span>' +
                    '</div>';

                // Traffic Heatmap Navigation Buttons (prev & next)
                map.trafficLegendHeatmapDiv.innerHTML +=
                    '<div id="heatmapNavigationCnt_traffic">' +
                    '<input type="button" id="<?= $_REQUEST['name_w'] ?>_prevButt_traffic" value="< Prev" style="float: left"/>' +
                    '<input type="button" id="<?= $_REQUEST['name_w'] ?>_nextButt_traffic" value="Next >" style="float: right"/>' +
                    '<div id="<?= $_REQUEST['name_w'] ?>_heatMapDescr_traffic" style="text-align: center">' + trafficMapDate + '</p>' +
                    '</div>';

                function checkLegend() {
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_slidermaxTrafficOpacity").addEventListener("input", function () { setOption('maxTrafficOpacity', this.value, 2) }, false);
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_animation_traffic").addEventListener("click", function () { animateTrafficHeatmap() }, false);
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt_traffic").addEventListener("click", function () { prevTrafficHeatmapPage() }, false);
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt_traffic").addEventListener("click", function () { nextTrafficHeatmapPage() }, false);

                    if (current_page_traffic == 0) {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt_traffic").style.visibility = "hidden";
                    } else {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt_traffic").style.visibility = "visible";
                    }

                    if (current_page_traffic == numTrafficHeatmapPages() - 1) {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt_traffic").style.visibility = "hidden";
                    } else {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt_traffic").style.visibility = "visible";
                    }
                }
                setTimeout(checkLegend, 500);
                return map.trafficLegendHeatmapDiv;
            };

            function removeTrafficHeatmap(index, isAnimated) {
                if (isAnimated) {
                    map.defaultMapRef.removeLayer(map.eventsOnMap[index]);
                } else {
                    if (trafficWmsLayer) {
                        map.defaultMapRef.removeLayer(trafficWmsLayer);
                        trafficWmsLayer = null;
                    } else if (newTfrLayer) {
                        map.defaultMapRef.removeLayer(newTfrLayer);
                        newTfrLayer = null;
                    }
                }
                map.defaultMapRef.removeControl(map.trafficLegendHeatmap);
                map.defaultMapRef.removeControl(map.eventsOnMap[index + 1].legendColors);
                map.eventsOnMap.splice(index, 2);
            }

            function nextTrafficHeatmapPage() {
                if (animationFlagTraffic) {
                    return;
                }
                animationFlagTraffic = false;
                if (current_page_traffic > 0) {
                    current_page_traffic--;
                    changeTrafficHeatmapPage(current_page_traffic);
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType === 'traffic_heatmap') {
                            event = map.eventsOnMap[i + 1]; // aggiorna evento corretto in caso di più heatmap presenti sulla mappa
                            removeTrafficHeatmap(i, false)
                            break;
                        }
                    }
                    addHeatmapFromClient(false);
                }
            }

            function prevTrafficHeatmapPage() {
                if (animationFlagTraffic) {
                    return;
                }
                animationFlagTraffic = false;
                if (current_page_traffic < numTrafficHeatmapPages() - 1) {
                    current_page_traffic++;
                    changeTrafficHeatmapPage(current_page_traffic);
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType === 'traffic_heatmap') {
                            event = map.eventsOnMap[i + 1] // aggiorna evento corretto in caso di più heatmap presenti sulla mappa
                            removeTrafficHeatmap(i, false)
                            break;
                        }
                    }
                    addHeatmapFromClient(false);
                }
            }

            function animateTrafficHeatmap() {
                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if (map.eventsOnMap[i].eventType === 'traffic_heatmap') {
                        event = map.eventsOnMap[i + 1] // aggiorna evento corretto in caso di più heatmap presenti sulla mappa
                        removeTrafficHeatmap(i, false)
                        break;
                    } else if (map.eventsOnMap[i]._url && map.eventsOnMap[i]._url.includes("animate") && map.eventsOnMap[i].options.pane.includes("TrafficFlowManager")) {
                        event = map.eventsOnMap[i + 1] // aggiorna evento corretto in caso di più heatmap presenti sulla mappa
                        removeTrafficHeatmap(i, true)
                        break;
                    }
                }
                if (!animationFlagTraffic) {
                    animationFlagTraffic = true;
                    addHeatmapFromClient(animationFlagTraffic);
                } else {
                    animationFlagTraffic = false;
                    addHeatmapFromClient(animationFlagTraffic);
                }
            }
            // FINE TRAFFICFLOWMANAGER GESTIONE LEGENDA + SLIDER OPACITA', PAGINE E ANIMAZIONE

            function nextHeatmapPage() {
                animationFlag = false;
                if (current_page > 0) {
                    current_page--;
                    changeHeatmapPage(current_page);

                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        // logica per evitare di rimuovere layer di trafficflowmanager
                        if (i > 0 && map.eventsOnMap[i - 1].eventType === 'traffic_heatmap') {
                            continue
                        } else if (map.eventsOnMap[i].eventType === 'traffic_heatmap') {
                            continue
                        } else if (i > 0 && map.eventsOnMap[i - 1]._url && map.eventsOnMap[i - 1]._url.includes("animate") && map.eventsOnMap[i - 1].options.pane.includes("TrafficFlowManager")) {
                            continue
                        } else if (map.eventsOnMap[i]._url && map.eventsOnMap[i]._url.includes("animate") && map.eventsOnMap[i].options.pane.includes("TrafficFlowManager")) {
                            continue
                        }
                        if (map.eventsOnMap[i].eventType === 'heatmap') {
                            removeHeatmap(false);
                            map.eventsOnMap.splice(i, 1);
                        } else if (map.eventsOnMap[i].type === 'addHeatmap') {
                            event = map.eventsOnMap[i] // aggiorna evento corretto in caso di più heatmap
                            removeHeatmapColorLegend(i, false);
                            map.eventsOnMap.splice(i, 1);
                        } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                            if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails') {
                                map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                map.eventsOnMap.splice(i, 1);
                            }
                            /*  map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                              map.eventsOnMap.splice(i, 1);*/
                        }
                    }

                    if (addMode === 'additive') {
                        //   if (baseQuery.includes("heatmap.php")) {
                        // addHeatmapToMap();
                        addHeatmapFromClient(false);
                        /*   } else {
                               // addHeatmapFromWMSClient();        // TBD
                           }*/
                    }
                    if (addMode === 'exclusive') {
                        map.defaultMapRef.eachLayer(function (layer) {
                            map.defaultMapRef.removeLayer(layer);
                        });
                        map.eventsOnMap.length = 0;

                        //Remove WidgetAlarm active pins
                        $.event.trigger({
                            type: "removeAlarmPin",
                        });
                        //Remove WidgetEvacuationPlans active pins
                        $.event.trigger({
                            type: "removeEvacuationPlanPin",
                        });
                        //Remove WidgetEvents active pins
                        $.event.trigger({
                            type: "removeEventFIPin",
                        });
                        //Remove WidgetResources active pins
                        $.event.trigger({
                            type: "removeResourcePin",
                        });
                        //Remove WidgetOperatorEvents active pins
                        $.event.trigger({
                            type: "removeOperatorEventPin",
                        });
                        //Remove WidgetTrafficEvents active pins
                        $.event.trigger({
                            type: "removeTrafficEventPin",
                        });
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                            maxZoom: leafletMaxZoom,
                            maxNativeZoom: leafletNativeMaxZoom
                        }).addTo(map.defaultMapRef);

                        addHeatmapFromClient(false);
                    }

                }
            }

            function animateHeatmap() {
                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    // logica per evitare di rimuovere layer di trafficflowmanager
                    if (i > 0 && map.eventsOnMap[i - 1].eventType === 'traffic_heatmap') {
                        continue
                    } else if (map.eventsOnMap[i].eventType === 'traffic_heatmap') {
                        continue
                    } else if (i > 0 && map.eventsOnMap[i - 1]._url && map.eventsOnMap[i - 1]._url.includes("animate") && map.eventsOnMap[i - 1].options.pane.includes("TrafficFlowManager")) {
                        continue
                    } else if (map.eventsOnMap[i]._url && map.eventsOnMap[i]._url.includes("animate") && map.eventsOnMap[i].options.pane.includes("TrafficFlowManager")) {
                        continue
                    }
                    if (map.eventsOnMap[i].eventType === 'heatmap') {
                        removeHeatmap(false);
                        map.eventsOnMap.splice(i, 1);
                    } else if (map.eventsOnMap[i].type === 'addHeatmap') {
                        event = map.eventsOnMap[i]; // aggiorna evento corretto in caso di più heatmap	
                        removeHeatmapColorLegend(i, false);
                        map.eventsOnMap.splice(i, 1);
                    } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                        if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails') {
                            map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                            map.eventsOnMap.splice(i, 1);
                        }
                    }
                }
                if (animationFlag === false) {
                    animationFlag = true;
                    addHeatmapFromClient(animationFlag);
                } else {
                    animationFlag = false;
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType === 'heatmap') {
                            removeHeatmap(false);
                            //    removeHeatmapColorLegend(i, false);
                            map.eventsOnMap.splice(i, 1);
                        } /*else if (map.eventsOnMap[i].type === 'addHeatmap') {
                                                removeHeatmapColorLegend(i, false);
                                                map.eventsOnMap.splice(i, 1);
                                            }*/
                    }
                    addHeatmapFromClient(animationFlag);
                }
            }

            //   window.nextHeatmapPage = function()
            function prevHeatmapPage() {
                animationFlag = false;
                if (current_page < numHeatmapPages() - 1) {
                    current_page++;
                    changeHeatmapPage(current_page);

                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        // logica per evitare di rimuovere layer di trafficflowmanager
                        if (i > 0 && map.eventsOnMap[i - 1].eventType === 'traffic_heatmap') {
                            continue
                        } else if (map.eventsOnMap[i].eventType === 'traffic_heatmap') {
                            continue
                        } else if (i > 0 && map.eventsOnMap[i - 1]._url && map.eventsOnMap[i - 1]._url.includes("animate") && map.eventsOnMap[i - 1].options.pane.includes("TrafficFlowManager")) {
                            continue
                        } else if (map.eventsOnMap[i]._url && map.eventsOnMap[i]._url.includes("animate") && map.eventsOnMap[i].options.pane.includes("TrafficFlowManager")) {
                            continue
                        }
                        if (map.eventsOnMap[i].eventType === 'heatmap') {
                            removeHeatmap(false);
                            map.eventsOnMap.splice(i, 1);
                        } else if (map.eventsOnMap[i].type === 'addHeatmap') {
                            event = map.eventsOnMap[i]; // aggiorna evento corretto in caso di più heatmap
                            removeHeatmapColorLegend(i, false);
                            map.eventsOnMap.splice(i, 1);
                        } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                            if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails') {
                                map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                map.eventsOnMap.splice(i, 1);
                            }
                            /*   map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                               map.eventsOnMap.splice(i, 1);*/
                        }
                    }

                    if (addMode === 'additive') {
                        //   if (baseQuery.includes("heatmap.php")) {
                        // addHeatmapToMap();
                        addHeatmapFromClient(false);
                        /*   } else {
                              // addHeatmapFromWMSClient();        // TBD
                           }*/
                    }
                    if (addMode === 'exclusive') {
                        map.defaultMapRef.eachLayer(function (layer) {
                            map.defaultMapRef.removeLayer(layer);
                        });
                        map.eventsOnMap.length = 0;

                        //Remove WidgetAlarm active pins
                        $.event.trigger({
                            type: "removeAlarmPin",
                        });
                        //Remove WidgetEvacuationPlans active pins
                        $.event.trigger({
                            type: "removeEvacuationPlanPin",
                        });
                        //Remove WidgetEvents active pins
                        $.event.trigger({
                            type: "removeEventFIPin",
                        });
                        //Remove WidgetResources active pins
                        $.event.trigger({
                            type: "removeResourcePin",
                        });
                        //Remove WidgetOperatorEvents active pins
                        $.event.trigger({
                            type: "removeOperatorEventPin",
                        });
                        //Remove WidgetTrafficEvents active pins
                        $.event.trigger({
                            type: "removeTrafficEventPin",
                        });
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                            maxZoom: leafletMaxZoom,
                            maxNativeZoom: leafletNativeMaxZoom
                        }).addTo(map.defaultMapRef);

                        addHeatmapFromClient(false);
                    }

                }
            }

            function prepareCustomMarkerForPointAndClick(dataObj, color1, color2) {
                var latLngId = dataObj.latitude + "" + dataObj.longitude;
                latLngId = latLngId.replace(".", "");
                latLngId = latLngId.replace(".", "");//Incomprensibile il motivo ma con l'espressione regolare /./g non funziona

                var popupText = '<h3 class="recreativeEventMapTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + '); text-transform: none;">' + dataObj.mapName + '</h3>';
                /*    if((serviceProperties.serviceUri !== '')&&(serviceProperties.serviceUri !== undefined)&&(serviceProperties.serviceUri !== 'undefined')&&(serviceProperties.serviceUri !== null)&&(serviceProperties.serviceUri !== 'null')) {
                        popupText += '<div class="recreativeEventMapSubTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">' + "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + '</div>';
                      //  popupText += '<div class="recreativeEventMapSubTitle">' + "Value Name: " + serviceProperties.serviceUri.split("/")[serviceProperties.serviceUri.split("/").length - 1] + '</div>';
                    }*/
                popupText += '<div class="recreativeEventMapBtnContainer"><span data-id="' + latLngId + '" class="recreativeEventMapDetailsBtn recreativeEventMapBtn recreativeEventMapBtnActive" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Heatmap Details</span></div>';

                popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDetailsContainer" style="height:100px; width:270px;">';

                popupText += '<table id="' + latLngId + '" class="gisPopupGeneralDataTable" style="width:90%">';
                //Intestazione
                popupText += '<thead>';
                popupText += '<th style="background: ' + color2 + '">Description</th>';
                popupText += '<th style="background: ' + color2 + '">Value</th>';
                popupText += '</thead>';

                //Corpo
                popupText += '<tbody>';

                //    var myKPIFromTimeRangeUTC = new Date(myKPIFromTimeRange).toUTCString();
                //    var myKPIFromTimeRangeISO = new Date(myKPIFromTimeRangeUTC).toISOString();
                //    var myKPIFromTimeRangeISOTrimmed = myKPIFromTimeRangeISO.substring(0, isoDate.length - 8);

                var dateTime = new Date(dataObj.dataTime);// Milliseconds to date
                dateTime = dateTime.getDate() + "\/" + parseInt(dateTime.getMonth() + 1) + "\/" + dateTime.getFullYear() + " " + dateTime.getHours() + ":" + dateTime.getMinutes() + ":" + dateTime.getSeconds();

                popupText += '<tr><td style="text-align:left; font-size: 12px;">Date & Time:</td><td style="font-size: 12px;">' + dateTime + '</td></tr>';
                popupText += '<tr><td style="text-align:left; font-size: 12px;">Metric Name:</td><td style="font-size: 12px;">' + dataObj.metricName + '</td></tr>';
                popupText += '<tr><td style="text-align:left; font-size: 12px;">Heatmap Value:</td><td style="font-size: 12px;">' + dataObj.value + '</td></tr>';
                popupText += '<tr><td style="text-align:left; font-size: 12px;">Coordinates:</td><td style="font-size: 12px;">' + dataObj.latitude + ', ' + dataObj.longitude + '</td></tr>';

                return popupText;
            }

            //   $('#'+event.target).on('click', function(e) {
            //   map.defaultMapRef.off('click', heatmapClick);
            map.defaultMapRef.on('click', heatmapClick = function (e) {
                if (map.testMetadata != null) {
                    //    if (map.testMetadata.metadata.file != 1) {
                    var heatmapPointAndClickData = null;
                    //  alert("Click on Map !");
                    var pointAndClickCoord = e.latlng;
                    var pointAndClickLat = pointAndClickCoord.lat.toFixed(5);
                    var pointAndClickLng = pointAndClickCoord.lng.toFixed(5);
                    //        var pointAndClickApiUrl = "https://heatmap.snap4city.org/interp.php?latitude=" + pointAndClickLat + "&longitude=" + pointAndClickLng + "&dataset=" + map.testMetadata.metadata.mapName + "&date=" + map.testMetadata.metadata.date;
                    var pointAndClickApiUrl = heatmapUrl + "interp.php?latitude=" + pointAndClickLat + "&longitude=" + pointAndClickLng + "&dataset=" + map.testMetadata.metadata.mapName + "&date=" + map.testMetadata.metadata.date;
                    $.ajax({
                        url: pointAndClickApiUrl,
                        async: true,
                        success: function (heatmapPointAndClickData) {
                            var popupData = {};
                            popupData.mapName = heatmapPointAndClickData.mapName;
                            popupData.latitude = pointAndClickLat;
                            popupData.longitude = pointAndClickLng;
                            popupData.metricName = heatmapPointAndClickData.metricName;
                            popupData.dataTime = heatmapPointAndClickData.date;
                            if (heatmapPointAndClickData.value) {
                                popupData.value = heatmapPointAndClickData.value.toFixed(5);
                                var customPointAndClickContent = prepareCustomMarkerForPointAndClick(popupData, "#C2D6D6", "#D1E0E0")
                                //   var pointAndClickPopup = L.popup(customPointAndClickMarker).openOn(map.defaultMapRef);
                                var popup = L.popup()
                                    .setLatLng(pointAndClickCoord)
                                    .setContent(customPointAndClickContent)
                                    .openOn(map.defaultMapRef);
                            }
                        },
                        error: function (errorData) {
                            console.log("Ko Point&Click Heatmap API");
                            console.log(JSON.stringify(errorData));
                        }
                    });
                    //    }
                }
            });

            function distance(lat1, lon1, lat2, lon2, unit) {   // unit: 'K' for Kilometers
                if ((lat1 == lat2) && (lon1 == lon2)) {
                    return 0;
                }
                else {
                    var radlat1 = Math.PI * lat1 / 180;
                    var radlat2 = Math.PI * lat2 / 180;
                    var theta = lon1 - lon2;
                    var radtheta = Math.PI * theta / 180;
                    var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
                    if (dist > 1) {
                        dist = 1;
                    }
                    dist = Math.acos(dist);
                    dist = dist * 180 / Math.PI;
                    dist = dist * 60 * 1.1515;
                    if (unit == "K") { dist = dist * 1.609344 }
                    if (unit == "N") { dist = dist * 0.8684 }
                    return dist;
                }
            }

            function getRadius() {
                var radius;
                var currentZoom = map.defaultMapRef.getZoom();
                if (estimateRadiusFlag && estimatedRadius) {
                    metresPerPixel = 40075016.686 * Math.abs(Math.cos(map.defaultMapRef.getCenter().lat * Math.PI / 180)) / Math.pow(2, currentZoom + 8);
                    radius = ((estimatedRadius * 1000) / metresPerPixel) / 50;
                    if (radius > 1000) {

                    } else if (radius > 1) {
                        if (currentZoom < prevZoom) {
                            prevZoom = currentZoom;
                            return radius / 1.2;
                        } else {
                            prevZoom = currentZoom;
                            return radius / 1.2;
                        }
                    } else {
                        prevZoom = currentZoom;
                        return 1;
                    }
                }
                if (prevZoom == null) {
                    prevZoom = widgetParameters.zoom;
                }
                if (currentZoom === 7) {
                    radius = 1;
                }
                else if (currentZoom === 8) {
                    radius = 1;
                }
                else if (currentZoom === 9) {
                    radius = 1;
                }
                else if (currentZoom === 10) {
                    if (currentZoom > prevZoom) {
                        radius = 2;
                    } else {
                        radius = 1;
                    }
                }
                else if (currentZoom === 11) {
                    if (currentZoom > prevZoom) {
                        radius = 3.5;
                    } else {
                        radius = 2;
                    }
                }
                else if (currentZoom === 12) {
                    if (currentZoom > prevZoom) {
                        radius = 10;
                    } else {
                        radius = 3.5;
                    }
                }
                else if (currentZoom === 13) {
                    if (currentZoom > prevZoom) {
                        radius = 16;
                    } else {
                        radius = 10;
                    }
                }
                else if (currentZoom === 14) {
                    if (currentZoom > prevZoom) {
                        radius = 31;
                    } else {
                        radius = 16;
                    }
                }
                else if (currentZoom === 15) {
                    if (currentZoom > prevZoom) {
                        radius = 60;
                    } else {
                        radius = 31;
                    }
                }
                else if (currentZoom === 16) {
                    if (currentZoom > prevZoom) {
                        radius = 80;
                    } else {
                        radius = 60;
                    }
                }
                else if (currentZoom === 17) {
                    if (currentZoom > prevZoom) {
                        radius = 100;
                    } else {
                        radius = 80;
                    }
                }
                else if (currentZoom === 18) {
                    if (currentZoom > prevZoom) {
                        radius = 130;
                    } else {
                        radius = 100;
                    }
                }
                prevZoom = currentZoom;
                return radius;
            }

            //    map.defaultMapRef.on('zoomstart', function(ev) {
            map.defaultMapRef.on('zoomend', function (ev) {
                if (prevZoom === null) {
                    prevZoom = widgetParameters.zoom;
                }
                // zoom level changed... adjust heatmap layer options!
                if (changeRadiusOnZoom === true) {

                    if (baseQuery.includes("heatmap.php")) {    // OLD HEATMAP
                        // INSERIRE CAMBIO SLIDER ZOOM
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_sliderradius").value = parseFloat(getRadius()).toFixed(1);
                        setOption('radius', getRadius(), 1);           // MODALITA HEATMAP ON ZOOM
                    }
                } else {
                    setOption('radius', current_radius, 1);
                }
            });


            function addHeatmapToMap() {
                animationFlag = false;
                animationFlagTraffic = false;
                odOnMap = false;
                //    current_page = 0;
                try {
                    const isAddingTrafficHeatmap = (event.passedData.includes(geoServerUrl) && event.passedData.includes("trafficflowmanager=true")) 
                        || event.passedData.includes("<?= $serviceMapUrlForTrendApi ?>" + "trafficflow") 
                        || event.passedData.includes("<?= $kbUrlSuperServiceMap ?>" + "trafficflow");
                    if (map.eventsOnMap.length > 0) {
                        const normalHeatmapPresent = map.eventsOnMap.some(event => (event.eventType === 'heatmap' || event.eventType === 'od' || (event._url && event._url.includes("animate") && !event.options.pane.includes("TrafficFlowManager"))))
                        for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                            // logica additività trafficflowmanager
                            // non rimuovere layer dalla mappa se:
                            // 1. sto aggiungendo una heatmap normale e sulla mappa è presente una traffic heatmap, oppure
                            // 2. sto aggiungendo una traffic heatmap e sulla mappa è presente una heatmap normale
                            if (!isAddingTrafficHeatmap && !normalHeatmapPresent) {
                                // in questo caso non devo rimuovere nulla
                                break;
                            } else if (isAddingTrafficHeatmap && normalHeatmapPresent) {
                                // in questo caso devo solo rimuovere la traffic heatmap corrente
                                if (map.eventsOnMap[i].eventType === 'traffic_heatmap') {
                                    removeTrafficHeatmap(i, false)
                                    current_page_traffic = 0;
                                    break;
                                } else if (map.eventsOnMap[i]._url && map.eventsOnMap[i]._url.includes("animate") && map.eventsOnMap[i].options.pane.includes("TrafficFlowManager")) {
                                    removeTrafficHeatmap(i, true)
                                    current_page_traffic = 0;
                                    break;
                                }
                                continue;
                            }

                            if (isAddingTrafficHeatmap) {
                                // se sto aggiungendo una traffic heatmap e già ce n'è una sulla mappa, rimuovo la traffic heatmap corrente
                                if (i > 0 && map.eventsOnMap[i - 1].eventType === 'traffic_heatmap') {
                                    removeTrafficHeatmap(i - 1, false)
                                    current_page_traffic = 0;
                                    break;
                                } else if (i > 0 && map.eventsOnMap[i - 1]._url && map.eventsOnMap[i - 1]._url.includes("animate") && map.eventsOnMap[i - 1].options.pane.includes("TrafficFlowManager")) {
                                    removeTrafficHeatmap(i - 1, true)
                                    current_page_traffic = 0;
                                    break;
                                }
                            } else if (i > 0 && map.eventsOnMap[i - 1].eventType === 'traffic_heatmap') {
                                // logica per evitare di rimuovere layer di trafficflowmanager
                            } else if (map.eventsOnMap[i]._url && map.eventsOnMap[i]._url.includes("animate") && map.eventsOnMap[i].options.pane.includes("TrafficFlowManager")) {
                                // logica per evitare di rimuovere layer di trafficflowmanager
                            } else if (i > 0 && map.eventsOnMap[i - 1]._url && map.eventsOnMap[i - 1]._url.includes("animate") && map.eventsOnMap[i - 1].options.pane.includes("TrafficFlowManager")) {
                                // logica per evitare di rimuovere layer di trafficflowmanager

                            } else if (map.eventsOnMap[i].eventType === 'heatmap') {
                                removeHeatmap(true);
                                map.eventsOnMap.splice(i, 1);
                            } else if (map.eventsOnMap[i].type === 'addHeatmap') {
                                removeHeatmapColorLegend(i, true);
                                map.eventsOnMap.splice(i, 1);
                                map.defaultMapRef.off('click', heatmapClick);
                            } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                                if (map.eventsOnMap[i].type === 'trafficRealTimeDetails') {
                                    map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                    map.eventsOnMap.splice(i, 1);
                                } else if (map.eventsOnMap[i]._url) {
                                    if (map.eventsOnMap[i]._url.includes("animate")) {
                                        map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                        map.eventsOnMap.splice(i, 1);
                                    }
                                } else if (map.eventsOnMap[i].eventType === 'od') {
                                    map.defaultMapRef.removeLayer(geojson_layer);
                                    if (geojson_layer_all) {
                                        map.defaultMapRef.removeLayer(geojson_layer_all);
                                    }
                                    map.defaultMapRef.removeLayer(sourcePolygon);
                                    map.defaultMapRef.removeControl(map.legendOd);
                                    map.defaultMapRef.removeControl(map.flowInfo);
                                    map.eventsOnMap.splice(i, 1);
                                } else if (map.eventsOnMap[i].type === 'addOD') {
                                    current_page = 0;
                                    map.defaultMapRef.removeControl(map.eventsOnMap[i].legendColors);
                                    map.eventsOnMap.splice(i, 1);
                                } else if (map.eventsOnMap[i].type === 'addPolyStat') {
                                    map.defaultMapRef.removeControl(map.eventsOnMap[i].legendColors);
                                    map.eventsOnMap.splice(i, 1);
                                }
                            }
                        }
                    }

                    if (!event.passedData.includes("heatmap.php")) {
                        passedParams = event.passedParams;

                        var color1 = passedParams.color1;
                        var color2 = passedParams.color2;
                        var desc = passedParams.desc;

                        var loadingDiv = $('<div class="gisMapLoadingDiv"></div>');

                        if ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length > 0) {
                            loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').last());
                        } else {
                            loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_map'));
                        }

                        loadingDiv.css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length * loadingDiv.height())) + "px");
                        loadingDiv.css("left", ($('#<?= $_REQUEST['name_w'] ?>_div').width() - loadingDiv.width()) + "px");

                        var loadingText = $('<p class="gisMapLoadingDivTextPar">adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                        var loadOkText = $('<p class="gisMapLoadingDivTextPar"><b>' + desc.toLowerCase() + '</b> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                        var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');

                        loadingDiv.css("background", color1);
                        loadingDiv.css("background", "-webkit-linear-gradient(left top, " + color1 + ", " + color2 + ")");
                        loadingDiv.css("background", "-o-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                        loadingDiv.css("background", "-moz-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                        loadingDiv.css("background", "linear-gradient(to bottom right, " + color1 + ", " + color2 + ")");

                        loadingDiv.show();

                        loadingDiv.append(loadingText);
                        loadingDiv.css("opacity", 1);

                        var parHeight = loadingText.height();
                        var parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                        loadingText.css("margin-top", parMarginTop + "px");
                    }

                    let heatmap = {};
                    heatmap.eventType = "heatmap";
                    baseQuery = event.passedData;
                    let latitude_min = map.defaultMapRef.getBounds()._southWest.lat;
                    let latitude_max = map.defaultMapRef.getBounds()._northEast.lat;
                    let longitude_min = map.defaultMapRef.getBounds()._southWest.lng;
                    let longitude_max = map.defaultMapRef.getBounds()._northEast.lng;
                    // INIZIO TRAFFICFLOWMANAGER
                    if ((baseQuery.includes(geoServerUrl) && baseQuery.includes("trafficflowmanager=true"))
                        || baseQuery.includes("<?= $serviceMapUrlForTrendApi ?>" + "trafficflow")
                        || baseQuery.includes("<?= $kbUrlSuperServiceMap ?>" + "trafficflow")) {
                        heatmap.eventType = "traffic_heatmap";
                        // console.log("TrafficFlowManager INIT");

                        // Get dataset name and metadata API url from passed data
                        let datasetName = "";
                        if (baseQuery.includes("WMS&layers=")) {
                            datasetName = baseQuery.split("WMS&layers=")[1].split("&")[0];
                        } else {
                            datasetName = baseQuery.split("scenario=")[1].split("&")[0];
                        }
                        const apiUrl = geoServerUrl + "trafficflowmanager/api/metadata?fluxName=" + datasetName;
                        // console.log(apiUrl);
                        // Get layers metadata from API
                        //     heatmapData = null;
                        $.ajax({
                            url: apiUrl,
                            async: true,
                            cache: false,
                            dataType: "text",
                            success: function (data) {
                                trafficData = JSON.parse(data);
                                map.defaultMapRef.createPane('TrafficFlowManager:' + datasetName);
                                map.defaultMapRef.getPane('TrafficFlowManager:' + datasetName).style.zIndex = 420;

                                // Setup map
                                //       if (heatmapData && heatmapData.length > 0) {
                                let timestamp = trafficData[0].dateTime;
                                current_traffic_opacity = 1
                                trafficMapName = trafficData[0].fluxName;
                                trafficMapDate = timestamp.replace('T', ' ');

                                if (baseQuery.includes("WMS&layers=")) {
                                    // Add layer to map
                                    trafficWmsLayer = L.tileLayer.wms(geoServerUrl + "geoserver/wms", {
                                        layers: trafficData[0].layerName,
                                        format: 'image/png',
                                        crs: L.CRS.EPSG4326,
                                        transparent: true,
                                        opacity: current_traffic_opacity,
                                        pane: 'TrafficFlowManager:' + datasetName
                                    }).addTo(map.defaultMapRef);
                                } else {
                                    
                                    timestamp = new Date(timestamp).toISOString().replace('Z', '');
                                    let apiOsUrl = "<?= $kbUrlSuperServiceMap; ?>" + "trafficflow/?scenario=" + trafficMapName + "&dateObservedStart=" + encodeURIComponent(timestamp) + "&dateObservedEnd=" + encodeURIComponent(timestamp) + "&kind=reconstructed";
                                    $.ajax({
                                        url: apiOsUrl,
                                        method: 'GET',
                                        success: function (roads) {

                                            newTfrLayer = new L.LayerGroup();
                                            newTfrLayer = createTfrLayer(roads);
                                            newTfrLayer.addTo(map.defaultMapRef);

                                        },
                                        error: function (xhr, status, error) {
                                            console.error('Error fetching new traffic data:', error);
                                        }
                                    });

                                }

                                // Add Legend
                                map.trafficLegendHeatmap.addTo(map.defaultMapRef);
                                map.eventsOnMap.push(heatmap);
                                const heatmapLegendColors = L.control({ position: 'bottomright' });
                                heatmapLegendColors.onAdd = function () {
                                    const div = L.DomUtil.create('div', 'info legend');
                                    const legendImgPath = "../trafficRTDetails/legend.png";
                                    div.innerHTML += " <img src=" + legendImgPath + " height='120'" + '<br style="margin-bottom:20px;">';
                                    return div;
                                };
                                heatmapLegendColors.addTo(map.defaultMapRef);
                                event.legendColors = heatmapLegendColors;
                                map.eventsOnMap.push(event);

                                // Done!
                                loadingDiv.empty();
                                loadingDiv.append(loadOkText);
                                parHeight = loadOkText.height();
                                parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                loadOkText.css("margin-top", parMarginTop + "px");
                                setTimeout(function () {
                                    loadingDiv.css("opacity", 0);
                                    setTimeout(function () {
                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                        });
                                        loadingDiv.remove();
                                    }, 350);
                                }, 1000);

                                // return;
                            },
                            error: function (errorData) {
                                console.log("Ko Traffic Heatmap");
                                console.log(JSON.stringify(errorData));
                            }
                        });

                        return;
                    }
                    //      }
                    // FINE TRAFFICFLOWMANAGER
                    let query = "";
                    if (baseQuery.includes("heatmap.php")) {    // OLD HEATMAP
                        //  query = baseQuery + '&limit=30&latitude_min=' + latitude_min + '&latitude_max=' + latitude_max + '&longitude_min=' + longitude_min + '&longitude_max=' + longitude_max;
                        query = baseQuery + '&latitude_min=' + latitude_min + '&latitude_max=' + latitude_max + '&longitude_min=' + longitude_min + '&longitude_max=' + longitude_max;
                        query = query.replace("heatmap.php", "heatmap-metadata.php");       // CON QUESTA RIGA SI PREDONO SOLO I METADATI ORA !!!
                        let metricNameSplit = baseQuery.split("metricName=")[1];
                    } else {
                        //  let metricNameSplit = baseQuery.split("metricName=")[1];
                        //  heatmapMetricName = baseQuery.split("metricName=")[1];
                        //    var datasetNameAux = baseQuery.split("https://wmsserver.snap4city.org/geoserver/Snap4City/wms?service=WMS&layers=")[1];
                        var datasetNameAux = baseQuery.split("WMS&layers=")[1];
                        wmsDatasetName = datasetNameAux.split("&metricName=")[0];
                        //    query = 'https://heatmap.snap4city.org/heatmap-metadata.php?dataset=' + wmsDatasetName + '&latitude_min=' + latitude_min + '&latitude_max=' + latitude_max + '&longitude_min=' + longitude_min + '&longitude_max=' + longitude_max;
                        query = heatmapUrl + 'heatmap-metadata.php?dataset=' + wmsDatasetName + '&latitude_min=' + latitude_min + '&latitude_max=' + latitude_max + '&longitude_min=' + longitude_min + '&longitude_max=' + longitude_max;
                    }

                    heatmapData = null;
                    $.ajax({
                        url: query,
                        async: true,
                        cache: false,
                        dataType: "text",
                        success: function (data) {
                            heatmapData = JSON.parse(data);
                            //     for (var i = 0; i < heatmapData.length; i++) {
                            //heatmap recommender data
                            /*   map.testData = {
                                   //   max: 8,
                                   data: heatmapData[current_page].data
                               };  */

                            // Initialize array of Days from metadata
                            // daysArray = initDaysArray(heatmapData);

                            //heatmap recommender metadata
                            map.testMetadata = {
                                //   max: 8,
                                metadata: heatmapData[current_page].metadata
                            };

                            if (map.testMetadata.metadata.metricName !== undefined) {
                                heatmapMetricName = map.testMetadata.metadata.metricName
                            } else {
                                heatmapMetricName = "airTemperature";
                                mapName = "WMS_PROVA";
                            }

                            if (map.testMetadata.metadata.mapName !== undefined) {
                                mapName = map.testMetadata.metadata.mapName;
                            } else {
                                mapName = "WMS_PROVA";
                            }

                            if (map.testMetadata.metadata.date !== undefined) {
                                mapDate = map.testMetadata.metadata.date;
                            } else {
                                mapDate = "DATA";
                            }

                            $.ajax({
                                url: "../controllers/getHeatmapRange.php",
                                type: "GET",
                                data: {
                                    metricName: heatmapMetricName
                                },
                                async: true,
                                dataType: 'json',
                                success: function (data) {
                                    try {
                                        if (data['detail'] == "Ok") {

                                            //  if (data['heatmapRange'].length > 1) {
                                            if (data['heatmapRange'][0]) {
                                                heatmapRange = data['heatmapRange'];
                                                initHeatmapLayer(heatmapRange);   // OLD-API
                                                // Set current_radius come variabile globale per essere sincronizzata attraverso le varie azioni (zoom ecc...)
                                                if (current_radius == null) {
                                                    current_radius = map.cfg.radius;
                                                }
                                                if (current_opacity == null) {
                                                    current_opacity = map.cfg.maxOpacity;
                                                }

                                            } else {
                                                heatmapRange = [];
                                            }

                                            if (baseQuery.includes("heatmap.php")) {    // OLD HEATMAP
                                                //    if (event.passedData.includes("heatmap.php")) {
                                                addHeatmapFromClient(false);

                                            } else {                    // NEW HEATMAP  FIRST INSTANTIATION
                                                // CORTI - Pane
                                                map.defaultMapRef.createPane('Snap4City:' + wmsDatasetName);
                                                map.defaultMapRef.getPane('Snap4City:' + wmsDatasetName).style.zIndex = 420;

                                                //   if (animationFlag === false) {
                                                //   var timestampISO = "2019-01-23T20:20:15.000Z";
                                                var timestamp = map.testMetadata.metadata.date;
                                                var timestampISO = timestamp.replace(" ", "T") + ".000Z";
                                                //    wmsLayer = L.tileLayer.wms("https://wmsserver.snap4city.org/geoserver/Snap4City/wms", {
                                                wmsLayer = L.tileLayer.wms(geoServerUrl + "geoserver/Snap4City/wms", {
                                                    layers: 'Snap4City:' + wmsDatasetName,
                                                    format: 'image/png',
                                                    crs: L.CRS.EPSG4326,
                                                    transparent: true,
                                                    opacity: current_opacity,
                                                    time: timestampISO,
                                                    //  bbox: [24.7926004025304,60.1025194986424,25.1905923952885,60.2516802986263],
                                                    tiled: true,   // TESTARE COME ANTWERP ??
                                                    //  attribution: "IGN ©"
                                                    pane: 'Snap4City:' + wmsDatasetName	// CORTI
                                                }).addTo(map.defaultMapRef);

                                                //    current_opacity = 0.5;

                                                // add legend to map
                                                map.legendHeatmap.addTo(map.defaultMapRef);
                                                map.eventsOnMap.push(heatmap);
                                                var mapControlsContainer = document.getElementsByClassName("leaflet-control")[0];

                                                var heatmapLegendColors = L.control({ position: 'bottomleft' });

                                                heatmapLegendColors.onAdd = function (map) {

                                                    var div = L.DomUtil.create('div', 'info legend'),
                                                        grades = ["Legend"];
                                                    //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
                                                    var legendImgPath = heatmapRange[0].iconPath; // OLD-API
                                                    div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';    /// OLD-API
                                                    return div;
                                                };

                                                heatmapLegendColors.addTo(map.defaultMapRef);
                                                //  map.eventsOnMap.push(heatmap);

                                                event.legendColors = heatmapLegendColors;
                                                map.eventsOnMap.push(event);

                                                loadingDiv.empty();
                                                loadingDiv.append(loadOkText);

                                                parHeight = loadOkText.height();
                                                parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                                loadOkText.css("margin-top", parMarginTop + "px");

                                                setTimeout(function () {
                                                    loadingDiv.css("opacity", 0);
                                                    setTimeout(function () {
                                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                        });
                                                        loadingDiv.remove();
                                                    }, 350);
                                                }, 1000);
                                                //  } else {

                                                //  }    // FINE ELSE ANIMATION
                                            }    // FINE ELSE NEW WMS HEATMAP FIRST INSTANTIATION

                                        } else {
                                            console.log("Ko Heatmap");
                                            console.log(JSON.stringify(errorData));
                                            loadingDiv.empty();
                                            loadingDiv.append(loadKoText);

                                            parHeight = loadKoText.height();
                                            parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                            loadKoText.css("margin-top", parMarginTop + "px");

                                            setTimeout(function () {
                                                loadingDiv.css("opacity", 0);
                                                setTimeout(function () {
                                                    loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                        $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                    });
                                                    loadingDiv.remove();
                                                }, 350);
                                            }, 1000);
                                        }
                                    } catch (err) {
                                        loadingDiv.empty();
                                        loadingDiv.append(loadKoText);

                                        parHeight = loadKoText.height();
                                        parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                        loadKoText.css("margin-top", parMarginTop + "px");
                                        console.log("Error: " + err);
                                        setTimeout(function () {
                                            loadingDiv.css("opacity", 0);
                                            setTimeout(function () {
                                                loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                    $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                });
                                                loadingDiv.remove();
                                            }, 350);
                                        }, 1000);
                                    }
                                },
                                error: function (errorData) {
                                    console.log("Ko Heatmap");
                                    console.log(JSON.stringify(errorData));
                                    loadingDiv.empty();
                                    loadingDiv.append(loadKoText);

                                    parHeight = loadKoText.height();
                                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                    loadKoText.css("margin-top", parMarginTop + "px");

                                    setTimeout(function () {
                                        loadingDiv.css("opacity", 0);
                                        setTimeout(function () {
                                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                            });
                                            loadingDiv.remove();
                                        }, 350);
                                    }, 1000);
                                }
                            });
                        },
                        error: function (errorData) {
                            console.log("Ko Heatmap");
                            console.log(JSON.stringify(errorData));
                        }
                    });

                } catch (err) {
                    loadingDiv.empty();
                    loadingDiv.append(loadKoText);

                    parHeight = loadKoText.height();
                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                    loadKoText.css("margin-top", parMarginTop + "px");
                    console.log("Error: " + err);
                    setTimeout(function () {
                        loadingDiv.css("opacity", 0);
                        setTimeout(function () {
                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                            });
                            loadingDiv.remove();
                        }, 350);
                    }, 1000);
                }
            }

            //   window.addHeatmapFromClient = function(animationFlag) {
            function addHeatmapFromClient(animationFlag) {

                let heatmap = {};
                heatmap.eventType = "heatmap";

                /*   map.testData = {
                       //   max: 8,
                       data: heatmapData[current_page].data
                   };  */

                //heatmap recommender metadata

                passedParams = event.passedParams;

                var color1 = passedParams.color1;
                var color2 = passedParams.color2;
                var desc = passedParams.desc;

                var loadingDiv = $('<div class="gisMapLoadingDiv"></div>');

                if ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length > 0) {
                    loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').last());
                }
                else {
                    loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_map'));
                }

                loadingDiv.css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length * loadingDiv.height())) + "px");
                loadingDiv.css("left", ($('#<?= $_REQUEST['name_w'] ?>_div').width() - loadingDiv.width()) + "px");

                var loadingText = $('<p class="gisMapLoadingDivTextPar">adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                var loadOkText = $('<p class="gisMapLoadingDivTextPar"><b>' + desc.toLowerCase() + '</b> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');

                loadingDiv.css("background", color1);
                loadingDiv.css("background", "-webkit-linear-gradient(left top, " + color1 + ", " + color2 + ")");
                loadingDiv.css("background", "-o-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                loadingDiv.css("background", "-moz-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                loadingDiv.css("background", "linear-gradient(to bottom right, " + color1 + ", " + color2 + ")");

                loadingDiv.show();

                loadingDiv.append(loadingText);
                loadingDiv.css("opacity", 1);

                var parHeight = loadingText.height();
                var parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                loadingText.css("margin-top", parMarginTop + "px");

                let latitude_min = map.defaultMapRef.getBounds()._southWest.lat;
                let latitude_max = map.defaultMapRef.getBounds()._northEast.lat;
                let longitude_min = map.defaultMapRef.getBounds()._southWest.lng;
                let longitude_max = map.defaultMapRef.getBounds()._northEast.lng;
                // INIZIO TRAFFICFLOWMANAGER PAGINE/ANIMAZIONE
                if ((event.passedData.includes(geoServerUrl) && event.passedData.includes("trafficflowmanager=true"))
                    || event.passedData.includes("<?= $serviceMapUrlForTrendApi ?>" + "trafficflow")
                    || event.passedData.includes("<?= $kbUrlSuperServiceMap ?>" + "trafficflow")) {

                    //        console.log("TrafficFlowManager addHeatmapFromClient INIT page=" + current_page_traffic);
                    const animationWidth = event.passedData.includes("&width=") ? event.passedData.split("&width=")[1].split("&")[0] : "4000";
                    // const datasetName = event.passedData.split("WMS&layers=")[1].split("&")[0];
                    let datasetName = "";
                    if (event.passedData.includes("WMS&layers=")) {
                        datasetName = event.passedData.split("WMS&layers=")[1].split("&")[0];
                    } else {
                        datasetName = event.passedData.split("scenario=")[1].split("&")[0];
                    }
                    map.defaultMapRef.createPane('TrafficFlowManager:' + datasetName);
                    map.defaultMapRef.getPane('TrafficFlowManager:' + datasetName).style.zIndex = 420;
                    let timestamp = trafficData[current_page_traffic].dateTime;
                    heatmap.eventType = "traffic_heatmap";
                    //    if (timestamp != null) {

                    if (!animationFlagTraffic) {

                        // Update map date
                        trafficMapDate = timestamp.replace('T', ' ');

                        if (event.passedData.includes("WMS&layers=")) {
                            // Add correct layer to the map
                            trafficWmsLayer = L.tileLayer.wms(geoServerUrl + "geoserver/wms", {
                                layers: trafficData[current_page_traffic].layerName,
                                format: 'image/png',
                                crs: L.CRS.EPSG4326,
                                transparent: true,
                                opacity: current_traffic_opacity,
                                pane: 'TrafficFlowManager:' + datasetName
                            }).addTo(map.defaultMapRef);
                        } else {
                            timestamp = new Date(timestamp).toISOString().replace('Z', '');
                            let apiOsUrl = "<?= $kbUrlSuperServiceMap; ?>" + "trafficflow/?scenario=" + trafficMapName + "&dateObservedStart=" + encodeURIComponent(timestamp) + "&dateObservedEnd=" + encodeURIComponent(timestamp) + "&kind=reconstructed";
                            $.ajax({
                                url: apiOsUrl,
                                method: 'GET',
                                success: function (roads) {

                                    newTfrLayer = new L.LayerGroup();
                                    newTfrLayer = createTfrLayer(roads);
                                    newTfrLayer.addTo(map.defaultMapRef);

                                },
                                error: function (xhr, status, error) {
                                    console.error('Error fetching new traffic data:', error);
                                }
                            });

                        }

                        // Add legend and heatmap
                        map.trafficLegendHeatmap.addTo(map.defaultMapRef);
                        map.eventsOnMap.push(heatmap);

                    } else {

                        var animationCurrentDayTimestamp;
                        const animationCurrentDayFwdTimestamp = [];
                        const animationCurrentDayBckwdTimestamp = [];
                        let animationStringTimestamp;
                        const day = timestamp.substring(0, 10);

                        // Get all layer names for animation
                        if (current_page_traffic == 0) {
                            var offsetFwd = current_page_traffic;
                            while (trafficData[offsetFwd].dateTime.substring(0, 10) == day) {
                                animationCurrentDayFwdTimestamp.push(trafficData[offsetFwd].layerName);
                                offsetFwd++;
                                if (offsetFwd > numTrafficHeatmapPages() - 1) {
                                    break;
                                }
                            }
                        } else if (current_page_traffic == numTrafficHeatmapPages() - 1) {
                            var offsetBckwd = current_page_traffic - 1;
                            while (trafficData[offsetBckwd].dateTime.substring(0, 10) == day) {
                                animationCurrentDayBckwdTimestamp.push(trafficData[offsetBckwd].layerName);
                                offsetBckwd--;
                                if (offsetBckwd < 0) {
                                    break;
                                }
                            }
                        } else {
                            var offsetFwd = current_page_traffic;
                            while (trafficData[offsetFwd].dateTime.substring(0, 10) == day) {
                                animationCurrentDayFwdTimestamp.push(trafficData[offsetFwd].layerName);
                                offsetFwd++;
                                if (offsetFwd > numTrafficHeatmapPages() - 1) {
                                    break;
                                }
                            }
                            var offsetBckwd = current_page_traffic - 1;
                            while (trafficData[offsetBckwd].dateTime.substring(0, 10) == day) {
                                animationCurrentDayBckwdTimestamp.push(trafficData[offsetBckwd].layerName);
                                offsetBckwd--;
                                if (offsetBckwd < 0) {
                                    break;
                                }
                            }
                        }

                        // Concatenate layer names
                        animationCurrentDayTimestamp = animationCurrentDayFwdTimestamp.reverse().concat(animationCurrentDayBckwdTimestamp);
                        animationStringTimestamp = animationCurrentDayTimestamp.join(",");

                        // Create animated layer using WMS animator
                        const bbox = [longitude_min, latitude_min, longitude_max, latitude_max].join(",");
                        //   const imageUrl = geoServerUrl + 'geoserver/wms/animate?layers=' + trafficData[current_page_traffic].layerName + '&aparam=layers&avalues=' + animationStringTimestamp + '&format=image/gif;subtype=animated&format_options=gif_loop_continuosly:true;layout:message;gif_frames_delay:500&transparent=true&bbox=' + bbox;
                        const imageUrl = geoServerUrl + 'geoserver/wms/animate?layers=' + trafficData[current_page_traffic].layerName + '&aparam=layers&avalues=' + animationStringTimestamp + '&format=image/gif;subtype=animated&format_options=gif_loop_continuosly:true;layout:message;gif_frames_delay:1000&transparent=true&bbox=' + bbox + '&width=' + animationWidth;
                        const imageBounds = [[latitude_min, longitude_min], [latitude_max, longitude_max]];
                        const animatedLayer = L.imageOverlay(imageUrl, imageBounds, {
                            opacity: current_traffic_opacity,
                            pane: 'TrafficFlowManager:' + datasetName
                        }).addTo(map.defaultMapRef);

                        // Add legend (w/ correct options) and animated layer to the maps
                        map.trafficLegendHeatmap.addTo(map.defaultMapRef);
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_animation_traffic").checked = true;
                        $("<?= $_REQUEST['name_w'] ?>_slidermaxTrafficOpacity").slider('disable');
                        map.eventsOnMap.push(animatedLayer);
                    }

                    // Setup Legend
                    const heatmapLegendColors = L.control({ position: 'bottomright' });
                    heatmapLegendColors.onAdd = function () {
                        const div = L.DomUtil.create('div', 'info legend');
                        const legendImgPath = "../trafficRTDetails/legend.png";
                        div.innerHTML += " <img src=" + legendImgPath + " height='120'" + '<br style="margin-bottom:20px;">';
                        return div;
                    };
                    heatmapLegendColors.addTo(map.defaultMapRef);
                    event.legendColors = heatmapLegendColors;
                    map.eventsOnMap.push(event);

                    // Done!
                    loadingDiv.empty();
                    loadingDiv.append(loadOkText);
                    parHeight = loadOkText.height();
                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                    loadOkText.css("margin-top", parMarginTop + "px");
                    setTimeout(function () {
                        loadingDiv.css("opacity", 0);
                        setTimeout(function () {
                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                            });
                            loadingDiv.remove();
                        }, 350);
                    }, 1000);

                    return;
                    //    }
                }
                // FINE TRAFFICFLOWMANAGER PAGINE/ANIMAZIONE
                let query = "";
                if (event.passedData.includes("heatmap.php")) {    // OLD HEATMAP
                    //  query = baseQuery + '&limit=30&latitude_min=' + latitude_min + '&latitude_max=' + latitude_max + '&longitude_min=' + longitude_min + '&longitude_max=' + longitude_max;
                    query = event.passedData + '&latitude_min=' + latitude_min + '&latitude_max=' + latitude_max + '&longitude_min=' + longitude_min + '&longitude_max=' + longitude_max;
                    query = query.replace("heatmap.php", "heatmap-metadata.php");       // CON QUESTA RIGA SI PREDONO SOLO I METADATI ORA !!!
                    let metricNameSplit = event.passedData.split("metricName=")[1];
                } else {
                    //  let metricNameSplit = baseQuery.split("metricName=")[1];
                    //  heatmapMetricName = baseQuery.split("metricName=")[1];
                    //    var datasetNameAux = baseQuery.split("https://wmsserver.snap4city.org/geoserver/Snap4City/wms?service=WMS&layers=")[1];
                    var datasetNameAux = event.passedData.split("WMS&layers=")[1];
                    wmsDatasetName = datasetNameAux.split("&metricName=")[0];
                    //   query = 'https://heatmap.snap4city.org/heatmap-metadata.php?dataset=' + wmsDatasetName + '&latitude_min=' + latitude_min + '&latitude_max=' + latitude_max + '&longitude_min=' + longitude_min + '&longitude_max=' + longitude_max;
                    query = heatmapUrl + 'heatmap-metadata.php?dataset=' + wmsDatasetName + '&latitude_min=' + latitude_min + '&latitude_max=' + latitude_max + '&longitude_min=' + longitude_min + '&longitude_max=' + longitude_max;
                }

                heatmapData = null;
                $.ajax({
                    url: query,
                    async: true,
                    cache: false,
                    dataType: "text",
                    success: function (data) {
                        heatmapData = JSON.parse(data);
                        map.testMetadata = {
                            //   max: 8,
                            metadata: heatmapData[current_page].metadata
                        };

                        if (map.testMetadata.metadata.metricName !== undefined) {
                            heatmapMetricName = map.testMetadata.metadata.metricName
                        } else {
                            heatmapMetricName = "airTemperature";
                            mapName = "WMS_PROVA";
                        }

                        if (map.testMetadata.metadata.mapName !== undefined) {
                            mapName = map.testMetadata.metadata.mapName;
                        } else {
                            mapName = "WMS_PROVA";
                        }

                        if (map.testMetadata.metadata.date !== undefined) {
                            mapDate = map.testMetadata.metadata.date;
                        } else {
                            mapDate = "DATA";
                        }

                        $.ajax({
                            url: "../controllers/getHeatmapRange.php",
                            type: "GET",
                            data: {
                                metricName: heatmapMetricName
                            },
                            async: true,
                            dataType: 'json',
                            success: function (data) {
                                try {
                                    if (data['detail'] == "Ok") {
                                        //  if (data['heatmapRange'].length > 1) {

                                        if (data['heatmapRange'][0]) {
                                            heatmapRange = data['heatmapRange'];
                                            initHeatmapLayer(heatmapRange);   // OLD-API
                                            // Gestione della sincronia dei check-box del cambio raggio on zoom e computo raggio su base dati dopo aggiornamento legenda

                                        } else {
                                            heatmapRange = [];
                                        }

                                        if (baseQuery.includes("heatmap.php")) {    // OLD HEATMAP


                                            //    let dataQuery = "https://heatmap.snap4city.org/data/" + mapName + "/" + heatmapMetricName + "/" + mapDate.replace(" ", "T") + "Z/0";
                                            let dataQuery = heatmapUrl + "data/" + mapName + "/" + heatmapMetricName + "/" + mapDate.replace(" ", "T") + "Z/0";

                                            $.ajax({
                                                url: dataQuery,
                                                type: "GET",
                                                data: {
                                                },
                                                async: true,
                                                cache: false,
                                                dataType: 'json',
                                                success: function (heatmapResData) {
                                                    if (heatmapResData['data']) {
                                                        //    heatmapRange = heatmapData['heatmapRange'];
                                                        initHeatmapLayer(heatmapRange);   // OLD-API
                                                        // Set current_radius come variabile globale per essere sincronizzata attraverso le varie azioni (zoom ecc...)
                                                        if (current_radius == null) {
                                                            current_radius = map.cfg.radius;
                                                        }
                                                        if (current_opacity == null) {
                                                            current_opacity = map.cfg.maxOpacity;
                                                        }

                                                    } else {
                                                        heatmapRange = [];
                                                    }

                                                    if (baseQuery.includes("heatmap.php")) {    // OLD HEATMAP
                                                        map.testData = {
                                                            //   max: 8,
                                                            data: heatmapResData.data
                                                        };

                                                        //heatmap recommender metadata
                                                        map.testMetadata = {
                                                            //   max: 8,
                                                            metadata: heatmapResData.metadata
                                                        };

                                                        if (heatmapRange[0].range1Inf == null) {
                                                            if (heatmapMetricName == "EAQI" || heatmapMetricName == "CAQI") {
                                                                heatmapRange[0].range1Inf = heatmapRange[0].range4Inf;
                                                            } else if (heatmapMetricName == "CO" || heatmapMetricName == "Benzene") {
                                                                heatmapRange[0].range1Inf = heatmapRange[0].range3Inf;
                                                                heatmapRange[0].range10Inf = heatmapRange[0].range8Inf;
                                                            }
                                                        }
                                                        map.heatmapLayer.setData({ max: heatmapRange[0].range10Inf, min: heatmapRange[0].range1Inf, data: map.testData.data });
                                                        map.defaultMapRef.addLayer(map.heatmapLayer);   // OLD HEATMAP
                                                        //    if (estimateRadiusFlag === true) {
                                                        var distArray = [];             // MODALITA HEATMAP ON DATA DISTANCE
                                                        if (heatmapResData.length > 20) {
                                                            for (k = 0; k < 20; k++) {
                                                                distArray[k] = distance(heatmapResData[k].latitude, heatmapResData[k].latitude, heatmapResData[k + 1].latitude, heatmapResData[k + 1].latitude, "K");
                                                            }

                                                            var sum = 0;
                                                            for (var i = 0; i < distArray.length; i++) {
                                                                sum += distArray[i];
                                                            }
                                                            estimatedRadius = sum / distArray.length;
                                                            if (estimatedRadius <= 1) {
                                                                estimatedRadius = 2;
                                                            }
                                                            //   if (estimateRadiusFlag === true) {
                                                        } else {
                                                            estimatedRadius = current_radius;
                                                        }

                                                        metresPerPixel = 40075016.686 * Math.abs(Math.cos(map.defaultMapRef.getCenter().lat * Math.PI / 180)) / Math.pow(2, map.defaultMapRef.getZoom() + 8);
                                                        var initRadius = ((estimatedRadius * 1000) / metresPerPixel) / 50;
                                                        if (current_page == 0) {
                                                            setOption('radius', initRadius.toFixed(1), 1);
                                                        } else {
                                                            setOption('radius', current_radius.toFixed(1), 1);
                                                        }
                                                        //   }
                                                    } else {                    // NEW HEATMAP
                                                        //   var timestampISO = "2019-01-23T20:20:15.000Z";
                                                        map.defaultMapRef.createPane('Snap4City:' + wmsDatasetName);    // CORTI
                                                        map.defaultMapRef.getPane('Snap4City:' + wmsDatasetName).style.zIndex = 420;    // CORTI

                                                        var timestamp = map.testMetadata.metadata.date;
                                                        var timestampISO = timestamp.replace(" ", "T") + ".000Z";
                                                        //    wmsLayer = L.tileLayer.wms("https://wmsserver.snap4city.org/geoserver/Snap4City/wms", {
                                                        wmsLayer = L.tileLayer.wms(geoServerUrl + "geoserver/Snap4City/wms", {
                                                            layers: 'Snap4City:' + wmsDatasetName,
                                                            format: 'image/png',
                                                            crs: L.CRS.EPSG4326,
                                                            transparent: true,
                                                            opacity: current_opacity,
                                                            time: timestampISO,
                                                            //  bbox: [24.7926004025304,60.1025194986424,25.1905923952885,60.2516802986263],
                                                            tiled: true,
                                                            //  attribution: "IGN ©"
                                                            pane: 'Snap4City:' + wmsDatasetName	// CORTI
                                                        }).addTo(map.defaultMapRef);
                                                        //     current_opacity = 0.5;

                                                    }

                                                    // add legend to map
                                                    map.legendHeatmap.addTo(map.defaultMapRef);
                                                    map.eventsOnMap.push(heatmap);
                                                    var mapControlsContainer = document.getElementsByClassName("leaflet-control")[0];

                                                    //    var legendImgPath = heatmapRange[0].iconPath;
                                                    //     div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';
                                                    var heatmapLegendColors = L.control({ position: 'bottomleft' });

                                                    heatmapLegendColors.onAdd = function (map) {

                                                        var div = L.DomUtil.create('div', 'info legend'),
                                                            grades = ["Legend"];
                                                        //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
                                                        var legendImgPath = heatmapRange[0].iconPath; // OLD-API
                                                        div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';    /// OLD-API
                                                        return div;
                                                    };

                                                    heatmapLegendColors.addTo(map.defaultMapRef);
                                                    //    map.eventsOnMap.push(heatmap);

                                                    event.legendColors = heatmapLegendColors;
                                                    map.eventsOnMap.push(event);

                                                    if (changeRadiusOnZoom) {
                                                        $('#<?= $_REQUEST['name_w'] ?>_changeRad').prop('checked', true);
                                                        if (estimateRadiusFlag) {
                                                            $('#<?= $_REQUEST['name_w'] ?>_changeRad').prop('disabled', true);
                                                        }
                                                    }

                                                    if (estimateRadiusFlag) {
                                                        $('#<?= $_REQUEST['name_w'] ?>_estimateRad').prop('checked', true);
                                                        $('#<?= $_REQUEST['name_w'] ?>_estimateRad').prop('disabled', false);
                                                    } else {
                                                        $('#<?= $_REQUEST['name_w'] ?>_estimateRad').prop('disabled', false);
                                                    }

                                                    loadingDiv.empty();
                                                    loadingDiv.append(loadOkText);

                                                    parHeight = loadOkText.height();
                                                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                                    loadOkText.css("margin-top", parMarginTop + "px");

                                                    setTimeout(function () {
                                                        loadingDiv.css("opacity", 0);
                                                        setTimeout(function () {
                                                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                            });
                                                            loadingDiv.remove();
                                                        }, 350);
                                                    }, 1000);

                                                },
                                                error: function (errorData) {
                                                    console.log("Ko Heatmap");
                                                    console.log(JSON.stringify(errorData));
                                                    loadingDiv.empty();
                                                    loadingDiv.append(loadKoText);

                                                    parHeight = loadKoText.height();
                                                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                                    loadKoText.css("margin-top", parMarginTop + "px");

                                                    setTimeout(function () {
                                                        loadingDiv.css("opacity", 0);
                                                        setTimeout(function () {
                                                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                            });
                                                            loadingDiv.remove();
                                                        }, 350);
                                                    }, 1000);
                                                }
                                            });


                                        } else {
                                            if (animationFlag === false) {

                                                map.defaultMapRef.createPane('Snap4City:' + wmsDatasetName);    // CORTI
                                                map.defaultMapRef.getPane('Snap4City:' + wmsDatasetName).style.zIndex = 420;    // CORTI

                                                // NEW HEATMAP
                                                var timestamp = map.testMetadata.metadata.date;
                                                var timestampISO = timestamp.replace(" ", "T") + ".000Z";
                                                //    wmsLayer = L.tileLayer.wms("https://wmsserver.snap4city.org/geoserver/Snap4City/wms", {
                                                wmsLayer = L.tileLayer.wms(geoServerUrl + "geoserver/Snap4City/wms", {
                                                    layers: 'Snap4City:' + wmsDatasetName,
                                                    format: 'image/png',
                                                    crs: L.CRS.EPSG4326,
                                                    transparent: true,
                                                    opacity: current_opacity,
                                                    time: timestampISO,
                                                    //  bbox: [24.7926004025304,60.1025194986424,25.1905923952885,60.2516802986263],
                                                    tiled: true,
                                                    //  attribution: "IGN ©"
                                                    pane: 'Snap4City:' + wmsDatasetName	// CORTI
                                                }).addTo(map.defaultMapRef);

                                                // add legend to map
                                                map.legendHeatmap.addTo(map.defaultMapRef);
                                                var heatmapLegendColors = L.control({ position: 'bottomleft' });

                                                heatmapLegendColors.onAdd = function (map) {

                                                    var div = L.DomUtil.create('div', 'info legend'),
                                                        grades = ["Legend"];
                                                    //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
                                                    var legendImgPath = heatmapRange[0].iconPath;         // OLD-API
                                                    div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';    // OLD-API
                                                    return div;
                                                };

                                                heatmapLegendColors.addTo(map.defaultMapRef);
                                                map.eventsOnMap.push(heatmap);
                                                event.legendColors = heatmapLegendColors;
                                                map.eventsOnMap.push(event);

                                                loadingDiv.empty();
                                                loadingDiv.append(loadOkText);

                                                parHeight = loadOkText.height();
                                                parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                                loadOkText.css("margin-top", parMarginTop + "px");

                                                setTimeout(function () {
                                                    loadingDiv.css("opacity", 0);
                                                    setTimeout(function () {
                                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                        });
                                                        loadingDiv.remove();
                                                    }, 350);
                                                }, 1000);
                                            } else {
                                                // ANIMATION WMS HEATMAP

                                                map.defaultMapRef.createPane('Snap4City:' + wmsDatasetName);    // CORTI
                                                map.defaultMapRef.getPane('Snap4City:' + wmsDatasetName).style.zIndex = 420;    // CORTI

                                                var animationCurrentDayTimestamp = [];
                                                var animationCurrentDayFwdTimestamp = [];
                                                var animationCurrentDayBckwdTimestamp = [];
                                                var animationStringTimestamp = "";
                                                var timestamp = map.testMetadata.metadata.date;
                                                //    var timestampISO = timestamp.replace(" ", "T") + ".000Z";
                                                var day = timestamp.substring(0, 10);
                                                if (current_page == 0) {
                                                    var offsetFwd = current_page;
                                                    while (heatmapData[offsetFwd].metadata['date'].substring(0, 10) == day) {
                                                        animationCurrentDayFwdTimestamp.push(heatmapData[offsetFwd].metadata['date'].replace(" ", "T") + ".000Z");
                                                        offsetFwd++;
                                                        if (offsetFwd > numHeatmapPages() - 1) {
                                                            break;
                                                        }
                                                    }
                                                } else if (current_page == numHeatmapPages() - 1) {
                                                    var offsetBckwd = current_page - 1;
                                                    while (heatmapData[offsetBckwd].metadata['date'].substring(0, 10) == day) {
                                                        animationCurrentDayBckwdTimestamp.push(heatmapData[offsetBckwd].metadata['date'].replace(" ", "T") + ".000Z");
                                                        offsetBckwd--;
                                                        if (offsetBckwd < 0) {
                                                            break;
                                                        }
                                                    }
                                                } else {
                                                    var offsetFwd = current_page;
                                                    while (heatmapData[offsetFwd].metadata['date'].substring(0, 10) == day) {
                                                        animationCurrentDayFwdTimestamp.push(heatmapData[offsetFwd].metadata['date'].replace(" ", "T") + ".000Z");
                                                        offsetFwd++;
                                                        if (offsetFwd > numHeatmapPages() - 1) {
                                                            break;
                                                        }
                                                    }
                                                    var offsetBckwd = current_page - 1;
                                                    while (heatmapData[offsetBckwd].metadata['date'].substring(0, 10) == day) {
                                                        animationCurrentDayBckwdTimestamp.push(heatmapData[offsetBckwd].metadata['date'].replace(" ", "T") + ".000Z");
                                                        offsetBckwd--;
                                                        if (offsetBckwd < 0) {
                                                            break;
                                                        }
                                                    }
                                                }

                                                /*     if (animationCurrentDayFwdTimestamp.length == 0) {
                                                         animationCurrentDayTimestamp = animationCurrentDayBckwdTimestamp;
                                                     } else if (animationCurrentDayBckwdTimestamp.length == 0) {
                                                         animationCurrentDayTimestamp = animationCurrentDayFwdTimestamp;
                                                     } else {*/
                                                animationCurrentDayTimestamp = animationCurrentDayFwdTimestamp.reverse().concat(animationCurrentDayBckwdTimestamp);
                                                //    animationCurrentDayTimestamp = animationCurrentDayTimestamp.reverse();
                                                animationStringTimestamp = animationCurrentDayTimestamp.join(",");
                                                //  }


                                                var bboxJson = {};
                                                $.ajax({
                                                    //    url: "https://heatmap.snap4city.org/bbox.php?layer=" + map.testMetadata.metadata.mapName,
                                                    url: heatmapUrl + "bbox.php?layer=" + map.testMetadata.metadata.mapName,
                                                    type: "GET",
                                                    async: false,
                                                    dataType: 'json',
                                                    success: function (resultBbox) {
                                                        bboxJson = resultBbox;
                                                    },
                                                    error: function (errbbox) {
                                                        alert("Error in retrieving bounding box for current heatmap: " + mapName);
                                                        console.log(errbbox);
                                                    }
                                                });

                                                /*    var bboxPage = "https://wmsserver.snap4city.org/"
                                                    var bboxHtmlContent = "";
                                                    $.get("test.php", function(htmlData){
                                                        bboxHtmlContent = htmlData;
                                                    });  */

                                                /*       var args = {

                                                                // reference to your leaflet map
                                                                map: map.defaultMapRef,

                                                                // WMS endpoint
                                                                url: 'https://wmsserver.snap4city.org/geoserver/Snap4City/wms',

                                                                // time slices to create (u probably want more than 2)
                                                                times: ["2019-04-18T11:06:18.000Z", "2019-04-18T09:06:18.000Z", "2019-04-18T07:06:18.000Z", "2019-04-18T05:06:18.000Z", "2019-04-18T03:06:18.000Z", "2019-04-18T01:06:18.000Z"],

                                                                // the bounds for the entire target WMS layer
                                                                bbox: ["24.90215", "60.1615000000001", "24.98005", "60.1959"],

                                                                // how long to show each frame in the animation
                                                                timeoutMs: 300,

                                                                frames: [
                                                                    {
                                                                        "time": "2019-04-18T11:06:18.000Z",
                                                                         "img": "https://heatmap.snap4city.org/base64.php?layer="+wmsDatasetName+"&date=20190418T110618Z"
                                                                       // "img": "SUkqAAgAAAATAAABAwABAAAAJwAAAAEBAwABAAAAJwAAAAIBAwAEAAAA8gAAAAMBAwABAAAACAAAAAYBAwABAAAAAgAAABUBAwABAAAABAAAABwBAwABAAAAAQAAAD0BAwABAAAAAQAAAEIBAwABAAAAAAEAAEMBAwABAAAAAAEAAEQBBAABAAAAogEAAEUBBAABAAAAwwEAAFIBAwABAAAAAgAAAFMBAwAEAAAA+gAAAA6DDAADAAAAAgEAAIKEDAAGAAAAGgEAAK+HAwAgAAAASgEAALCHDAACAAAAigEAALGHAgAIAAAAmgEAAAAAAAAIAAgACAAIAAEAAQABAAEAg3TCSFm1Xz+4fMraslFMPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA20/G+DDnOEAug5NwBhlOQAAAAAAAAAAAAQABAAAABwAABAAAAQACAAEEAAABAAEAAAgAAAEA5hABCLGHBwAAAAYIAAABAI4jCQiwhwEAAQALCLCHAQAAAIhtdJYdpHJAAAAAQKZUWEFXR1MgODR8AHja7djRCcJAEEXRrdaeUssUNyKYD8HAohHMvnNkGhi4s8Qxfq9vowcQ59G+/iG3fTcA9G8jkNm+GwDZ7bsBEN5/6R/i2q/XsSnIbF//ENJ/HY+NQWb7+oeF+6+JaTcAUtvfxwbhou3XZO8H7esfgvrv92OTkNm+/iG3fTcAFu5/pv39B2S2r3/Ibd8NgDX6/7R9/UNu+24AXLf/M9rXP+S2vz0HyGxf//Af/fdc39590L7vfdC+//kht3/dg/Y1D8HtAxH96x7y2tc8ZPave8hr38Zglfg1D95+vUPq228ZEGRrzQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHzhDpylbKQ="
                                                                     },
                                                                     {
                                                                        "time": "2019-04-18T09:06:18.000Z",
                                                                         "img": "https://heatmap.snap4city.org/base64.php?layer="+wmsDatasetName+"&date=20190418T090618Z"
                                                                      //   "img": "SUkqAAgAAAATAAABAwABAAAAJwAAAAEBAwABAAAAJwAAAAIBAwAEAAAA8gAAAAMBAwABAAAACAAAAAYBAwABAAAAAgAAABUBAwABAAAABAAAABwBAwABAAAAAQAAAD0BAwABAAAAAQAAAEIBAwABAAAAAAEAAEMBAwABAAAAAAEAAEQBBAABAAAAogEAAEUBBAABAAAAxwEAAFIBAwABAAAAAgAAAFMBAwAEAAAA+gAAAA6DDAADAAAAAgEAAIKEDAAGAAAAGgEAAK+HAwAgAAAASgEAALCHDAACAAAAigEAALGHAgAIAAAAmgEAAAAAAAAIAAgACAAIAAEAAQABAAEAg3TCSFm1Xz+4fMraslFMPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA20/G+DDnOEAug5NwBhlOQAAAAAAAAAAAAQABAAAABwAABAAAAQACAAEEAAABAAEAAAgAAAEA5hABCLGHBwAAAAYIAAABAI4jCQiwhwEAAQALCLCHAQAAAIhtdJYdpHJAAAAAQKZUWEFXR1MgODR8AHja7dXRCcMwEERBVeueUouKu5DkJwKDHWKDrZ2Ba2DhSa2dr5ZWDYjzal//kNu+NwD0bxHIbN8bANntewNA/xaCzParf85SENR+H89aENJ/Xz+LQWb7+ofJ++/bZzm4eft9X+veAND+cKV/iOu/xrMkZLavf8ht3xsAAf3X9lkWJmu/9p91IbP9d//eAJij/1+71z9kt+8NgPv2Xwe0r3+4Vvvf3Z7153sD4NrtH3BN/xDZv+5B+5qHjPZ1D5n96x60r3nIaF/3kNm/7iG4fSCuf8tBVvsWg1ni1zz4+/UOqX+/MSDIozQPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwhycnMYt0"
                                                                     },
                                                                    {
                                                                        "time": "2019-04-18T07:06:18.000Z",
                                                                         "img": https://heatmap.snap4city.org/base64.php?layer="+wmsDatasetName+"&date=20190418T070618Z
                                                                    //    "img": "SUkqAAgAAAATAAABAwABAAAAJwAAAAEBAwABAAAAJwAAAAIBAwAEAAAA8gAAAAMBAwABAAAACAAAAAYBAwABAAAAAgAAABUBAwABAAAABAAAABwBAwABAAAAAQAAAD0BAwABAAAAAQAAAEIBAwABAAAAAAEAAEMBAwABAAAAAAEAAEQBBAABAAAAogEAAEUBBAABAAAAzwEAAFIBAwABAAAAAgAAAFMBAwAEAAAA+gAAAA6DDAADAAAAAgEAAIKEDAAGAAAAGgEAAK+HAwAgAAAASgEAALCHDAACAAAAigEAALGHAgAIAAAAmgEAAAAAAAAIAAgACAAIAAEAAQABAAEAg3TCSFm1Xz+4fMraslFMPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA20/G+DDnOEAug5NwBhlOQAAAAAAAAAAAAQABAAAABwAABAAAAQACAAEEAAABAAEAAAgAAAEA5hABCLGHBwAAAAYIAAABAI4jCQiwhwEAAQALCLCHAQAAAIhtdJYdpHJAAAAAQKZUWEFXR1MgODR8AHja7dbRDYJAEEVRqqUna9nixighJCofupLAvnNgGpjkDkzT8er5Amke7esfctuveRkbgaD+5619/UNu+24AZLfvBoD+bQgy23cDILv9avqHyP7bNjYGIe2397E1COi/7Y/NQWb7bgBcvP214x+61z8M0n/n2CQEtl/L2CZktu8GQFD/tT82C5nt6x9y23cDYMD+67uxZQhtf32A6/ZfHe3rH3LbdwPgPO2/9np09/qH8/b/6Rb8s33g/O2Xf33Qfkf7wPD96x7C2wdi2tc9ZPave8hr3wYhr3+bg6z2bQxGiV/z4Nuvd0j99lsGBLmV5gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADrcAd+SmZk="
                                                                    },
                                                                    {
                                                                        "time": "2019-04-18T05:06:18.000Z",
                                                                         "img": "https://heatmap.snap4city.org/base64.php?layer="+wmsDatasetName+"&date=20190418T050618Z"
                                                                     //   "img": "SUkqAAgAAAATAAABAwABAAAAJwAAAAEBAwABAAAAJwAAAAIBAwAEAAAA8gAAAAMBAwABAAAACAAAAAYBAwABAAAAAgAAABUBAwABAAAABAAAABwBAwABAAAAAQAAAD0BAwABAAAAAQAAAEIBAwABAAAAAAEAAEMBAwABAAAAAAEAAEQBBAABAAAAogEAAEUBBAABAAAA1AEAAFIBAwABAAAAAgAAAFMBAwAEAAAA+gAAAA6DDAADAAAAAgEAAIKEDAAGAAAAGgEAAK+HAwAgAAAASgEAALCHDAACAAAAigEAALGHAgAIAAAAmgEAAAAAAAAIAAgACAAIAAEAAQABAAEAg3TCSFm1Xz+4fMraslFMPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA20/G+DDnOEAug5NwBhlOQAAAAAAAAAAAAQABAAAABwAABAAAAQACAAEEAAABAAEAAAgAAAEA5hABCLGHBwAAAAYIAAABAI4jCQiwhwEAAQALCLCHAQAAAIhtdJYdpHJAAAAAQKZUWEFXR1MgODR8AHja7dvRCYNAEEVRq7Wn1LLFTUggSIgYRQJx3jnrNDBwd7+cpt+r5wekebSvf8ht3x0A4f3P+oe49uf3sRlo3v782b07APSvf8ht3x0A2e3rH7L7r+EOgLj2xzK2BiH9j/WxOWjc/vg+NgjN2h/7xxbhov2PY627A0D7+gftVy1jqxDSf62PzULj9mt7bBcatl/7x5ahSf91fGwZLt5+nRvbhgv2f7b71wH+p/063/au7t0BENP+5gFa9q97yGtf85DXvu4hr3/dQ177moe89nUPef3rHvLa1zz07n/XAdq+/ZqHxm7+ywFvv/9wIfXttwxIar80DwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcMIdCPB4EA=="
                                                                    },
                                                                    {
                                                                        "time": "2019-04-18T03:06:18.000Z",
                                                                         "img": "https://heatmap.snap4city.org/base64.php?layer="+wmsDatasetName+"&date=20190418T030618Z"
                                                                    //    "img": "SUkqAAgAAAATAAABAwABAAAAJwAAAAEBAwABAAAAJwAAAAIBAwAEAAAA8gAAAAMBAwABAAAACAAAAAYBAwABAAAAAgAAABUBAwABAAAABAAAABwBAwABAAAAAQAAAD0BAwABAAAAAQAAAEIBAwABAAAAAAEAAEMBAwABAAAAAAEAAEQBBAABAAAAogEAAEUBBAABAAAAwwEAAFIBAwABAAAAAgAAAFMBAwAEAAAA+gAAAA6DDAADAAAAAgEAAIKEDAAGAAAAGgEAAK+HAwAgAAAASgEAALCHDAACAAAAigEAALGHAgAIAAAAmgEAAAAAAAAIAAgACAAIAAEAAQABAAEAg3TCSFm1Xz+4fMraslFMPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA20/G+DDnOEAug5NwBhlOQAAAAAAAAAAAAQABAAAABwAABAAAAQACAAEEAAABAAEAAAgAAAEA5hABCLGHBwAAAAYIAAABAI4jCQiwhwEAAQALCLCHAQAAAIhtdJYdpHJAAAAAQKZUWEFXR1MgODR8AHja7dfBCcMwEEVBVZueVEuK2xDwJSEQG1tg6c+IbUDwVnZr49WjVQPi1LPVe9wEZLZvB4D+3Qhktm8HQHb7dgDo3w1BZvt2AAS2X5/jtmDh/uv/uDFYrP3aP24NFum/jrVvB0B2+3YAZLevfwjv3w6AnH/+XwdYsv3dB5i+/1MHmK79yw4wTftDDnDr/oce4JbtDz99G+BmC2Bg798DrNd+PzDA3O33EwPM03+/aIA52tc85LWve8jrX/eQ177mIa993UMW3/iQ+/ZrHrz9ugdvv+Zh/Xe/NA/efr1D5NsPJD38mgcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADjhBT9JH44="
                                                                    },
                                                                    {
                                                                        "time": "2019-04-18T01:06:18.000Z",
                                                                         "img": "https://heatmap.snap4city.org/base64.php?layer="+wmsDatasetName+"&date=20190418T010618Z"
                                                                      //  "img": "SUkqAAgAAAATAAABAwABAAAAJwAAAAEBAwABAAAAJwAAAAIBAwAEAAAA8gAAAAMBAwABAAAACAAAAAYBAwABAAAAAgAAABUBAwABAAAABAAAABwBAwABAAAAAQAAAD0BAwABAAAAAQAAAEIBAwABAAAAAAEAAEMBAwABAAAAAAEAAEQBBAABAAAAogEAAEUBBAABAAAAvgEAAFIBAwABAAAAAgAAAFMBAwAEAAAA+gAAAA6DDAADAAAAAgEAAIKEDAAGAAAAGgEAAK+HAwAgAAAASgEAALCHDAACAAAAigEAALGHAgAIAAAAmgEAAAAAAAAIAAgACAAIAAEAAQABAAEAg3TCSFm1Xz+4fMraslFMPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA20/G+DDnOEAug5NwBhlOQAAAAAAAAAAAAQABAAAABwAABAAAAQACAAEEAAABAAEAAAgAAAEA5hABCLGHBwAAAAYIAAABAI4jCQiwhwEAAQALCLCHAQAAAIhtdJYdpHJAAAAAQKZUWEFXR1MgODR8AHja7ddbCsJAEEXB2f8OerUjIkI+FJOY59yqpjcgnOnY2v56b70BcZ7t6x9y2/cGgP79IpDZvjcAstv3BkDw7X8PkPGf/9sAw7b/c4Dh+l80wCDxrxggt39vAOS27w2A7Pb1D5n912SBjPbrwwLjtl8zFhir/1q4wP3br5UL3LP92miB+/RfGy9w/fZrxwWu2f+e3Vd/LXCt9o/ofrrA+Y5sXv8weP+6h7z2NQ9Z7bv1kNe/7iGvfc1DVvtuPeT1r3vIa1/zkNe/7iH39msexmy/z/vuB3JuP5Bz+4EgvukBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+8QDzyKb4"
                                                                    }
                                                                     ],

                                                            // OPTIONAL - only required if you are not providing your own frames
                                                            // **See defining image request for more info**
                                                            // due to CORS restrictions, you need to define an async function to ask your proxy server to make the WMS
                                                            // GetMap request and resolve the result (as a base64 encoded string). This example is using a call to a server function called
                                                            // 'getImage' (in MeteorJS). Note that if your target WMS is CORS enabled, you can just define a direct HTTP request here instead.
                                                            proxyFunction: function(requestUrl, time, resolve, reject){

                                                                $.ajax({
                                                                    type: "GET",
                                                                    url: requestUrl,
                                                                    beforeSend: function (xhr) {
                                                                        xhr.overrideMimeType('text/plain; charset=x-user-defined');
                                                                    },
                                                                    success: function (result, textStatus, jqXHR) {
                                                                        if(result.length < 1){
                                                                            alert("The thumbnail doesn't exist");
                                                                            $("#thumbnail").attr("src", "data:image/png;base64,");
                                                                            return
                                                                        }

                                                                        var binary = "";
                                                                        var responseText = jqXHR.responseText;
                                                                        var responseTextLen = responseText.length;

                                                                        for ( i = 0; i < responseTextLen; i++ ) {
                                                                            binary += String.fromCharCode(responseText.charCodeAt(i) & 255)
                                                                        }
                                                                     //   $("#thumbnail").attr("src", "data:image/png;base64,"+btoa(binary));
                                                                        resolve({ time: time, img: btoa(binary) });
                                                                    },
                                                                    error: function(xhr, textStatus, errorThrown){
                                                                        alert("Error in getting document "+textStatus);
                                                                    }
                                                                });

                                                            },

                                                            // OPTIONAL - only required if you are not providing your own frames
                                                            // your WMS query params
                                                            params: {
                                                                BBOX: "24.90215,60.1615000000001,24.98005,60.1959",
                                                                LAYERS: "Snap4City:" + wmsDatasetName,
                                                                SRS: "EPSG:4326",
                                                                VERSION: "1.1.1",
                                                                WIDTH: 256,
                                                                HEIGHT: 256,
                                                                transparent: true,

                                                                // ncWMS params (optional)
                                                            //    abovemaxcolor: "extend",
                                                            //    belowmincolor: "extend",
                                                            //    colorscalerange: "10.839295,13.386014",
                                                            //    elevation: "-5.050000000000001",
                                                                format: "image/png",
                                                            //    logscale: false,
                                                            //    numcolorbands: "50",
                                                                opacity: current_opacity,
                                                            //    styles: "boxfill/rainbow"
                                                            }

                                                         };

                                                        LeafletWmsAnimator.initAnimation(args, function(frames){

                                                            // if you didn't provide your own frames this callback function returns the
                                                            // array of images with their respective time stamps (e.g. you can use timestamps in UI)
                                                        });  */

                                                var upEastLat = parseFloat(bboxJson['maxy']);
                                                var upEastLon = parseFloat(bboxJson['maxx']);
                                                var bottomWestLat = parseFloat(bboxJson['miny']);
                                                var bottomWestLon = parseFloat(bboxJson['minx']);
                                                //    var imageUrl = 'https://wmsserver.snap4city.org/geoserver/wms/animate?LAYERS=' + wmsDatasetName + '&aparam=time&avalues=' + animationStringTimestamp + '&format=image/gif;subtype=animated&format_options=gif_loop_continuosly:true;layout:message;gif_frames_delay:500&transparent=true';
                                                var imageUrl = geoServerUrl + 'geoserver/wms/animate?LAYERS=' + wmsDatasetName + '&aparam=time&avalues=' + animationStringTimestamp + '&format=image/gif;subtype=animated&format_options=gif_loop_continuosly:true;layout:message;gif_frames_delay:500&transparent=true';
                                                var imageBounds = [[bottomWestLat, bottomWestLon], [upEastLat, upEastLon]];
                                                var overlayOpacity = current_opacity;

                                                // ANIMATED GIF LAYER
                                                var animatedLayer = L.imageOverlay(imageUrl, imageBounds, { opacity: overlayOpacity, pane: 'Snap4City:' + wmsDatasetName }).addTo(map.defaultMapRef);

                                                // add legend to map
                                                map.legendHeatmap.addTo(map.defaultMapRef);
                                                //    $("<?= $_REQUEST['name_w'] ?>_animation").prop("checked",true);
                                                document.getElementById("<?= $_REQUEST['name_w'] ?>_animation").checked = true;
                                                //     $("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").slider({ disabled: "true" });
                                                $("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").slider('disable');
                                                //     document.getElementById("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").slider({ disabled: "true" });
                                                //     document.getElementById("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").slider({ disabled: "true" });
                                                map.eventsOnMap.push(animatedLayer);
                                                var mapControlsContainer = document.getElementsByClassName("leaflet-control")[0];

                                                var heatmapLegendColors = L.control({ position: 'bottomleft' });

                                                heatmapLegendColors.onAdd = function (map) {

                                                    var div = L.DomUtil.create('div', 'info legend'),
                                                        grades = ["Legend"];
                                                    //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
                                                    var legendImgPath = heatmapRange[0].iconPath; // OLD-API
                                                    div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';    /// OLD-API
                                                    return div;
                                                };

                                                heatmapLegendColors.addTo(map.defaultMapRef);
                                                //  map.eventsOnMap.push(heatmap);

                                                event.legendColors = heatmapLegendColors;
                                                map.eventsOnMap.push(event);

                                                loadingDiv.empty();
                                                loadingDiv.append(loadOkText);

                                                parHeight = loadOkText.height();
                                                parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                                loadOkText.css("margin-top", parMarginTop + "px");

                                                setTimeout(function () {
                                                    loadingDiv.css("opacity", 0);
                                                    setTimeout(function () {
                                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                        });
                                                        loadingDiv.remove();
                                                    }, 350);
                                                }, 1000);
                                            }
                                        }

                                    } else {
                                        console.log("Ko Heatmap");
                                        console.log(JSON.stringify(errorData));

                                        loadingDiv.empty();
                                        loadingDiv.append(loadKoText);

                                        parHeight = loadKoText.height();
                                        parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                        loadKoText.css("margin-top", parMarginTop + "px");

                                        setTimeout(function () {
                                            loadingDiv.css("opacity", 0);
                                            setTimeout(function () {
                                                loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                    $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                });
                                                loadingDiv.remove();
                                            }, 350);
                                        }, 1000);

                                    }
                                } catch (err) {
                                    loadingDiv.empty();
                                    loadingDiv.append(loadKoText);

                                    parHeight = loadKoText.height();
                                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                    loadKoText.css("margin-top", parMarginTop + "px");
                                    console.log("Error: " + err);
                                    setTimeout(function () {
                                        loadingDiv.css("opacity", 0);
                                        setTimeout(function () {
                                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                            });
                                            loadingDiv.remove();
                                        }, 350);
                                    }, 1000);
                                }
                            },
                            error: function (errorData) {
                                console.log("Ko Heatmap");
                                console.log(JSON.stringify(errorData));

                                loadingDiv.empty();
                                loadingDiv.append(loadKoText);

                                parHeight = loadKoText.height();
                                parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                loadKoText.css("margin-top", parMarginTop + "px");

                                setTimeout(function () {
                                    loadingDiv.css("opacity", 0);
                                    setTimeout(function () {
                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                        });
                                        loadingDiv.remove();
                                    }, 350);
                                }, 1000);

                            }
                        });
                    },
                    error: function (errorData) {
                        console.log("Ko Heatmap");
                        console.log(JSON.stringify(errorData));
                    }
                });

            }

            if (addMode === 'additive') {
                //   if (event.animationFlag === true) {
                //       addHeatmapToMap(true);
                //   } else {
                addHeatmapToMap();
                //   }
            }
            if (addMode === 'exclusive') {
                map.defaultMapRef.eachLayer(function (layer) {
                    map.defaultMapRef.removeLayer(layer);
                });
                map.eventsOnMap.length = 0;

                //Remove WidgetAlarm active pins
                $.event.trigger({
                    type: "removeAlarmPin",
                });
                //Remove WidgetEvacuationPlans active pins
                $.event.trigger({
                    type: "removeEvacuationPlanPin",
                });
                //Remove WidgetEvents active pins
                $.event.trigger({
                    type: "removeEventFIPin",
                });
                //Remove WidgetResources active pins
                $.event.trigger({
                    type: "removeResourcePin",
                });
                //Remove WidgetOperatorEvents active pins
                $.event.trigger({
                    type: "removeOperatorEventPin",
                });
                //Remove WidgetTrafficEvents active pins
                $.event.trigger({
                    type: "removeTrafficEventPin",
                });
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                    maxZoom: leafletMaxZoom,
                    maxNativeZoom: leafletNativeMaxZoom
                }).addTo(map.defaultMapRef);

                addHeatmapToMap();
            }
        }
    });


    //dBologna INIZIO VECTOR FLOW
    $(document).on('resetVectorFlow', function(event){
                let allCanvases = document.getElementsByTagName('canvas');
                    while (allCanvases.length > 0) {
                        allCanvases[0].remove(); 
                    }
                    flowField = null;
    });


    $(document).on('addVectorFlow', function(event){
    var token;
    let nameVectorField= event.passedData.name;
    $.ajax({
        url: "../controllers/getAccessToken.php",
        type: "GET",
        dataType: 'json',
        success: function(dataSso) {
            token = dataSso.accessToken;
            const metadataUrl= "<?= $superServiceMapProxy ?>api/v1/?serviceUri=" + event.passedData.query + "&format=json&accessToken="+token;
            $.ajax({
                url: metadataUrl,
                method: "GET",
                dataType: 'json',
                success: function(data1) {
                    const results = data1.realtime.results.bindings[0];
                    const localCoordinates= data1.Service.features[0];
                    const outputData = {
                        //latitude: event.passedData.coordinates[0],
                        //longitude: event.passedData.coordinates[1],
                        latitude: localCoordinates.geometry.coordinates[1],
                        longitude: localCoordinates.geometry.coordinates[0],
                        nPointsLatitude: parseInt(results.nPointsLatitude.value),
                        nPointsLongitude: parseInt(results.nPointsLongitude.value),
                        stepLat: parseInt(results.stepLat.value),
                        stepLong: parseInt(results.stepLong.value),
                        //vectorLength: JSON.parse(results.vectorLength.value),
                        vectorLength: results.vectorLength ? JSON.parse(results.vectorLength.value) : '',
                        //angle: JSON.parse(results.angle.value),
                        angle: results.angle ? JSON.parse(results.angle.value) : '',
                        description: results.vectorDescription.value,
                        scaleFactor: parseFloat(results.scaleFactor.value),
                        legenda: results.legenda.value
                    };
                    console.log(outputData);
                    try{
                        initializeP5(outputData);
                    }catch(e){
                        console.error(e);
                    }
                    
                    
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    alert("Errore nella richiesta: " + textStatus);
                }
            });
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error("Errore nel recupero del token: " + textStatus, errorThrown);
        }
    });

    let flowField;

    function initializeP5(data){
        //console.log('initializeP5');
    

    // Definisco l'istanza p5.js
    new p5(function(p) {
        //
        // Funzione di setup per p5
        p.setup = function() {
           // console.log('OK');
           //
           removeAllCanvas();
           // Otteniamo la posizione del div contenente la mappa
           //
           let mapContainer = document.getElementById('<?= $_REQUEST['name_w'] ?>_map');
            let rect = mapContainer.getBoundingClientRect();

            // Ottieni la posizione e le dimensioni dell'elemento rispetto alla finestra del browser
            let width = rect.width;         // Larghezza del div
            let height = rect.height;       // Altezza del div
            let top = rect.top;             // Distanza dall'angolo superiore del browser
            let left = rect.left;           // Distanza dal lato sinistro del browser
            let right = rect.right;         // Distanza dal lato destro del browser
            let bottom = rect.bottom;       // Distanza dal lato inferiore del browser
           //
           let zoom = map.defaultMapRef.getZoom();
           map.defaultMapRef.setView([data.latitude, data.longitude], zoom);
           let mapWidth = mapContainer.offsetWidth;
           let mapHeight = mapContainer.offsetHeight;
           
           //let canvas = p.createCanvas(mapWidth, mapHeight);
           let canvas = p.createCanvas(rect.width, rect.height);

           //canvas.position(mapContainer.offsetLeft, mapContainer.offsetTop);
           canvas.position(rect.left, rect.top);
           //
           let bottomLeftPoint = map.defaultMapRef.latLngToLayerPoint([data.latitude, data.longitude]);
            p.clear();

            // Aggiunge un listener per ridisegnare il canvas quando la mappa si muove o viene fatto zoom
            map.defaultMapRef.on('zoom move', () => {
                p.redraw();  // Redraw ripete il ciclo di draw quando la mappa cambia
            });

            // Disabilita il loop automatico di p5.js, dato che vogliamo ridisegnare solo su richiesta
            //p.noLoop();
            initializeFlowField(data);
        };

        // Funzione di draw per p5.js
        p.draw = function() {
            p.clear();  // Rimuove il disegno precedente

            if (flowField) {
                flowField.display();
            } else {
                console.log('No flowField');
            }
        };
    

        p.initializeMap = function(data) {
            initializeFlowField(data);
        };

    function adjustAngleForLatitude(angle) {
            let latitudeReference = Math.PI / 2; 
            return angle - latitudeReference;
     }

     function degreesToRadians(degrees) {
            return degrees * (Math.PI / 180);
        }



    function initializeFlowField(data) {
        //
        let zoom = map.defaultMapRef.getZoom();
        //
        let bottomLeftPoint = map.defaultMapRef.latLngToLayerPoint([data.latitude, data.longitude]);
        let totalVectors = data.nPointsLatitude*data.nPointsLongitude;
        let cols = data.nPointsLatitude;
        let rows = data.nPointsLongitude;
        //

        //

        if (cols > 0 && rows > 0) {
            //
            var vectorLength = data.vectorLength;
            var angle = data.angle;
            if((vectorLength == '')&&(angle =='')){
                console.log(nameVectorField);
                /////////////
                var url = "<?= $endprocessloader; ?>" + `getOneSpecific.php?suri=${nameVectorField}&accessToken=${token}`;
                //var url = `http://dashboard/processloader/api/bigdatafordevice/getOneSpecific.php?suri=${nameVectorField}&accessToken=${token}`;
                $.ajax({
                    type: 'GET',
                    url: url,
                    dataType: "json",
                    data: { 'accessToken': token },
                    contentType: 'application/json; charset=utf-8',
                    headers: { 'Authorization': `Bearer ${token}` },
                    async: false,
                    success: function (data) {
                        console.log('Load DATA',data);
                        const json = JSON.parse(data[0].data);
                        if( JSON.parse(data[0].data).grandidati !== undefined){
                            var grandidati = JSON.parse(data[0].data).grandidati;
                            vectorLength = JSON.parse(grandidati).magnitude;
                            angle =JSON.parse(grandidati).angle;
                        
                        }else{
                            vectorLength = JSON.parse(json.magnitude);
                            angle = JSON.parse(json.angle);
                        }
                       
                        
                    }
                });
                ////////////
            }
            //
            flowField = new FlowField(cols, rows, [data.latitude, data.longitude], angle, vectorLength, data.stepLat, data.stepLong, data.scaleFactor, data.description, data.legenda);
        }
    }

    function removeAllCanvas() {
        const canvases = document.querySelectorAll('canvas');
        canvases.forEach((canvas) => {
            canvas.parentNode.removeChild(canvas);
        });
    }

        

        function getLatLngAfterDistance(latA, lonA, distance, angle) {
            // Raggio della Terra in km
             const R = 6372.795477598;
            // Convertire latitudine e longitudine iniziale in radianti
            let latA_rad = p.radians(latA);
            let lonA_rad = p.radians(lonA);
            
            // Calcolo della nuova latitudine latB
            let latB_rad = Math.asin(
                Math.sin(latA_rad) * Math.cos(distance / R) +
                Math.cos(latA_rad) * Math.sin(distance / R) * Math.cos(angle)
            );
            
            // Calcolo della nuova longitudine lonB
            let lonB_rad = lonA_rad + Math.atan2(
                Math.sin(angle) * Math.sin(distance / R) * Math.cos(latA_rad),
                Math.cos(distance / R) - Math.sin(latA_rad) * Math.sin(latB_rad)
            );
            
            // Convertire i risultati da radianti a gradi
            let latB = p.degrees(latB_rad);
            let lonB = p.degrees(lonB_rad);

            return { latB, lonB };
        }


    class FlowField {
        constructor(cols, rows, baseLatLng, angleMatrix, magnitudeMatrix, stepLat, stepLong, scaleFactor, description, legenda) {
            this.cols = cols;
            this.rows = rows;
            this.baseLatLng = baseLatLng;
            this.field = new Array(this.cols);
            if (typeof angleMatrix === 'string') {
                this.angleMatrix = JSON.parse(angleMatrix);
            }else{
                this.angleMatrix = angleMatrix;
            }
            if (typeof magnitudeMatrix === 'string') {
                this.magnitudeMatrix = JSON.parse(magnitudeMatrix);
            }else{
                this.magnitudeMatrix = magnitudeMatrix;
            }
            //this.magnitudeMatrix = JSON.parse(magnitudeMatrix);
            this.stepLong = stepLong;
            this.stepLat = stepLat;
            this.scaleFactor = scaleFactor;
            this.description = description;
            this.legenda = legenda;
            console.log('magnitudeMatrix',this.magnitudeMatrix);
            console.log('angleMatrix',this.angleMatrix);
               /*let adjustedAngleMatrix = this.angleMatrix.map(row =>
                    row.map(angle => adjustAngleForLatitude(degreesToRadians(angle)))
                );
            this.angleMatrix = adjustedAngleMatrix;
           console.log(this.angleMatrix);*/
           // Trova i valori massimo e minimo di magnitude
        this.maxMagnitude = -Infinity;
        this.minMagnitude = Infinity;

            for (let i = 0; i < this.cols; i++) {
                this.field[i] = new Array(this.rows);
                for (let j = 0; j < this.rows; j++) {
                    let angle = this.angleMatrix[i][j];
                    let magnitude = this.magnitudeMatrix[i][j];
                    // Trova i valori massimo e minimo di magnitude
                    this.maxMagnitude = Math.max(this.maxMagnitude, magnitude);
                    this.minMagnitude = Math.min(this.minMagnitude, magnitude);
                    //
            // Usa la funzione per calcolare la nuova posizione in base all'angolo e distanza
                    let newLatLng = getLatLngAfterDistance(
                                this.baseLatLng[0] + i * this.stepLat / 111320,  // Latitudine corrente
                                this.baseLatLng[1] + j * this.stepLong / 111320, // Longitudine corrente
                                magnitude,  // Distanza
                                angle       // Angolo in radianti
                            );
                    //
                    this.field[i][j] = p.createVector(newLatLng.latB, newLatLng.lonB);
                    //this.field[i][j] = p.createVector(p.cos(angle), p.sin(angle));
                    this.isHovered = false;
                    this.hoverPosition = null;
                }
            }
        }

        //14_ottobre
        // Funzione per calcolare il passo del campionamento basato sul livello di zoom
            calculateSamplingStep(zoomLevel) {
                if (zoomLevel > 18) return 1;
                if (zoomLevel > 17) return 1;   // Zoom alto, più dettagli (passo piccolo)
                if (zoomLevel > 15) return 4; 
                if (zoomLevel > 13) return 8; 
                if (zoomLevel > 12) return 16; 
                if (zoomLevel > 11) return 32;
                if (zoomLevel > 10) return 64;
                if (zoomLevel > 9) return 128;  // Zoom medio, media dettagli (passo medio)
                return 256;                      // Zoom basso, meno dettagli (passo grande)
            }

            // Funzione per calcolare un vettore medio per un gruppo di celle
            calculateAveragedVector(i, j, step) {
                    let sumX = 0;
                    let sumY = 0;
                    let count = 0;

                    for (let x = i; x < i + step && x < this.cols; x++) {
                        for (let y = j; y < j + step && y < this.rows; y++) {
                            let v = this.field[x][y];
                            sumX += v.x;
                            sumY += v.y;
                            count++;
                        }
                    }
                    return p.createVector(sumX / count, sumY / count);
            }

                // Funzione per calcolare una magnitudine media per un gruppo di celle
            calculateAveragedMagnitude(i, j, step) {
                    let sum = 0;
                    let count = 0;

                    for (let x = i; x < i + step && x < this.cols; x++) {
                        for (let y = j; y < j + step && y < this.rows; y++) {
                            sum += this.magnitudeMatrix[x][y];
                            count++;
                        }
                    }
                    return sum / count;
            }    
            
            // Funzione per mostrare le informazioni di hover
                    showHoverInfo(scaledX, scaledY, magnitude) {
                        let hoverText = `Value: ${magnitude}`;
                        let hoverBoxWidth = p.textWidth(hoverText) + 20;
                        let hoverBoxHeight = 30;

                        // Disegna il riquadro di hover
                        p.fill(255);
                        p.stroke(0);
                        p.strokeWeight(1);
                        p.rect(scaledX + 10, scaledY - hoverBoxHeight - 10, hoverBoxWidth, hoverBoxHeight, 5);

                        // Disegna il testo di hover
                        p.fill(0);
                        p.textSize(14);
                        p.text(hoverText, scaledX + 15, scaledY - hoverBoxHeight + 5);
                    }
        //fine 14_ottobre


        display() {
            //
                    let legendWidth = 200; // Larghezza del riquadro
                    let legendHeight = 50; // Altezza del riquadro
                    let legendText1 = ` ${this.description}`;
                    let legendText2 = ` ${this.legenda}`;
                    let arrayLegend;
                    let arrayLegendSize = []; 
                    let zoomLevel = map.defaultMapRef.getZoom(); // Ottieni il livello di zoom
                    let samplingStep = this.calculateSamplingStep(zoomLevel); // Calcola il passo del campionamento
                    let hoverInfo = [];
                    //
                    var finalPointA = 0;
                    var finalPointB = 0;
                    //        
           for (let i = 0; i < this.cols; i += samplingStep) {
                for (let j = 0; j < this.rows; j += samplingStep) {
                    this.field[i][j].isHovered = false;
                    this.field[i][j].hoverPosition = null;

                    let latLng = this.getLatLngForCell(i, j);
                    if (this.isPointInView(latLng)) {
                        let mapPoint = map.defaultMapRef.latLngToContainerPoint(latLng);
                        let scaledX = mapPoint.x;
                        let scaledY = mapPoint.y;
                        let v = this.calculateAveragedVector(i, j, samplingStep);
                        let magnitude = this.calculateAveragedMagnitude(i, j, samplingStep);
                        let maxArrowLength = magnitude;
                        let zoomScale = p.map(zoomLevel, 5, 22, 0.2, 1); // Scala basata sullo zoom (valori adattabili)
                        let scaledArrowLength = p.constrain(magnitude * zoomScale, 0, maxArrowLength); // Limita la lunghezza massima

                            this.drawArrow(p.createVector(scaledX, scaledY), v, scaledArrowLength, this.scaleFactor);

                            let d = p.dist(p.mouseX, p.mouseY, scaledX, scaledY);
                            if (d < 10) {
                                hoverInfo.push({ x: scaledX, y: scaledY, magnitude: magnitude });
                            }
                            //
                        let latLngA = this.getLatLngForCell(v.y, v.x);  // Il punto A (origine del vettore)
                        let latLngB = this.getLatLngForCell(v.y + 1, v.x + 1);  // Punto B per calcolare la direzione
                        // Converte le coordinate LatLng in punti sulla mappa (in pixel)
                        finalPointA = map.defaultMapRef.latLngToContainerPoint(latLngA);
                        finalPointB = map.defaultMapRef.latLngToContainerPoint(latLngB);
                            
                        }

                    }
            }

            if (legendText2 && legendText2.trim() !== "") {
                      
                      arrayLegend = JSON.parse(legendText2);  // Converti in JSON
                          //console.log(arrayLegend); 
                          for (let y = 0; y < arrayLegend.length; y++) {  
                              legendText2 = legendText2 + arrayLegend[y];
                          }        
                  }     
                  //
                  //let legendBoxWidth = Math.max(p.textWidth(legendText1), p.textWidth(legendText2)) + 20; // Aggiungi margine di 20px
                  let legendBoxWidth = legendWidth;
                  let legendBoxHeight = 30+(arrayLegend.length)*30;
                  ///
                  let legendX = 20; // Posizione orizzontale del riquadro (angolo in basso a sinistra)
                  let legendY = p.height - legendBoxHeight - 20; // Posizione verticale del riquadro
                    // Disegna il riquadro bianco per la legenda
                    p.fill(255); // Riempimento bianco
                    p.stroke(0); // Bordo nero
                    p.strokeWeight(1);
                    p.rect(legendX -5, legendY -10, legendBoxWidth, legendBoxHeight, 5); // Riquadro con angoli arrotondati
                    p.fill(0); // Colore del testo
                    p.textSize(12);
                    p.text(legendText1, legendX + 10, legendY + 10);
                    //
                    // Calcola la distanza in pixel tra i due punti
                    
                        //
                        
                    //
                    //p.text(legendText2, legendX + 10, legendY + 30);
                    var rapporto = this.calculateSamplingStep(zoomLevel);
                    p.text('Scaled 1:'+rapporto, legendX + 10, legendY + 30);
                    var count = 50;
                    if (legendText2 && legendText2.trim() !== "") {
                    for (let y = 0; y < arrayLegend.length; y++) {  
                                p.text(arrayLegend[y], legendX + 10, legendY + count);
                                let distanceInPixels = p.dist(finalPointA.x, finalPointA.y, finalPointB.x, finalPointB.y);
                                let maxArrowLength = distanceInPixels * 0.7;
                                let normalizedMagnitude = p.map(arrayLegend[y], this.minMagnitude, this.maxMagnitude, 5, maxArrowLength);
                                ////////////
                                // Disegna una freccia accanto al legendText2
                                let arrowX = legendX + p.textWidth(arrayLegend[y]) + 20; // Posiziona la freccia accanto al testo
                                let arrowY = legendY + count; // Allineamento verticale della freccia
                                let arrowSize = parseFloat(arrayLegend[y]); // Dimensione della freccia
                                if(arrowSize == NaN){
                                    arrowSize = 0;
                                }
                                //let maxArrowLength = arrowSize * 0.7; 
                                //let scaledArrowLengthLegend = p.constrain(arrowSize * rapporto, 0, maxArrowLength);
                                let scaledArrowLengthLegend = p.map(arrowSize, 0, this.maxMagnitude, 2, 20);
                                let arrowHeadSize = scaledArrowLengthLegend * 0.3
                                p.stroke(0); // Colore della freccia
                                p.strokeWeight(2);
                                //console.log('legendText2    '+legendText2);
                                if(arrayLegend[y] == 0){
                                    p.strokeWeight(3);
                                    p.line(arrowX, arrowY, arrowX, arrowY);
                                }else{
                                     p.line(arrowX, arrowY, arrowX + normalizedMagnitude, arrowY);
                                    p.fill(0); // Riempimento nero per la punta
                                    p.triangle(
                                        arrowX + normalizedMagnitude, arrowY - 2,
                                        arrowX + normalizedMagnitude, arrowY + 2,
                                        arrowX + normalizedMagnitude + 5, arrowY
                                    );
                                }
                                
                                count = count+20;
                            }            
                    }else{
                            p.text(legendText2, legendX + 10, legendY + 30);
                    }
                //
                //
                //

            for (let i = 0; i < hoverInfo.length; i++) {
                this.showHoverInfo(hoverInfo[i].x, hoverInfo[i].y, hoverInfo[i].magnitude);
            }

            }




            getLatLngForCell(col, row) {
                // Calcola la distanza dalla base (in basso a sinistra) in termini di coordinate geografiche
                let latLngOffset = [
                    row * this.stepLong / 111320,  // 1 grado di latitudine è circa 111.32 km
                    col * this.stepLat / (111320 * Math.cos(p.radians(this.baseLatLng[0])))
                    //col * this.stepLat / (111320 * Math.cos((this.baseLatLng[0])))  // Corregge la longitudine per la latitudine
                ];

                // Ritorna la nuova LatLng per la cella
                return [
                    this.baseLatLng[0] + latLngOffset[0],  // Aggiunge la latitudine offset
                    this.baseLatLng[1] + latLngOffset[1]   // Aggiunge la longitudine offset
                ];
            }

            drawArrow(base, vec, magnitude, scaleFactor) {
                
                //
                // Calcola la distanza in pixel tra due punti usando le coordinate sulla mappa
                        let latLngA = this.getLatLngForCell(vec.y, vec.x);  // Il punto A (origine del vettore)
                        let latLngB = this.getLatLngForCell(vec.y + 1, vec.x + 1);  // Punto B per calcolare la direzione
                        // Converte le coordinate LatLng in punti sulla mappa (in pixel)
                        let pointA = map.defaultMapRef.latLngToContainerPoint(latLngA);
                        let pointB = map.defaultMapRef.latLngToContainerPoint(latLngB);
                    
                    // Calcola la distanza in pixel tra i due punti
                    let distanceInPixels = p.dist(pointA.x, pointA.y, pointB.x, pointB.y);
                    let maxArrowLength = distanceInPixels * 0.7;
                //
                let zoomLevel = map.defaultMapRef.getZoom();  // Ottieni il livello di zoom
                //let maxZoom = 23;  // Imposta un livello di zoom massimo, ad esempio 18
                //let minZoom = 5;   // Imposta un livello di zoom minimo, ad esempio 5
                //let normalizedMagnitude = p.map(magnitude, 0, this.maxMagnitude, 2, 20);  // Scala tra 5 e 70 pixel
                let normalizedMagnitude = p.map(magnitude, this.minMagnitude, this.maxMagnitude, 5, maxArrowLength);
                // Scala la lunghezza della freccia in base allo zoom
                let zoomScale = p.map(zoomLevel, this.minZoom, this.maxZoom, 0.2, 1);  // Valore tra 0.2 e 1
                //let maxArrowLength = magnitude * 0.7;
                //let scaledLength = magnitude * scaleFactor * zoomScale;
                //let scaledLength = normalizedMagnitude * scaleFactor * zoomScale;
                let scaledLength = Math.min(normalizedMagnitude, maxArrowLength);
                //scaledLength *= zoomScale;
                 let arrowSize = 3 * scaleFactor;
                //let arrowSize = normalizedMagnitude * 0.2;

                //scaledLength = Math.min(scaledLength, maxArrowLength);
                //
                // Normalizza la lunghezza della freccia in base ai valori di magnitude
                if (scaledLength == NaN){
                    scaledLength = 0;
                }
                //
                //
                p.push();
                p.stroke(0);
                p.strokeWeight(2);
                p.fill(0);
                p.translate(base.x, base.y);
                p.rotate(vec.heading());
                
                //
                if(magnitude > 0){
                    p.line(0, 0, normalizedMagnitude, 0);
                    p.translate(normalizedMagnitude, 0);
                //p.triangle(0, normalizedMagnitude  / 3, 0, -normalizedMagnitude  / 3, normalizedMagnitude , 0);
                    p.triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
                }else{
                    p.strokeWeight(3);
                    p.line(1, 1, 1, 1);
                }
                //
                p.pop();
            }



            // Funzione che controlla se un punto è visibile nella mappa
            isPointInView(latLng) {
                let bounds = map.defaultMapRef.getBounds();
                return bounds.contains(L.latLng(latLng[0], latLng[1]));
            }


        // Le altre funzioni della classe FlowField
    }
});
};
/////////FUNZIONE AGGIUNGI RIQUADRO PER LO SCRORRIMENTO DEL TEMPO.///////

//////////////////////////
});
        //////////
    
    //dBologna FINE VECTOR FLOW

    
    $(document).on('addOD', function (event) {
        if (event.target === map.mapName) {

            if (newOdTargetData != null) {
                $(document).off('newOdTargetData', newOdTargetData);
            }
            if (newOdSourceData != null) {
                $(document).off('newOdSourceData', newOdSourceData);
            }
            if (odmapClick != null) {
                map.defaultMapRef.off('click', odmapClick);
            }
            if (showAllPolyOdMapZoomend != null) {
                map.defaultMapRef.off('zoomend', showAllPolyOdMapZoomend);
            }
            if (showAllPolyOdMapMoveend != null) {
                map.defaultMapRef.off('moveend', showAllPolyOdMapMoveend);
            }
            if (newOdDateTimeFunc != null) {
                map.defaultMapRef.off('newOdDatetime', newOdDateTimeFunc);
                newOdDateTimeFunc = null;
                jQuery(document).off("newOdDatetime");
            }


            odOnMap = true;
            var passedData = event.passedData.split("get?");
            var odUrl = passedData[0];
            var parameters = passedData[1].split("&");

            var latitude = "";
            var longitude = "";
            var precision = "";
            var organization = "";
            var inflow = "";
            var odID = "";
            var getPerc = "True";
            var statID = "";
            var allPoly = "False";
            var panelOnShape = false;
            var colorMapName = "ODcolormap1";
            var sourcePolyColor = "#0000FF";
            var opacity = "0.6";
            var allPolyColor = "#bf2015";
            var panelBackgroundColor = "#cccccc";
            var panelFontColor = "#505050";
            var panelWidth = "340px";
            var panelFontSize = "12px";
            var dataPanelWidth = "240px";
            var dataPanelFontSize = "12px";
            var popupPanelWidth = "300";
            var popupPanelFontSize = "12px"
            var cmFontSize = "12px";
            mapName = "Origin-Destination Map";

            for (n = 0; n < parameters.length; n++) {
                if (parameters[n].split("=")[0] == "latitude") {
                    latitude = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "longitude") {
                    longitude = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "precision") {
                    precision = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "organization") {
                    organization = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "inflow") {
                    inflow = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "od_id") {
                    odID = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "perc") {
                    getPerc = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "stat_id") {
                    statID = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "all_polygon") {
                    allPoly = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "panel_on_shape") {
                    panelOnShape = parameters[n].split("=")[1];
                    panelOnShape = ((panelOnShape == "False") ? false : true)
                } else if (parameters[n].split("=")[0] == "color_map") {
                    colorMapName = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "source_polygon_color") {
                    sourcePolyColor = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "opacity") {
                    opacity = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "all_polygon_color") {
                    allPolyColor = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "panel_bg_color") {
                    panelBackgroundColor = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "panel_font_color") {
                    panelFontColor = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "map_name") {
                    mapName = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "panel_width") {
                    panelWidth = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "panel_font_size") {
                    panelFontSize = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "data_panel_width") {
                    dataPanelWidth = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "data_panel_font_size") {
                    dataPanelFontSize = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "popup_panel_width") {
                    popupPanelWidth = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "popup_panel_font_size") {
                    popupPanelFontSize = parameters[n].split("=")[1];
                } else if (parameters[n].split("=")[0] == "cm_font_size") {
                    cmFontSize = parameters[n].split("=")[1];
                }
            }

            var sourcePolyID = null; //[];
            var targetPolyID = null; //[];
            var sourcePolyName = null; //[];
            var newDateTimeSet = null;

            var dates = null; //[];
            var colors = null; //[];
            var animationPeriod = "week";
            var animationCounter = 0;
            var shapeTypes = null; //[];
            var showAllPolygonFlag = ((allPoly === "False") ? false : true);
            var legendColorObserver = null;
            //mapName = "Origin-Destination Map";

            //Crea un layer per la OD (i dati gli verranno passati nell'evento)
            //OD configuration
            function getOdColorLegend() {

                var colorScale = {};

                $.ajax({
                    url: odUrl + "color?metric_name=" + colorMapName,
                    type: "GET",
                    async: false,
                    dataType: 'json',
                    success: function (dataColorScale) {
                        colorScale = dataColorScale;
                    },
                    error: function (err) {
                        alert("Error in retrieving color map scale: " + colorMapName + ".\nCheck the console log for more info.");
                        console.log(err);
                    }
                });
                if (typeof colorScale === "string") {
                    alert("Error in retrieving color map scale: " + colorMapName + ".\nCheck the console log for more info.");
                    console.log("Error in retrieving color map scale: \n" + colorScale);
                    colorScale = {};
                }
                return colorScale;
            }

            if (!map.legendOd) {
                map.legendOd = L.control({ position: 'topright' });
            }

            if (!map.flowInfo) {
                map.flowInfo = L.control({ position: 'topright' });
            }

            function changeOdPage(page) {
                var btn_next = document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt");
                var btn_prev = document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt");

                // Validate page
                if (dates.length > 0) {
                    if (page < 0) page = 0;
                    if (page > (dates.length - 1)) page = (dates.length - 1);

                    if (current_page == 0) {
                        btn_prev.style.visibility = "hidden";
                    } else {
                        btn_prev.style.visibility = "visible";
                    }

                    if (current_page == dates.length - 1) {
                        btn_next.style.visibility = "hidden";
                    } else {
                        btn_next.style.visibility = "visible";
                    }
                }
            }

            function setOption(option, value, decimals) {
                if (option == "maxOpacity") {
                    if (geojson_layer || sourcePolygon) {
                        current_opacity_od = value;
                        if (decimals) {
                            $("#<?= $_REQUEST['name_w'] ?>_range" + option).text(parseFloat(current_opacity_od).toFixed(parseInt(decimals)));
                            $("#<?= $_REQUEST['name_w'] ?>_slider" + option).attr("value", parseFloat(current_opacity_od).toFixed(parseInt(decimals)));
                            if (geojson_layer) {
                                geojson_layer.setStyle({ fillOpacity: current_opacity_od });
                            }
                            if (sourcePolygon) {
                                sourcePolygon.setStyle({ fillOpacity: current_opacity_od });
                            }
                        }
                    }



                }
            }

            function removeOd(resetPageFlag) {
                if (resetPageFlag == true) {
                    current_page = 0;
                }
                if (geojson_layer !== null) {
                    map.defaultMapRef.removeLayer(geojson_layer);
                }
                // if (geojson_layer_all !== null) {
                //     map.defaultMapRef.removeLayer(geojson_layer_all);
                // }
                if (sourcePolygon !== null) {
                    map.defaultMapRef.removeLayer(sourcePolygon);
                }
                map.defaultMapRef.removeControl(map.legendOd);
                map.defaultMapRef.removeControl(map.flowInfo);
            }

            function removeOdColorLegend(index, resetPageFlag) {
                if (resetPageFlag == true) {
                    current_page = 0;
                }
                map.defaultMapRef.removeControl(map.eventsOnMap[index].legendColors);
            }



            map.legendOd.onAdd = function () {
                map.legendOdDiv = L.DomUtil.create('div');
                map.legendOdDiv.id = "odLegend";
                // disable interaction of this div with map
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(map.legendOdDiv);
                    L.DomEvent.on(map.legendOdDiv, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(map.legendOdDiv, 'click', L.DomEvent.stopPropagation);
                }
                map.legendOdDiv.style.width = panelWidth; //"340px";
                map.legendOdDiv.style.fontWeight = "bold";
                map.legendOdDiv.style.background = panelBackgroundColor; //"#cccccc";
                map.legendOdDiv.style.padding = "10px";
                map.legendOdDiv.style.color = panelFontColor;
                map.legendOdDiv.style.fontSize = panelFontSize;

                //map.legendOdDiv.innerHTML += '<div class="textTitle" style="text-align:center">' + mapName + '</div>';
                map.legendOdDiv.innerHTML += '<div class="textTitle" style="text-align:center">' + mapName.replaceAll('_', ' ') + '</div>';
                map.legendOdDiv.innerHTML += '<div id="<?= $_REQUEST['name_w'] ?>_controlsContainer" style="height:20px"><div class="text"  style="width:50%; float:left; text-decoration: underline;">Controls:</div>';

                // SHOW ALL POLYGONS (NOT YET IMPLEMENTED FOR COMMUNES AND MSGR!!!)
                if (precision == 'poi' || precision == 'ace' || precision == 'municipality' || precision == 'province' || precision == 'region' || precision == 'communes') {
                    if (showAllPolygonFlag === false) {
                        map.legendOdDiv.innerHTML += '' +
                            '<div class="text" style="width:50%; float:right">' +
                            '<label class="switch">' +
                            '<input type="checkbox" id="<?= $_REQUEST['name_w'] ?>_show_all">' +
                            '<div class="slider round" id="slider_poly" style="background-color:#DBDBDB">' +
                            //'<div class="show_allOn"></div>' + 
                            '<div class="show_allOff" id="show_allText" style="color: black; text-align: center">ON</div>' +
                            '</div>' +
                            '</label>' +
                            '</div>' + //</div>' +
                            '<div id="odShowAllControl">' +
                            '<label for="ShowAll">Show all polygons:&nbsp;</label>' +
                            '</div>';
                    } else {
                        map.legendOdDiv.innerHTML += '' +
                            '<div class="text" style="width:50%; float:right">' +
                            '<label class="switch">' +
                            '<input type="checkbox" id="<?= $_REQUEST['name_w'] ?>_show_all" checked>' +
                            '<div class="slider round" id="slider_poly" style="background-color:' + panelFontColor + '">' +
                            //'<div class="show_allOff"></div>' + 
                            '<div class="show_allOn" id="show_allText" style="color: white; text-align: center">OFF</div>' +
                            '</div>' +
                            '</label>' +
                            '</div>' + //</div>' +
                            '<div id="odShowAllControl">' +
                            '<label for="ShowAll">Show all polygons:&nbsp;</label>' +
                            '</div>';
                        getAllPolyOdMap();
                    }
                } else {
                    showAllPolygonFlag === false
                    getAllPolyOdMap();
                }

                if (animationFlag === false) {
                    if (animationPeriod === "week") {
                        map.legendOdDiv.innerHTML += '<div class="text" style="width:50%; float:right"><label class="switch"><input type="checkbox" id="<?= $_REQUEST['name_w'] ?>_animation"><div class="slider round" id="animation_slider" style="background-color:#DBDBDB"><span class="animationOn"></span><span class="animationOff" id="animationText" style="color: black; text-align: right">Start</span><span class="animationOn" style="color: black; text-align: right">Static</span></div></label></div></div>' +
                            '<div id="odAnimationControl">' +
                            '<label for="Animation">Time period:&nbsp;</label><select name="animation" id="animationPeriod" >' +
                            '<option value="week">week</option>' +
                            '<option value="month">month</option>' + '</select></div>';
                    } else {
                        map.legendOdDiv.innerHTML += '<div class="text" style="width:50%; float:right"><label class="switch"><input type="checkbox" id="<?= $_REQUEST['name_w'] ?>_animation"><div class="slider round" id="animation_slider" style="background-color:#DBDBDB"><span class="animationOn"></span><span class="animationOff" id="animationText" style="color: black; text-align: right">Start</span><span class="animationOn" style="color: black; text-align: right">Static</span></div></label></div></div>' +
                            '<div id="odAnimationControl">' +
                            '<label for="Animation">Time period:&nbsp;</label><select name="animation" id="animationPeriod" >' +
                            '<option value="month">month</option>' +
                            '<option value="week">week</option>' + '</select></div>';
                    }
                } else {
                    if (animationPeriod === "week") {
                        map.legendOdDiv.innerHTML += '<div class="text" style="width:50%; float:right"><label class="switch"><input type="checkbox" id="<?= $_REQUEST['name_w'] ?>_animation" checked disabled><div class="slider round" id="animation_slider" style="background-color:' + panelFontColor + '"><span class="animationOn"></span><span class="animationOff" id="animationText" style="color: white; text-align: right">Stop</span><span class="animationOn" style="color: black; text-align: right">Static</span></div></label></div></div>' +
                            '<div id="odAnimationControl">' +
                            '<label for="Animation">Time period:&nbsp;</label><select name="animation" id="animationPeriod" disabled>' +
                            '<option value="week">week</option>' +
                            '<option value="month">month</option>' + '</select></div>';
                    } else {
                        map.legendOdDiv.innerHTML += '<div class="text" style="width:50%; float:right"><label class="switch"><input type="checkbox" id="<?= $_REQUEST['name_w'] ?>_animation" checked disabled><div class="slider round" id="animation_slider" style="background-color:' + panelFontColor + '"><span class="animationOn"></span><span class="animationOff" id="animationText" style="color: white; text-align: right">Stop</span><span class="animationOn" style="color: black; text-align: right">Static</span></div></label></div></div>' +
                            '<div id="odAnimationControl">' +
                            '<label for="Animation">Time period:&nbsp;</label><select name="animation" id="animationPeriod" disabled>' +
                            '<option value="month">month</option>' +
                            '<option value="week">week</option>' + '</select></div>';
                    }
                    setTimeout(function () {
                        if (odOnMap) {
                            $("#<?= $_REQUEST['name_w'] ?>_animation").prop('disabled', false);
                        }
                    }, 1500);
                }

                //precision
                if (precision != 'poi' && precision != 'ace' && precision != 'municipality' && precision != 'province' && precision != 'region') {
                    var options = '';
                    for (let i = 0; i < shapeTypes.length; i++) {
                        if (shapeTypes[i] !== precision) {
                            options += '<option value=' + shapeTypes[i] + '>' + shapeTypes[i] + '</option>';
                        }
                    }
                    map.legendOdDiv.innerHTML += '<div id="odPrecisionControl">' +
                        '<label for="Precision">Precision:&nbsp;</label><select name="precision" id="precision" ' + disabledAnimation() + '>' +
                        '<option value=' + precision + '>' + precision +
                        options +
                        '</select></div>';
                } else {
                    map.legendOdDiv.innerHTML += '<div id="odPrecisionControl">' +
                        '<label for="Precision">Precision:&nbsp;</label><span name="precision" id="precision" ' + disabledAnimation() + '>' +
                        precision + '</span></div>';
                }

                //flow
                if (inflow === "True") {
                    map.legendOdDiv.innerHTML += '<div id="odFlowControl">' +
                        '<label for="Flow">Flow:&nbsp;</label>' +
                        '<select name="flow" id="flow" ' + disabledAnimation() + '>' +
                        '<option value="inflow">inflow</option>' +
                        '<option value="outflow">outflow</option>' +
                        '</select></div>';
                } else {
                    map.legendOdDiv.innerHTML += '<div id="odFlowControl">' +
                        '<label for="Flow">Flow:&nbsp;</label>' +
                        '<select name="flow" id="flow" ' + disabledAnimation() + '>' +
                        '<option value="outflow">outflow</option>' +
                        '<option value="inflow">inflow</option>' +
                        '</select></div>';
                }

                // max opacity
                map.legendOdDiv.innerHTML +=
                    '<div id="odOpacityControl">' +
                    '<div style="display:inline-block; vertical-align:super;">Max Opacity: &nbsp;&nbsp;&nbsp;&nbsp;</div>' +
                    '<div id="<?= $_REQUEST['name_w'] ?>_downSlider_opacity" style="display:inline-block; vertical-align:super; color: ' + panelFontColor + '">&#10094;</div>&nbsp;&nbsp;&nbsp;' +
                    '<input id="<?= $_REQUEST['name_w'] ?>_slidermaxOpacity" style="display:inline-block; vertical-align:baseline; width:auto; accent-color:' + panelFontColor + '" type="range" min="0" max="1" value="' + current_opacity_od + '" step="0.01" ' + disabledAnimation() + '>' +
                    '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<div id="upSlider_opacity" style="display:inline-block;vertical-align:super; color: ' + panelFontColor + '">&#10095;</div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
                    '<span id="<?= $_REQUEST['name_w'] ?>_rangemaxOpacity" style="display:inline-block;vertical-align:super;">' + current_opacity_od + '</span>' +
                    '</div>';

                // Od Navigation Buttons (prev & next)
                map.legendOdDiv.innerHTML +=
                    '<div id="odNavigationCnt" style="margin-bottom:0.2cm;margin-top:0.2cm">' +
                    '<input type="button" id="<?= $_REQUEST['name_w'] ?>_prevButt" value="< Prev" style="float: left" ' + disabledAnimation() + '/>' +
                    '<input type="button" id="<?= $_REQUEST['name_w'] ?>_nextButt" value="Next >" style="float: right" ' + disabledAnimation() + '/>' +
                    '<div id="<?= $_REQUEST['name_w'] ?>_odDescr" style="text-align: center">' + mapDate + '</div>' +
                    '</div>';

                //Od Navigation Buttons (for more days)
                map.legendOdDiv.innerHTML +=
                    '<div id="odNavigationPeriodCnt">' +
                    '<input type="button" id="<?= $_REQUEST['name_w'] ?>_prevPeriod" value="<<" style="float: left" ' + disabledAnimation() + '/>' +
                    '<input type="button" id="<?= $_REQUEST['name_w'] ?>_nextPeriod" value=">>" style="float: right" ' + disabledAnimation() + '/>' +
                    '<div id="<?= $_REQUEST['name_w'] ?>_odPeriod" style="text-align: center">' + animationPeriod + '</div>' +
                    '</div>';


                //map.legendOdDiv.innerHTML += '<input type="text" id="my-datepicker" class="datepicker" />';
                //map.legendOdDiv.innerHTML += '<input type="date" id="mydatepicker" name="trip-start" value="2018-07-22T00:00:00" min="2018-01-01" max="2018-12-31">'
                // map.legendOdDiv.innerHTML += '<input id="datetimepicker" type="text" >';

                // $.datetimepicker.setDateFormatter('moment');

                function getCloserDateTime(dates, datetime) {
                    var mindatediff = Math.pow(10, 1000); // Max positive number
                    var mindateidx = 0; // Max positive number
                    for (let i = 0; i < dates.length; i++) {
                        var tmp = Math.abs(datetime - (new Date(dates[i])));
                        if (tmp < mindatediff) {
                            mindateidx = i;
                            mindatediff = tmp;
                        }
                    }
                    return new Date(dates[mindateidx]);
                }

                function checkLegend() {

                    // document.getElementById("mydatepicker").addEventListener("change", function (event) {
                    //     console.log(event);
                    //     console.log(document.getElementById("mydatepicker").value);
                    // }, false);

                    document.getElementById("<?= $_REQUEST['name_w'] ?>_odDescr").addEventListener("click", function () {
                        var thisDate = mapDate; //.split(' ')[0]; // day + '.' + mon + '.' + year;
                        var allowDates = []
                        var allowTimes = []
                        var validDateTimes = {};
                        for (let ii = 0; ii < dates.length; ii++) {

                            let key = dates[ii].split(' ')[0];
                            let val = dates[ii].split(' ')[1].split(':')[0] + ':' + dates[ii].split(' ')[1].split(':')[1];
                            allowDates.push(dates[ii].split(' ')[0]);
                            allowTimes.push(dates[ii].split(' ')[1].split(':')[0] + ':' + dates[ii].split(' ')[1].split(':')[1]);

                            if (key in validDateTimes) {
                                var tmparray = validDateTimes[key];
                                tmparray.push(val);
                                validDateTimes[key] = tmparray;
                            } else {
                                validDateTimes[key] = [val];
                            }
                        }
                        allowTimes = [...new Set(allowTimes)];


                        var timepicker = true;
                        if (allowTimes.length == 1) {
                            timepicker = false;
                        }

                        // Map_1_widgetMap1_odDescr
                        $.datetimepicker.setDateFormatter('moment');
                        jQuery('#' + '<?= $_REQUEST['name_w'] ?>_odDescr').datetimepicker({
                            //parentID:'#odLegend',
                            value: thisDate,
                            startDate: thisDate,
                            allowDates: allowDates,
                            //showSecond: true,
                            //showMillisec: false,
                            //format: 'YYYY-MM-DD HH:mm:ss A',
                            formatTime: 'HH:mm',
                            formatDate: 'YYYY-MM-DD',
                            //allowTimes: allowTimes,
                            timepicker: timepicker,
                            onSelectDate: function (ct, $i) {
                                $i.datetimepicker('setOptions', { allowTimes: [] });
                                //var selectedDate = ct.dateFormat('YYYY-MM-DD');
                                //console.log('here');
                                tmpday = ('0' + ct.getDate()).slice(-2);
                                tmpmonth = ('0' + (ct.getMonth() + 1)).slice(-2);
                                tmpyear = ct.getFullYear();


                                var times = validDateTimes[tmpyear + '-' + tmpmonth + '-' + tmpday] || [];

                                // Update the datetimepicker with the new allowed times
                                $i.datetimepicker('setOptions', { value: tmpyear + '-' + tmpmonth + '-' + tmpday });
                                $i.datetimepicker('setOptions', { allowTimes: times });
                            },
                            onClose: function (ct, $i) {
                                newDateTimeSet = getCloserDateTime(dates, ct);
                                //console.log(newDateTimeSet);
                                jQuery.event.trigger({ type: "newOdDatetime" });
                                $i.datetimepicker('destroy');
                                $i.datetimepicker('remove');
                            }
                        }).datetimepicker("show");
                    });

                    document.getElementById("animationPeriod").addEventListener("change", function () {
                        changeAnimationPeriod()
                    }, false);
                    document.getElementById("precision").addEventListener("change", function () {
                        changePrecision()
                    }, false);
                    document.getElementById("flow").addEventListener("change", function () {
                        changeFlow()
                    }, false);

                    document.getElementById("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").addEventListener("input", function () {
                        setOption('maxOpacity', this.value, 2)
                    }, false);

                    if (precision == 'poi' || precision == 'ace' || precision == 'municipality' || precision == 'province' || precision == 'region' || precision == 'communes') {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_show_all").addEventListener("click", function () {
                            showAllPolyOdMap()
                        }, false);
                    }

                    //if(precision === "communes"){
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_animation").addEventListener("click", function () {
                        animateOdMap()
                    }, false);
                    //}
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt").addEventListener("click", function () {
                        prevOdPage()
                    }, false);
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt").addEventListener("click", function () {
                        nextOdPage()
                    }, false);

                    document.getElementById("<?= $_REQUEST['name_w'] ?>_prevPeriod").addEventListener("click", function () {
                        prevOdPeriod();
                    }, false);
                    document.getElementById("<?= $_REQUEST['name_w'] ?>_nextPeriod").addEventListener("click", function () {
                        nextOdPeriod();
                    }, false);

                    if (current_page == 0) {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt").style.visibility = "hidden";
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_prevPeriod").style.visibility = "hidden";
                    } else {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_prevButt").style.visibility = "visible";
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_prevPeriod").style.visibility = "visible";
                    }

                    if (current_page == dates.length - 1) {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt").style.visibility = "hidden";
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_nextPeriod").style.visibility = "hidden";
                    } else {
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_nextButt").style.visibility = "visible";
                        document.getElementById("<?= $_REQUEST['name_w'] ?>_nextPeriod").style.visibility = "visible";
                    }
                }

                setTimeout(checkLegend, 500);
                return map.legendOdDiv;
            };

            map.flowInfo.onAdd = function () {
                map.flowInfoDiv = L.DomUtil.create('div', 'info');
                // disable interaction of this div with map
                if (L.Browser.touch) {
                    L.DomEvent.disableClickPropagation(map.flowInfoDiv);
                    L.DomEvent.on(map.flowInfoDiv, 'mousewheel', L.DomEvent.stopPropagation);
                } else {
                    L.DomEvent.on(map.flowInfoDiv, 'click', L.DomEvent.stopPropagation);
                }
                map.flowInfoDiv.style.width = dataPanelWidth; // "240px" //"170px";
                map.flowInfoDiv.style.fontWeight = "bold";
                map.flowInfoDiv.style.background = panelBackgroundColor; //"#cccccc";
                map.flowInfoDiv.style.color = panelFontColor;
                map.flowInfoDiv.style.fontSize = dataPanelFontSize;
                map.flowInfoDiv.style.padding = "10px";
                this.update();
                return map.flowInfoDiv;
            };

            map.flowInfo.update = function (props) {
                // map.flowInfoDiv.innerHTML = '<div>OD Flows<br />' + (props ?
                //     '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />Rate: ' + 100 * Math.round(props.density * 1000) / 1000 + '%'
                //     : 'Hover over a zone') + '</div>';
                if (props) {
                    var keyNames = Object.keys(props.density);
                    if (keyNames.length <= 1) {
                        if (getPerc === 'True') {
                            map.flowInfoDiv.innerHTML = '<div>' + //OD Flows<br />' + 
                                '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />' +
                                'Rate: ' + 100 * Math.round(props.density * Math.pow(10, 5)) / Math.pow(10, 5) + '%' +
                                '</div>';
                        } else {
                            map.flowInfoDiv.innerHTML = '<div>' + //OD Flows<br />' +  
                                '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />' +
                                'Value: ' + props.density +
                                '</div>';
                        }
                    } else {
                        if (getPerc === 'True') {
                            rates = '<br /><ul>';
                            for (let i = 0; i < keyNames.length; i++) {
                                rates = rates + '<li>' + keyNames[i].replace(/_/g, ' ') + ': ' +
                                    100 * Math.round(props.density[keyNames[i]] * Math.pow(10, 5)) / Math.pow(10, 5) + '%</li>';
                            }
                            rates = rates + '</ul>'
                            map.flowInfoDiv.innerHTML = '<div>' + //OD Flows<br />' +  
                                '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />' +
                                'Rates: ' + rates +
                                '</div>';
                        } else {
                            rates = '<br /><ul>';
                            for (let i = 0; i < keyNames.length; i++) {
                                rates = rates + '<li>' + keyNames[i].replace(/_/g, ' ') + ': ' +
                                    props.density[keyNames[i]] + '</li>';
                            }
                            rates = rates + '</ul>'
                            map.flowInfoDiv.innerHTML = '<div>' + //OD Flows<br />' + 
                                '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />' +
                                'Values: ' + rates +
                                '</div>';
                        }
                    }
                } else {
                    map.flowInfoDiv.innerHTML = '<div>' + //OD Flows<br />' + 
                        'Hover over a zone' + '</div>';
                }
                // map.flowInfoDiv.innerHTML = '<div>OD Flows<br />' + (props ?
                //     '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />Rate: ' + 100 * Math.round(props.density * Math.pow(10, 5)) / Math.pow(10, 5) + '%'
                //     : 'Hover over a zone') + '</div>';
            };

            function disabledAnimation() {
                if (animationFlag) {
                    return "disabled";
                } else {
                    return "";
                }
            }

            function dateDiffInDays(a, b) {
                const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
                const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

                return Math.floor((utc2 - utc1) / (1000 * 60 * 60 * 24));
            }

            function getAllPolyOdMap(async) {
                bbox = map.defaultMapRef.getBounds();
                //console.log(bbox);

                var type = ""; // TODO :: controlla retrocompatibilità                            
                if (precision == 'communes') {
                    type = "communes";
                } else if (precision == 'poi' || precision == 'ace' || precision == 'municipality' || precision == 'province' || precision == 'region') {
                    type = precision;
                } else {
                    type = "mgrs";
                }
                if (type != "mgrs") {
                    $.ajax({
                        url: odUrl + 'get_all_polygons',
                        async: async == 'False' ? false : true,
                        type: "get",
                        data: {
                            latitude_ne: bbox['_northEast']['lat'],
                            longitude_ne: bbox['_northEast']['lng'],
                            latitude_sw: bbox['_southWest']['lat'],
                            longitude_sw: bbox['_southWest']['lng'],
                            type: type,
                            organization: organization
                        },
                        success: function (response) {
                            // remove old layer
                            if (geojson_layer_all) {
                                map.defaultMapRef.removeLayer(geojson_layer_all);
                            }

                            geojson_layer_all = L.geoJson(response, {
                                style: { "color": allPolyColor, "weight": 3, "fill": false }
                            });
                            geojson_layer_all.addTo(map.defaultMapRef);
                            if (sourcePolygon) {
                                sourcePolygon.bringToFront()
                            }
                            if (geojson_layer) {
                                geojson_layer.bringToFront()
                            }
                        }
                    });
                }
            }

            function showAllPolyOdMap() {
                if (!showAllPolygonFlag) {
                    showAllPolygonFlag = true;
                    $("#show_allText").text("OFF");
                    $("#show_allText")[0].style.color = "white";
                    $("#slider_poly")[0].style.backgroundColor = panelFontColor;
                    getAllPolyOdMap();
                } else {
                    showAllPolygonFlag = false;
                    $("#show_allText").text("ON");
                    $("#show_allText")[0].style.color = "black";
                    $("#slider_poly")[0].style.backgroundColor = "#DBDBDB";
                    if (geojson_layer_all) {
                        map.defaultMapRef.removeLayer(geojson_layer_all);
                    }
                }
            }

            map.defaultMapRef.on('zoomend', showAllPolyOdMapZoomend = function () {
                if (showAllPolygonFlag) {
                    getAllPolyOdMap();
                }
            });

            map.defaultMapRef.on('moveend', showAllPolyOdMapMoveend = function () {
                if (showAllPolygonFlag) {
                    getAllPolyOdMap();
                }
            });

            function animateOdMap() {
                if (!animationFlag) {	// && current_page < dates.length - 1
                    animationFlag = true;
                    if (animationPeriod === "week") {
                        let actual_date = new Date((dates[current_page].split(" "))[0]);
                        let week_day = actual_date.getDay();
                        let checkWeek = false;
                        let i = 0;
                        if (week_day === 1) {
                            let max_difference = 6;
                            let temp_page = current_page;
                            current_page--;
                            while (!checkWeek) {
                                temp_page++;
                                if (temp_page < dates.length) {
                                    let temp_date = new Date((dates[temp_page].split(" "))[0]);
                                    let difference = dateDiffInDays(actual_date, temp_date);
                                    if (difference > max_difference) {
                                        checkWeek = true;
                                    }
                                } else {
                                    checkWeek = true;
                                }
                                i++;
                            }
                        } else if (week_day === 0) {
                            let max_difference = 6;
                            while (!checkWeek) {
                                current_page--;
                                if (current_page >= 0) {
                                    let temp_date = new Date((dates[current_page].split(" "))[0]);
                                    let difference = dateDiffInDays(temp_date, actual_date);
                                    if (difference > max_difference) {
                                        checkWeek = true;
                                    }
                                } else {
                                    checkWeek = true;
                                }
                                i++;
                            }
                        } else {
                            let down_difference = week_day - 1;
                            let up_difference = 7 - week_day;
                            let temp_page = current_page;
                            while (!checkWeek) {
                                current_page--;
                                if (current_page >= 0) {
                                    let temp_date = new Date((dates[current_page].split(" "))[0]);
                                    let difference = dateDiffInDays(temp_date, actual_date);
                                    if (difference > down_difference) {
                                        checkWeek = true;
                                    }
                                } else {
                                    checkWeek = true;
                                }
                                i++;
                            }
                            checkWeek = false;
                            while (!checkWeek) {
                                temp_page++;
                                if (temp_page < dates.length) {
                                    let temp_date = new Date((dates[temp_page].split(" "))[0]);
                                    let difference = dateDiffInDays(actual_date, temp_date);
                                    if (difference > up_difference) {
                                        checkWeek = true;
                                    }
                                } else {
                                    checkWeek = true;
                                }
                                i++;
                            }
                            i--;
                        }
                        animationCounter = i;
                        nextOdPage();
                    } else if (animationPeriod === "month") {
                        let checkMonth = false;
                        let date = dates[current_page].split("-");
                        let year = date[0];
                        let month = date[1];
                        let i = 0;
                        let temp_page = current_page;
                        while (!checkMonth) {
                            current_page--;
                            if (current_page >= 0) {
                                let temp_date = dates[current_page].split("-");
                                let temp_year = temp_date[0];
                                let temp_month = temp_date[1];
                                if (month !== temp_month || year !== temp_year) {
                                    checkMonth = true;
                                }
                            } else {
                                checkMonth = true;
                            }
                            i++;
                        }
                        checkMonth = false;
                        while (!checkMonth) {
                            temp_page++;
                            if (temp_page < dates.length) {
                                let temp_date = dates[temp_page].split("-");
                                let temp_year = temp_date[0];
                                let temp_month = temp_date[1];
                                if (month !== temp_month || year !== temp_year) {
                                    checkMonth = true;
                                }
                            } else {
                                checkMonth = true;
                            }
                            i++;
                        }
                        i--;
                        animationCounter = i;
                        nextOdPage()
                    }
                } else {
                    animationFlag = false;
                    $("#<?= $_REQUEST['name_w'] ?>_animation").prop('checked', false);
                    $("#animation_slider")[0].style.backgroundColor = "#DBDBDB";
                    $("#animationText")[0].style.color = "black";
                    $("#animationText").text("Wait");
                    $("#<?= $_REQUEST['name_w'] ?>_animation").prop('disabled', true);
                    setTimeout(function () {
                        if (odOnMap) {
                            $("#<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").prop('disabled', false);
                            $("#animationPeriod").prop('disabled', false);
                            $("#precision").prop('disabled', false);
                            $("#flow").prop('disabled', false);
                            $("#<?= $_REQUEST['name_w'] ?>_prevButt").prop('disabled', false);
                            $("#<?= $_REQUEST['name_w'] ?>_nextButt").prop('disabled', false);
                            $("#<?= $_REQUEST['name_w'] ?>_prevPeriod").prop('disabled', false);
                            $("#<?= $_REQUEST['name_w'] ?>_nextPeriod").prop('disabled', false);
                            $("#<?= $_REQUEST['name_w'] ?>_animation").prop('disabled', false);
                            $("#animationText").text("Start");
                        }
                    }, 3000);
                }
            }

            function changeAnimationPeriod() {
                if (animationPeriod !== $("#animationPeriod").val()) {
                    animationPeriod = $("#animationPeriod").val();
                    $("#<?= $_REQUEST['name_w'] ?>_odPeriod").text(animationPeriod);
                }
            }

            function changePrecision() {
                if (precision !== $("#precision").val()) {
                    var tmp_precision = $("#precision").val();

                    var query_od = odID;
                    if (precision == "communes" || !isNaN(precision)) { // true if precision is communes or a number (e.g. for MGRS)
                        var tmp = query_od.split("_");
                        query_od = tmp[0] + "_" + tmp[1] + "_" + tmp_precision;
                        // console.log(query_od);
                    }

                    $.ajax({
                        url: '../widgets/get_od_metadata.php',
                        data: {
                            precision: tmp_precision,
                            action: "dates",
                            organization: organization,
                            od_id: query_od
                        },
                        async: true,
                        cache: false,
                        dataType: 'json',
                        type: "POST",
                        success: function (data) {
                            if (data.length > 0) {
                                dates = data;
                                precision = tmp_precision;
                                console.log('changePrecision');
                                console.log(dates);
                                current_page = (dates.length) - 1;
                                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                                    if (map.eventsOnMap[i].eventType === 'od') {
                                        removeOd(false);
                                        map.eventsOnMap.splice(i, 1);
                                    } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                                        if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails' && map.eventsOnMap[i].type !== 'addOD') {
                                            map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                            map.eventsOnMap.splice(i, 1);
                                        }
                                    }
                                }

                                if (addMode === 'additive') {
                                    addOdFromClient();
                                }
                                if (addMode === 'exclusive') {
                                    map.defaultMapRef.eachLayer(function (layer) {
                                        map.defaultMapRef.removeLayer(layer);
                                    });
                                    map.eventsOnMap.length = 0;

                                    //Remove WidgetAlarm active pins
                                    $.event.trigger({
                                        type: "removeAlarmPin",
                                    });
                                    //Remove WidgetEvacuationPlans active pins
                                    $.event.trigger({
                                        type: "removeEvacuationPlanPin",
                                    });
                                    //Remove WidgetEvents active pins
                                    $.event.trigger({
                                        type: "removeEventFIPin",
                                    });
                                    //Remove WidgetResources active pins
                                    $.event.trigger({
                                        type: "removeResourcePin",
                                    });
                                    //Remove WidgetOperatorEvents active pins
                                    $.event.trigger({
                                        type: "removeOperatorEventPin",
                                    });
                                    //Remove WidgetTrafficEvents active pins
                                    $.event.trigger({
                                        type: "removeTrafficEventPin",
                                    });
                                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                                        maxZoom: leafletMaxZoom,
                                        maxNativeZoom: leafletNativeMaxZoom
                                    }).addTo(map.defaultMapRef);

                                    addOdFromClient();
                                }
                            } else {
                                console.log('No data for precision: ' + tmp_precision);
                                alert('No data for precision: ' + tmp_precision);
                                var dropdown = document.getElementById("precision");
                                dropdown.value = precision;
                            }
                        },
                        error: function (errorData) {
                            console.log("Ko OD");
                            console.log(JSON.stringify(errorData));
                        }
                    });
                }
            }

            function changeFlow() {
                if ($("#flow").val() === "inflow") {
                    if (inflow !== "True") {
                        inflow = "True";
                        for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                            if (map.eventsOnMap[i].eventType === 'od') {
                                removeOd(false);
                                map.eventsOnMap.splice(i, 1);
                            } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                                if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails' && map.eventsOnMap[i].type !== 'addOD') {
                                    map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                    map.eventsOnMap.splice(i, 1);
                                }
                            }
                        }

                        if (addMode === 'additive') {
                            addOdFromClient();
                        }
                        if (addMode === 'exclusive') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;

                            //Remove WidgetAlarm active pins
                            $.event.trigger({
                                type: "removeAlarmPin",
                            });
                            //Remove WidgetEvacuationPlans active pins
                            $.event.trigger({
                                type: "removeEvacuationPlanPin",
                            });
                            //Remove WidgetEvents active pins
                            $.event.trigger({
                                type: "removeEventFIPin",
                            });
                            //Remove WidgetResources active pins
                            $.event.trigger({
                                type: "removeResourcePin",
                            });
                            //Remove WidgetOperatorEvents active pins
                            $.event.trigger({
                                type: "removeOperatorEventPin",
                            });
                            //Remove WidgetTrafficEvents active pins
                            $.event.trigger({
                                type: "removeTrafficEventPin",
                            });
                            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                                maxZoom: leafletMaxZoom,
                                maxNativeZoom: leafletNativeMaxZoom
                            }).addTo(map.defaultMapRef);

                            addOdFromClient();
                        }
                    }
                } else {
                    if (inflow === "True") {
                        inflow = "False";
                        for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                            if (map.eventsOnMap[i].eventType === 'od') {
                                removeOd(false);
                                map.eventsOnMap.splice(i, 1);
                            } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                                if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails' && map.eventsOnMap[i].type !== 'addOD') {
                                    map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                    map.eventsOnMap.splice(i, 1);
                                }
                            }
                        }

                        if (addMode === 'additive') {
                            addOdFromClient();
                        }
                        if (addMode === 'exclusive') {
                            map.defaultMapRef.eachLayer(function (layer) {
                                map.defaultMapRef.removeLayer(layer);
                            });
                            map.eventsOnMap.length = 0;

                            //Remove WidgetAlarm active pins
                            $.event.trigger({
                                type: "removeAlarmPin",
                            });
                            //Remove WidgetEvacuationPlans active pins
                            $.event.trigger({
                                type: "removeEvacuationPlanPin",
                            });
                            //Remove WidgetEvents active pins
                            $.event.trigger({
                                type: "removeEventFIPin",
                            });
                            //Remove WidgetResources active pins
                            $.event.trigger({
                                type: "removeResourcePin",
                            });
                            //Remove WidgetOperatorEvents active pins
                            $.event.trigger({
                                type: "removeOperatorEventPin",
                            });
                            //Remove WidgetTrafficEvents active pins
                            $.event.trigger({
                                type: "removeTrafficEventPin",
                            });
                            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                                maxZoom: leafletMaxZoom,
                                maxNativeZoom: leafletNativeMaxZoom
                            }).addTo(map.defaultMapRef);

                            addOdFromClient();
                        }
                    }
                }
            }

            function newOdPage() {
                if (current_page < dates.length - 1) {
                    changeOdPage(current_page);

                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType === 'od') {
                            removeOd(false);
                            map.eventsOnMap.splice(i, 1);
                        } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                            if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails' && map.eventsOnMap[i].type !== 'addOD') {
                                map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                map.eventsOnMap.splice(i, 1);
                            }
                        }
                    }

                    if (addMode === 'additive') {
                        addOdFromClient();
                    }
                    if (addMode === 'exclusive') {
                        map.defaultMapRef.eachLayer(function (layer) {
                            map.defaultMapRef.removeLayer(layer);
                        });
                        map.eventsOnMap.length = 0;

                        //Remove WidgetAlarm active pins
                        $.event.trigger({
                            type: "removeAlarmPin",
                        });
                        //Remove WidgetEvacuationPlans active pins
                        $.event.trigger({
                            type: "removeEvacuationPlanPin",
                        });
                        //Remove WidgetEvents active pins
                        $.event.trigger({
                            type: "removeEventFIPin",
                        });
                        //Remove WidgetResources active pins
                        $.event.trigger({
                            type: "removeResourcePin",
                        });
                        //Remove WidgetOperatorEvents active pins
                        $.event.trigger({
                            type: "removeOperatorEventPin",
                        });
                        //Remove WidgetTrafficEvents active pins
                        $.event.trigger({
                            type: "removeTrafficEventPin",
                        });
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                            maxZoom: leafletMaxZoom,
                            maxNativeZoom: leafletNativeMaxZoom
                        }).addTo(map.defaultMapRef);

                        addOdFromClient();
                    }
                }
            }

            function prevOdPage() {
                if (current_page > 0) {
                    current_page--;
                    changeOdPage(current_page);

                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType === 'od') {
                            removeOd(false);
                            map.eventsOnMap.splice(i, 1);
                        } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                            if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails' && map.eventsOnMap[i].type !== 'addOD') {
                                map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                map.eventsOnMap.splice(i, 1);
                            }
                        }
                    }

                    if (addMode === 'additive') {
                        addOdFromClient();
                    }
                    if (addMode === 'exclusive') {
                        map.defaultMapRef.eachLayer(function (layer) {
                            map.defaultMapRef.removeLayer(layer);
                        });
                        map.eventsOnMap.length = 0;

                        //Remove WidgetAlarm active pins
                        $.event.trigger({
                            type: "removeAlarmPin",
                        });
                        //Remove WidgetEvacuationPlans active pins
                        $.event.trigger({
                            type: "removeEvacuationPlanPin",
                        });
                        //Remove WidgetEvents active pins
                        $.event.trigger({
                            type: "removeEventFIPin",
                        });
                        //Remove WidgetResources active pins
                        $.event.trigger({
                            type: "removeResourcePin",
                        });
                        //Remove WidgetOperatorEvents active pins
                        $.event.trigger({
                            type: "removeOperatorEventPin",
                        });
                        //Remove WidgetTrafficEvents active pins
                        $.event.trigger({
                            type: "removeTrafficEventPin",
                        });
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                            maxZoom: leafletMaxZoom,
                            maxNativeZoom: leafletNativeMaxZoom
                        }).addTo(map.defaultMapRef);

                        addOdFromClient();
                    }
                }
            }

            function nextOdPage() {
                if (current_page < dates.length - 1) {
                    current_page++;
                    changeOdPage(current_page);

                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType === 'od') {
                            removeOd(false);
                            map.eventsOnMap.splice(i, 1);
                        } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                            if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails' && map.eventsOnMap[i].type !== 'addOD') {
                                map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                map.eventsOnMap.splice(i, 1);
                            }
                        }
                    }

                    if (addMode === 'additive') {
                        addOdFromClient();
                    }
                    if (addMode === 'exclusive') {
                        map.defaultMapRef.eachLayer(function (layer) {
                            map.defaultMapRef.removeLayer(layer);
                        });
                        map.eventsOnMap.length = 0;

                        //Remove WidgetAlarm active pins
                        $.event.trigger({
                            type: "removeAlarmPin",
                        });
                        //Remove WidgetEvacuationPlans active pins
                        $.event.trigger({
                            type: "removeEvacuationPlanPin",
                        });
                        //Remove WidgetEvents active pins
                        $.event.trigger({
                            type: "removeEventFIPin",
                        });
                        //Remove WidgetResources active pins
                        $.event.trigger({
                            type: "removeResourcePin",
                        });
                        //Remove WidgetOperatorEvents active pins
                        $.event.trigger({
                            type: "removeOperatorEventPin",
                        });
                        //Remove WidgetTrafficEvents active pins
                        $.event.trigger({
                            type: "removeTrafficEventPin",
                        });
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                            maxZoom: leafletMaxZoom,
                            maxNativeZoom: leafletNativeMaxZoom
                        }).addTo(map.defaultMapRef);

                        addOdFromClient();
                    }
                }
            }

            function prevOdPeriod() {
                let actual_date = new Date((dates[current_page].split(" "))[0]);
                let max_difference;
                if (animationPeriod === "week") {
                    let week_day = actual_date.getDay();
                    let checkPrevWeek = false;
                    let temp_page = current_page;
                    temp_page--;
                    //il valore assegnato a max_difference serve per andare indietro fra le date fino al lunedì della settimana precedente
                    if (week_day === 0) {
                        max_difference = 13;
                    } else {
                        max_difference = week_day + 6;
                    }
                    while (!checkPrevWeek) {
                        current_page--;
                        if (current_page >= 0) {
                            let temp_date = new Date((dates[current_page].split(" "))[0]);
                            let difference = dateDiffInDays(temp_date, actual_date);
                            if (difference > max_difference) {
                                checkPrevWeek = true;
                            }
                        } else {
                            checkPrevWeek = true;
                        }
                    }
                    if (current_page >= 0 && current_page === temp_page) {
                        current_page--;
                    }
                    nextOdPage();
                } else {
                    let checkMonth = false;
                    let date = dates[current_page].split("-");
                    let year = date[0];
                    let month = date[1];
                    let temp_page = current_page;
                    temp_page--;
                    //ciclo per arrivare all'inizio del mese della data attuale
                    while (!checkMonth) {
                        current_page--;
                        if (current_page >= 0) {
                            let temp_date = dates[current_page].split("-");
                            let temp_year = temp_date[0];
                            let temp_month = temp_date[1];
                            if (month !== temp_month || year !== temp_year) {
                                checkMonth = true;
                            }
                        } else {
                            checkMonth = true;
                        }
                    }
                    checkMonth = false;
                    month = parseInt(month);
                    if (month !== 1) {
                        month--;
                        if (month < 10) {
                            month = "0" + month.toString();
                        } else {
                            month = month.toString();
                        }
                    } else {
                        month = 12;
                        year = parseInt(year);
                        year--;
                        month = month.toString();
                        year = year.toString();
                    }
                    //ciclo per arrivare all'inizio del mese precedente
                    while (!checkMonth) {
                        current_page--;
                        if (current_page >= 0) {
                            let temp_date = dates[current_page].split("-");
                            let temp_year = temp_date[0];
                            let temp_month = temp_date[1];
                            if (month !== temp_month || year !== temp_year) {
                                checkMonth = true;
                            }
                        } else {
                            checkMonth = true;
                        }
                    }
                    if (current_page >= 0 && current_page === temp_page) {
                        current_page--;
                    }
                    nextOdPage();
                }
            }

            function nextOdPeriod() {
                let actual_date = new Date((dates[current_page].split(" "))[0]);
                let max_difference;
                if (animationPeriod === "week") {
                    let week_day = actual_date.getDay();
                    let checkNextWeek = false;
                    let temp_page = current_page;
                    temp_page++;
                    if (week_day === 0) {
                        max_difference = 1;
                    } else {
                        max_difference = 8 - week_day;
                    }
                    while (!checkNextWeek) {
                        current_page++;
                        if (current_page < dates.length) {
                            let temp_date = new Date((dates[current_page].split(" "))[0]);
                            let difference = dateDiffInDays(actual_date, temp_date);
                            if (difference > max_difference) {
                                checkNextWeek = true;
                            }
                        } else {
                            checkNextWeek = true;
                        }
                    }
                    if (current_page < dates.length && current_page === temp_page) {
                        current_page++;
                    }
                    prevOdPage();
                } else {
                    let checkMonth = false;
                    let date = dates[current_page].split("-");
                    let year = date[0];
                    let month = date[1];
                    while (!checkMonth) {
                        current_page++;
                        if (current_page < dates.length) {
                            let temp_date = dates[current_page].split("-");
                            let temp_year = temp_date[0];
                            let temp_month = temp_date[1];
                            if (month !== temp_month || year !== temp_year) {
                                checkMonth = true;
                            }
                        } else {
                            checkMonth = true;
                        }
                    }
                    if (current_page < dates.length) {
                        current_page++;
                    }
                    prevOdPage();
                }
            }

            function load(setView, async) {  /// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< LOOK HERE
                // get OD data
                var dataQuery = "";
                var polygonQuery = "";
                var type = ""; // TODO :: controlla retrocompatibilità

                if (precision == 'communes') {
                    dataQuery = "get";
                    polygonQuery = "polygon";
                } else if (precision == 'poi' || precision == 'ace' || precision == 'municipality' || precision == 'province' || precision == 'region') {
                    dataQuery = "get";
                    polygonQuery = "polygon";
                    type = precision;
                } else {
                    dataQuery = "get_mgrs";
                    polygonQuery = "mgrs_polygon";
                }

                targetPolyID = [];
                sourcePolyID = [];
                sourcePolyName = [];
                console.log('odUrl dataQuery mapDate:');
                console.log(mapDate);
                $.ajax({
                    url: odUrl + dataQuery,
                    async: async == 'False' ? false : true,
                    type: "get",
                    data: {
                        latitude: latitude,
                        longitude: longitude,
                        precision: precision,
                        from_date: mapDate,
                        organization: organization,
                        inflow: inflow,
                        od_id: odID,
                        perc: getPerc
                    },
                    success: function (response) {
                        // remove old layer
                        if (geojson_layer) {
                            map.defaultMapRef.removeLayer(geojson_layer);
                        }
                        //console.log('Target response OK')
                        // if(responce.properties.density)
                        targetPolyID = [];
                        if (response.features) {
                            for (let ii = 0; ii < response.features.length; ii++) {
                                targetPolyID.push(response.features[ii].id);
                            }
                        }

                        geojson_layer = L.geoJson(response, {
                            style: style,
                            onEachFeature: onEachFeature
                        });
                        geojson_layer.addTo(map.defaultMapRef);
                        jQuery.event.trigger({
                            type: "newOdTargetData",
                        });
                    }
                });

                // get clicked polygon and add it to map
                $.ajax({
                    url: odUrl + polygonQuery,
                    type: "get",
                    data: {
                        precision: precision,
                        latitude: latitude,
                        longitude: longitude,
                        type: type, // TODO controlla retrocompatibilità
                        organization: organization
                    },
                    success: function (response) {
                        // remove old layer
                        if (sourcePolygon) {
                            map.defaultMapRef.removeLayer(sourcePolygon);
                        }
                        //console.log('Source response OK')
                        // MODIFED CODE 2022-05-05
                        sourcePolyID = [];
                        sourcePolyName = [];
                        if (response.features) {
                            sourcePolyID.push(response.features[0].id);
                            sourcePolyName.push(response.features[0].properties.txt_name);
                            src = L.geoJson(response, {
                                style: {
                                    "color": sourcePolyColor,
                                    "fillOpacity": current_opacity_od,
                                    "fillColor": sourcePolyColor
                                },
                                //onEachFeature: onEachFeature
                            });
                        }
                        else {
                            if (Array.isArray(response) && response.length == 5) {
                                sourcePolyID.push('Source');
                                sourcePolyName.push('Source area');
                                var rev_coord = response.map(innerArray => innerArray.reverse());
                                var geojsonFeature = {
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": [response]
                                    }
                                };
                                src = L.geoJson(geojsonFeature, {
                                    style: {
                                        "color": sourcePolyColor,
                                        "fillOpacity": current_opacity_od,
                                        "fillColor": sourcePolyColor
                                    },
                                    //onEachFeature: onEachFeature
                                });
                            }
                        }

                        sourcePolygon = src;
                        src.addTo(map.defaultMapRef);
                        if (geojson_layer) {
                            try {
                                geojson_layer.bringToFront();
                            } catch {

                            }
                        }
                        jQuery.event.trigger({
                            type: "newOdSourceData",
                        });
                        // ORIGINAL CODE
                        //var src = L.polygon(response)
                        //sourcePolygon = src;
                        //src.setStyle({fillColor: '#0000FF'});
                        //src.addTo(map.defaultMapRef);
                    }
                });
            }

            function update_od_gui() {
                // nascondi comandi inflow/outflow se source e target sono lo stesso unico poligono

                if (sourcePolyID.length === targetPolyID.length && sourcePolyID[0] === targetPolyID[0]) {
                    if (document.getElementById('odFlowControl')) {
                        if (inflow === 'True') {
                            document.getElementById('odFlowControl').innerHTML = '<label for="Flow">Flow:&nbsp;</label>' +
                                '<span name="precision" id="precision" ' + disabledAnimation() + '>inflow</span>';
                            // '<select name="flow" id="flow" ' + disabledAnimation() + '>' +
                            // '<option value="inflow">inflow</option>' +
                            // '</select>';
                        } else {
                            document.getElementById('odFlowControl').innerHTML = '<label for="Flow">Flow:&nbsp;</label>' +
                                '<span name="precision" id="precision" ' + disabledAnimation() + '>outflow</span>';
                            // '<select name="flow" id="flow" ' + disabledAnimation() + '>' +
                            // '<option value="outflow">outflow</option>' +
                            // '</select>';
                        }
                        document.getElementById('odFlowControl').style.display = "none";

                        // if(inflow === 'true'){
                        //     document.getElementById('odFlowControl').innerHTML= '<label for="Flow">Flow:&nbsp;</label>' +
                        //                                                         '<span name="flow" id="flow">inflow</span>';
                        //     $("#flow").val() = "inflow";
                        // } else {
                        //     document.getElementById('odFlowControl').innerHTML= '<label for="Flow">Flow:&nbsp;</label>' +
                        //                                                         '<span name="flow" id="flow">outflow</span>';
                        //     $("#flow").val() = "outflow";
                        // }
                    }
                    // if(document.getElementById('info_legend_id')){
                    //         document.getElementById("info_legend_id").style.visibility = 'hidden';
                    //         document.getElementById("legendColorContainer").style.visibility = 'hidden';
                    // }
                } else {
                    // if(document.getElementById('odFlowControl')){
                    //         document.getElementById('odFlowControl').style.visibility = 'visible';
                    // }
                    if (legendColorObserver) {
                        legendColorObserver.disconnect();
                    }
                    if (document.getElementById("info_legend_id")) {
                        document.getElementById("info_legend_id").style.display = "block";
                        document.getElementById("legendColorContainer").style.display = "block";

                        document.getElementById("info_legend_id").style.visibility = 'visible';
                        document.getElementById("legendColorContainer").style.visibility = 'visible';
                    }
                    if (legendColorObserver) {
                        legendColorObserver.observe(document.getElementById("legendColorContainer"), { attributes: true });
                    }
                }
            };


            $(document).on('newOdDatetime', newOdDateTimeFunc = function (event) {
                //console.log('[event] new date and time set')
                //console.log(newDateTimeSet);
                event.stopPropagation();

                tmpday = ('0' + newDateTimeSet.getDate()).slice(-2);
                tmpmonth = ('0' + (newDateTimeSet.getMonth())).slice(-2);
                tmpyear = newDateTimeSet.getFullYear();
                tmphour = ('0' + newDateTimeSet.getHours()).slice(-2);
                tmpmin = ('0' + newDateTimeSet.getMinutes()).slice(-2);
                tmpsec = ('0' + newDateTimeSet.getSeconds()).slice(-2);

                tmpdatestring = new Date(Date.UTC(tmpyear, tmpmonth, tmpday, tmphour, tmpmin, tmpsec)).toISOString();
                date = tmpdatestring.split('T')[0];
                time = tmpdatestring.split('T')[1].split('.')[0];
                // document.getElementById("<?= $_REQUEST['name_w'] ?>_odDescr").textContent = date + ' ' + time;
                mapDateSet = date + ' ' + time;
                dateIndex = dates.findIndex((dts) => dts === mapDateSet);

                if (dateIndex != -1) {
                    mapDate = mapDateSet;
                    current_page = dateIndex;
                    newOdPage();
                    //load();
                    //document.getElementById("<?= $_REQUEST['name_w'] ?>_odDescr").textContent = mapDate;
                    //changeOdPage(current_page);
                } else {
                    alert("No data available for the selected date-time!");
                }
                // console.log(dates);
            });

            $(document).on('newOdTargetData', newOdTargetData = function (event) {
                //    console.log('[event] newOdTargetData')
                if (sourcePolyID.length > 0 && targetPolyID.length > 0) {
                    update_od_gui();
                }
                event.stopPropagation();
            });
            $(document).on('newOdSourceData', newOdSourceData = function (event) {
                //    console.log('[event] newOdSourceData')
                if (sourcePolyID.length > 0 && targetPolyID.length > 0) {
                    update_od_gui();
                }

                if (statID !== "" && sourcePolyID) {
                    let eventJson = new Object();
                    eventJson.topic = "get_stats";
                    eventJson.sourceID = sourcePolyID[0];
                    eventJson.sourceName = sourcePolyName[0];
                    eventJson.precision = precision;
                    eventJson.from_date = mapDate;
                    eventJson.organization = organization;
                    eventJson.inflow = inflow;
                    eventJson.od_id = odID;
                    eventJson.perc = getPerc;
                    eventJson.stat_id = statID;
                    eventJson.latitude = latitude;
                    eventJson.longitude = longitude;
                    currentValue = JSON.stringify(eventJson);
                    if (nodeId != null) {
                        triggerEventOnIotApp(map.defaultMapRef, currentValue);
                    }
                } else {
                    let eventJson = new Object();
                    eventJson.topic = "clear";
                    currentValue = JSON.stringify(eventJson);
                    if (nodeId != null) {
                        triggerEventOnIotApp(map.defaultMapRef, currentValue);
                    }
                }

                event.stopPropagation();
            });

            function style(feature) {
                // if(feature.properties.density.length > 1){
                //     color = getColor(feature.properties.density[Object.keys(feature.properties.density)[0]])
                // }else{
                //     color = getColor(feature.properties.density)
                // }
                if ((typeof feature.properties.density == 'number') || (feature.properties.density == 'string')) {
                    color = getColor(feature.properties.density)
                } else {
                    color = getColor(feature.properties.density[Object.keys(feature.properties.density)[0]])
                }
                if (typeof color === 'undefined') {
                    color = sourcePolyColor;
                }
                return {
                    //weight: 2,
                    //opacity: 1,
                    //color: 'white',
                    //dashArray: '3',
                    stroke: false,
                    fillOpacity: current_opacity_od,
                    fillColor: color //getColor(feature.properties.density)
                };
            }

            function getColor(d) {
                for (i = 0; i < colors.length; i++) {
                    min_value = colors[i][0] == '' ? Number.NEGATIVE_INFINITY : colors[i][0];
                    max_value = colors[i][1] == '' ? Number.POSITIVE_INFINITY : colors[i][1];
                    hex = colors[i][2];
                    if (d > min_value && d <= max_value) {
                        return hex;
                    }
                }
            }

            function onEachFeature(feature, layer) {
                layer.on({
                    mouseover: highlightFeature,
                    mouseout: resetHighlight
                });
            }

            function fillPolygonPopup(props) {
                data = '<div style="background-color:' + panelBackgroundColor + ';color:' + panelFontColor + ';font-size:' + popupPanelFontSize + ';margin:0px;padding:5px;width:100%;height:100%">';
                var keyNames = Object.keys(props.density);
                if (keyNames.length <= 1) {
                    if (getPerc === 'True') {
                        data = data + // 'OD Flows<br />' + 
                            '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />' +
                            'Rate: ' + 100 * Math.round(props.density * Math.pow(10, 5)) / Math.pow(10, 5) + '%';
                    } else {
                        data = data + //'OD Flows<br />' + 
                            '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />' +
                            'Value: ' + props.density;
                    }
                } else {
                    if (getPerc === 'True') {
                        rates = '<br /><ul>';
                        for (let i = 0; i < keyNames.length; i++) {
                            rates = rates + '<li>' + keyNames[i].replace(/_/g, ' ') + ': ' +
                                100 * Math.round(props.density[keyNames[i]] * Math.pow(10, 5)) / Math.pow(10, 5) + '%</li>';
                        }
                        rates = rates + '</ul>'
                        data = data + //'OD Flows<br />' + 
                            '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />' +
                            'Rates: ' + rates;
                    } else {
                        rates = '<br /><ul>';
                        for (let i = 0; i < keyNames.length; i++) {
                            rates = rates + '<li>' + keyNames[i].replace(/_/g, ' ') + ': ' +
                                props.density[keyNames[i]] + '</li>';
                        }
                        rates = rates + '</ul>'
                        data = data + //'OD Flows<br />' + 
                            '<b>Area id: ' + (props.txt_name != '' ? props.txt_name : props.name) + '</b><br />' +
                            'Values: ' + rates;
                    }
                }
                return data + '</div>';
            }

            function highlightFeature(e) {
                var layer = e.target;
                // layer.setStyle({
                //     weight: 5,
                //     color: '#666',
                //     dashArray: '',
                //     fillOpacity: current_opacity_od
                // });

                if (panelOnShape) {
                    var popupStyle = {
                        closeButton: false,
                        maxWidth: popupPanelWidth //300
                    }
                    layer.bindPopup(fillPolygonPopup(layer.feature.properties), popupStyle);
                    layer.off('click', layer._openPopup);
                    layer.openPopup(e.latlng);
                    map.flowInfoDiv.style.display = "none";
                } else {
                    if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                        layer.bringToFront();
                    }

                    map.flowInfo.update(layer.feature.properties);
                }
            }

            function resetHighlight(e) {
                geojson_layer.resetStyle(e.target); // CONTROLLA!!
                if (panelOnShape) {
                    e.target.closePopup();
                    map.flowInfoDiv.style.display = "block";
                } else {
                    map.flowInfo.update();
                }
            }

            odmapClick = function (e) {
                if (animationFlag === false) {
                    var pointAndClickCoord = e.latlng;
                    latitude = pointAndClickCoord.lat.toFixed(5);
                    longitude = pointAndClickCoord.lng.toFixed(5);
                    load();
                    map.flowInfo.update();
                    if (sourcePolyID.length === targetPolyID.length && sourcePolyID[0] === targetPolyID[0] && statID !== "") {
                        // send data to nodered to work on statistics (provenienze)        
                        console.log('Get Provenienze!')
                    }
                }
            }

            if (nodeRedClick != null) {
                map.defaultMapRef.off('click', nodeRedClick)
            }
            map.defaultMapRef.on('click', odmapClick);
            // map.defaultMapRef.on('click', odmapClick = function(e) {
            //     if(animationFlag === false){
            //         var pointAndClickCoord = e.latlng;
            //         latitude = pointAndClickCoord.lat.toFixed(5);
            //         longitude = pointAndClickCoord.lng.toFixed(5);
            //         load();
            //         map.flowInfo.update();
            //     }
            // });

            function addOdToMap() {
                animationFlag = false;
                // try {
                if (map.eventsOnMap.length > 0) {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i].eventType === 'od') {
                            removeOd(true);
                            map.eventsOnMap.splice(i, 1);
                        } else if (map.eventsOnMap[i].type === 'addOD') {
                            removeOdColorLegend(i, true);
                            // map.defaultMapRef.removeControl(map.eventsOnMap[i].legendColors);
                            map.eventsOnMap.splice(i, 1);
                        } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                            if (map.eventsOnMap[i].type === 'trafficRealTimeDetails') {
                                map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                map.eventsOnMap.splice(i, 1);
                            } else if (map.eventsOnMap[i]._url) {
                                if (map.eventsOnMap[i]._url.includes("animate")) {
                                    map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                    map.eventsOnMap.splice(i, 1);
                                }
                            } else if (map.eventsOnMap[i].eventType === 'heatmap') {
                                map.defaultMapRef.removeLayer(wmsLayer);
                                map.defaultMapRef.removeControl(map.legendHeatmap);
                                map.eventsOnMap.splice(i, 1);
                            } else if (map.eventsOnMap[i].type === 'addHeatmap') {
                                map.defaultMapRef.removeControl(map.eventsOnMap[i].legendColors);
                                map.eventsOnMap.splice(i, 1);
                            }
                        }
                    }
                }

                passedParams = event.passedParams;
                var color1 = passedParams.color1;
                var color2 = passedParams.color2;
                var desc = passedParams.desc;
                var loadingDiv = $('<div class="gisMapLoadingDiv"></div>');

                if ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length > 0) {
                    loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').last());
                } else {
                    loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_map'));
                }

                loadingDiv.css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length * loadingDiv.height())) + "px");
                loadingDiv.css("left", ($('#<?= $_REQUEST['name_w'] ?>_div').width() - loadingDiv.width()) + "px");

                var loadingText = $('<p class="gisMapLoadingDivTextPar">adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                var loadOkText = $('<p class="gisMapLoadingDivTextPar"><b>' + desc.toLowerCase() + '</b> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');

                loadingDiv.css("background", color1);
                loadingDiv.css("background", "-webkit-linear-gradient(left top, " + color1 + ", " + color2 + ")");
                loadingDiv.css("background", "-o-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                loadingDiv.css("background", "-moz-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                loadingDiv.css("background", "linear-gradient(to bottom right, " + color1 + ", " + color2 + ")");

                loadingDiv.show();

                loadingDiv.append(loadingText);
                loadingDiv.css("opacity", 1);

                var parHeight = loadingText.height();
                var parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                loadingText.css("margin-top", parMarginTop + "px");

                var od = {};
                od.eventType = "od";
                var query_od = odID;
                if (precision == "communes" || !isNaN(precision)) {
                    var tmp = query_od.split("_");
                    query_od = tmp[0] + "_" + tmp[1] + "_" + precision;
                }
                $.ajax({
                    url: '../widgets/get_od_metadata.php',
                    data: {
                        precision: precision,
                        action: "dates",
                        organization: organization,
                        od_id: query_od
                    },
                    async: true,
                    cache: false,
                    dataType: 'json',
                    type: "POST",
                    success: function (data) {
                        dates = data;
                        colors = getOdColorLegend();
                        if (opacity != null) {
                            current_opacity_od = parseFloat(opacity);
                        }
                        if (current_opacity_od == null) {
                            current_opacity_od = parseFloat(opacity); //0.60;
                        }

                        current_page = (dates.length) - 1;


                        map.defaultMapRef.createPane('Snap4City: OD Flows');
                        map.defaultMapRef.getPane('Snap4City: OD Flows').style.zIndex = 420;

                        mapDate = dates[current_page];
                        load();

                        $.ajax({
                            url: '../widgets/get_od_metadata.php',
                            data: {
                                precision: precision,
                                action: "shape_type",
                                organization: organization,
                                od_id: query_od
                            },
                            async: true,
                            cache: false,
                            dataType: 'json',
                            type: "POST",
                            success: function (data) {
                                for (let i = 0; i < data.length; i++) {
                                    data[i] = (data[i].split("_"))[2];
                                }
                                shapeTypes = data;

                                // add legend to map
                                map.legendOd.addTo(map.defaultMapRef);
                                document.getElementById("<?= $_REQUEST['name_w'] ?>_odDescr").style.cursor = 'pointer';
                                map.flowInfo.addTo(map.defaultMapRef);
                                map.eventsOnMap.push(od);


                                var legendColors = L.control({ position: 'bottomleft' });

                                legendColors.onAdd = function () {
                                    var div = L.DomUtil.create('div', 'info_legend'),
                                        labels = [],
                                        from, to;
                                    div.id = "info_legend_id";
                                    div.style.display = "none";
                                    div.style.visibility = "hidden";
                                    div.style.backgroundColor = panelBackgroundColor; //"#cccccc";
                                    div.style.color = panelFontColor;
                                    div.style.fontSize = cmFontSize;
                                    div.style.textAlign = "left";
                                    div.style.lineHeigth = "18px";
                                    div.style.fontWeight = "bold";
                                    labels.push('<div id="legendColorContainer" style="margin:8px; display:none; visibility: hidden;">Flow');
                                    for (i = 0; i < colors.length; i++) {
                                        if ((colors[i])[0] != null) {
                                            from = ((colors[i])[0]) * 100;
                                        } else {
                                            from = 0;
                                        }
                                        from = Math.round(from * 10) / 10
                                        if ((colors[i])[1] != null) {
                                            to = ((colors[i])[1]) * 100;
                                        } else {
                                            to = 100
                                        }
                                        to = Math.round(to * 10) / 10
                                        hex = (colors[i])[2];
                                        labels.push(
                                            '<i style="background:' + hex + ';width:18px;height:18px;float:left;margin-right:8px;opacity:0.7;"></i> ' +
                                            from + (to ? '&ndash;' + to : '+') + '%');
                                    }
                                    labels.push('</div>');
                                    div.innerHTML = labels.join('<br>');

                                    L.DomEvent.disableClickPropagation(div);
                                    div.style.display = "none";
                                    return div;
                                };

                                legendColors.addTo(map.defaultMapRef);

                                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                // Select the node that will be observed for mutations
                                const targetNode = document.getElementById('legendColorContainer');

                                // Options for the observer (which mutations to observe)
                                const config = { attributes: true }; //, childList: true, subtree: true };

                                // Callback function to execute when mutations are observed
                                const callback = function (mutationsList, observer) {
                                    // Use traditional 'for loops' for IE 11
                                    for (const mutation of mutationsList) {
                                        if (mutation.type === 'childList') {
                                            // console.log('A child node has been added or removed.');
                                        }
                                        else if (mutation.type === 'attributes') {
                                            // console.log('The ' + mutation.attributeName + ' attribute was modified.');

                                            observer.disconnect();
                                            document.getElementById("info_legend_id").style.display = "none";
                                            document.getElementById("legendColorContainer").style.display = "none";
                                            document.getElementById("info_legend_id").style.visibility = 'hidden';
                                            document.getElementById("legendColorContainer").style.visibility = 'hidden';
                                            observer.observe(document.getElementById("legendColorContainer"), { attributes: true });
                                        }
                                    }
                                };

                                // Create an observer instance linked to the callback function
                                legendColorObserver = new MutationObserver(callback);

                                // Start observing the target node for configured mutations
                                legendColorObserver.observe(targetNode, config);

                                // Later, you can stop observing
                                // observer.disconnect();
                                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                event.legendColors = legendColors;
                                map.eventsOnMap.push(event);

                                loadingDiv.empty();
                                loadingDiv.append(loadOkText);

                                parHeight = loadOkText.height();
                                parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                loadOkText.css("margin-top", parMarginTop + "px");

                                setTimeout(function () {
                                    loadingDiv.css("opacity", 0);
                                    setTimeout(function () {
                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                        });
                                        loadingDiv.remove();
                                    }, 350);
                                }, 1000);
                            },
                            error: function (errorData) {
                                console.log("No Data!!!");
                                console.log(JSON.stringify(errorData));
                            }
                        });
                    },
                    error: function (errorData) {
                        console.log("Ko OD");
                        console.log(JSON.stringify(errorData));
                    }
                });

                //   } catch(err) {
                //       loadingDiv.empty();
                //       loadingDiv.append(loadKoText);

                //     parHeight = loadKoText.height();
                //     parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                //     loadKoText.css("margin-top", parMarginTop + "px");
                //     console.log("Error: " + err);
                //     setTimeout(function () {
                //         loadingDiv.css("opacity", 0);
                //         setTimeout(function () {
                //             loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                //                 $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                //             });
                //             loadingDiv.remove();
                //         }, 350);
                //     }, 1000);
                // }
            }

            function addOdFromClient() {
                var od = {};
                od.eventType = "od";

                            /*passedParams = event.passedParams;

                            var color1 = passedParams.color1;
                            var color2 = passedParams.color2;
                            var desc = passedParams.desc;

                            var loadingDiv = $('<div class="gisMapLoadingDiv"></div>');

                            if ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length > 0) {
                loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').last());
            } else {
                loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_map'));
            }

            loadingDiv.css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length * loadingDiv.height())) + "px");
            loadingDiv.css("left", ($('#<?= $_REQUEST['name_w'] ?>_div').width() - loadingDiv.width()) + "px");

            var loadingText = $('<p class="gisMapLoadingDivTextPar">adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="fa fa-circle-o-notch fa-spin" style="font-size: 30px"></i></p>');
            var loadOkText = $('<p class="gisMapLoadingDivTextPar"><b>' + desc.toLowerCase() + '</b> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
            var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');

            loadingDiv.css("background", color1);
            loadingDiv.css("background", "-webkit-linear-gradient(left top, " + color1 + ", " + color2 + ")");
            loadingDiv.css("background", "-o-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
            loadingDiv.css("background", "-moz-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
            loadingDiv.css("background", "linear-gradient(to bottom right, " + color1 + ", " + color2 + ")");

            loadingDiv.show();
            loadingDiv.append(loadingText);
            loadingDiv.css("opacity", 1);

            var parHeight = loadingText.height();
            var parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
            loadingText.css("margin-top", parMarginTop + "px");*/

            if (current_page < 0 || current_page >= dates.length) {
                current_page = (dates.length) - 1;
            }

            mapDate = dates[current_page];

            map.defaultMapRef.createPane('Snap4City: OD Flows');
            map.defaultMapRef.getPane('Snap4City: OD Flows').style.zIndex = 420;
            //if(mapDate !== null){
            load();
            //}

            // add legend to map
            map.legendOd.addTo(map.defaultMapRef);
            document.getElementById("<?= $_REQUEST['name_w'] ?>_odDescr").style.cursor = 'pointer';
            map.flowInfo.addTo(map.defaultMapRef);
            map.eventsOnMap.push(od);

                            /*loadingDiv.empty();
                            loadingDiv.append(loadOkText);

                            parHeight = loadOkText.height();
                            parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                            loadOkText.css("margin-top", parMarginTop + "px");  */

                            /*if (!animationFlag) {
                                setTimeout(function () {
                                    loadingDiv.css("opacity", 0);
                                    setTimeout(function () {
                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
        });
    loadingDiv.remove();
                                    }, 350);
                                }, 1000);
                            } else {    */
        if (animationFlag) {
                                //setTimeout(function () {
                                    /*loadingDiv.css("opacity", 0);
                                    setTimeout(function () {
                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
        });
        loadingDiv.remove();
    }, 350);    */
    setTimeout(function () {
        if (animationFlag && odOnMap) {
            animationCounter--;
            if (animationCounter > 0) {
                nextOdPage()
            } else {
                animateOdMap();
            }
        }
    }, 3000);
                            //    }, 1000);
                            }
                        }

    if (addMode === 'additive') {
        addOdToMap();
    }
    if (addMode === 'exclusive') {
        map.defaultMapRef.eachLayer(function (layer) {
            map.defaultMapRef.removeLayer(layer);
        });
        map.eventsOnMap.length = 0;

        //Remove WidgetAlarm active pins
        $.event.trigger({
            type: "removeAlarmPin",
        });
        //Remove WidgetEvacuationPlans active pins
        $.event.trigger({
            type: "removeEvacuationPlanPin",
        });
        //Remove WidgetEvents active pins
        $.event.trigger({
            type: "removeEventFIPin",
        });
        //Remove WidgetResources active pins
        $.event.trigger({
            type: "removeResourcePin",
        });
        //Remove WidgetOperatorEvents active pins
        $.event.trigger({
            type: "removeOperatorEventPin",
        });
        //Remove WidgetTrafficEvents active pins
        $.event.trigger({
            type: "removeTrafficEventPin",
        });
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
            maxZoom: leafletMaxZoom,
            maxNativeZoom: leafletNativeMaxZoom
        }).addTo(map.defaultMapRef);

        addOdToMap();
    }
                    }
                });


    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    $(document).on('addBimShape', function (event) {
        var currentBimShapePage = 0;
        var newBimShape = null;
        if (event.target === map.mapName) {
            var bimColorScale = "";
            if (lastPopup !== null) {
                lastPopup.closePopup();
            }

            function getBimColor(d) {
                var min_val, max_val, bim_hex = null;
                for (let i = 0; i < bimColorScale.length; i++) {
                    min_val = (bimColorScale[i]["min"] == null || bimColorScale[i]["min"] == '') ? Number.NEGATIVE_INFINITY : bimColorScale[i]["min"];
                    max_val = (bimColorScale[i]["max"] == null || bimColorScale[i]["max"] == '') ? Number.POSITIVE_INFINITY : bimColorScale[i]["max"];
                    bim_hex = '#' + fullColorHex(bimColorScale[i].rgb.substring(1, bimColorScale[i].rgb.length - 1));
                    if (min_val == null) min_val = -1;
                    if (d > parseFloat(min_val) && d <= parseFloat(max_val)) {
                        return bim_hex;
                    }
                }
            }

            function styleBimShape(feature) {
                //var color = getBimColor(feature.properties.density[Object.keys(feature.properties.density)[0]]);
                var color = "";
                if (feature.properties.values) {
                    color = getBimColor(feature.properties.values[bubbleSelectedMetric[descBim]]);
                } else if (feature.properties.lastValue) {
                    color = getBimColor(feature.properties.lastValue[bubbleSelectedMetric[descBim]]);
                }
                
                var borderColor = darkenColor(color, 0.2);

                return {
                    stroke: true,
                    color: borderColor,
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.6,
                    fillColor: color
                };

            }

            $(document).on('newBimShape', newBimShape = function (event) {
                //    console.log('[event] newOdTargetData')
                /*    if(sourcePolyID.length > 0 && targetPolyID.length >0){
                        update_od_gui();
                    }   */
                event.stopPropagation();
            });

            function addBimShapeEventToMap() {

                if (map.eventsOnMap.length > 0) {
                    for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                        if (map.eventsOnMap[i] && map.eventsOnMap[i].type && map.eventsOnMap[i].type === 'addBimShape') {
                            removeBimShapeColorLegend(i, true);
                            map.eventsOnMap.splice(i, 1);
                            //map.defaultMapRef.off('click', heatmapClick);
                        }
                    }
                }

                var passedData = event.passedData;
                var mapBounds = map.defaultMapRef.getBounds();
                var query = passedData.query;
                var queryShape = passedData.query;
                var targets = passedData.targets;
                var eventGenerator = passedData.eventGenerator;
                var color1 = passedData.color1;
                var color2 = passedData.color2;
                var queryType = passedData.queryType;
                descBim = passedData.desc;
                var display = passedData.display;
                var pinattr = passedData.pinattr;
                var pincolor = passedData.pincolor;
                var symbolcolor = passedData.symbolcolor;
                var iconFilePath = passedData.iconFilePath;
                selectedMetrics = passedData.selectedMetrics;
                bubbleSelectedMetric[descBim] = passedData.bubbleSelectedMetric;
                altViewMode = passedData.altViewMode;
                bimShapeOnMap = true;

                var loadingDiv = $('<div class="gisMapLoadingDiv"></div>');

                if ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length > 0) {
                    loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').last());
                }
                else {
                    loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_map'));
                }

                loadingDiv.css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length * loadingDiv.height())) + "px");
                loadingDiv.css("left", ($('#<?= $_REQUEST['name_w'] ?>_div').width() - loadingDiv.width()) + "px");

                if (descBim == query) {
                    var loadingText = $('<p class="gisMapLoadingDivTextPar">adding to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                    var loadOkText = $('<p class="gisMapLoadingDivTextPar"> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                    var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');
                } else {
                    var loadingText = $('<p class="gisMapLoadingDivTextPar">adding <b>' + descBim.toLowerCase() + '</b> to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                    var loadOkText = $('<p class="gisMapLoadingDivTextPar"><b>' + descBim.toLowerCase() + '</b> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                    var loadKoText = $('<p class="gisMapLoadingDivTextPar">error adding <b>' + descBim.toLowerCase() + '</b> to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');
                }

                loadingDiv.css("background", color1);
                loadingDiv.css("background", "-webkit-linear-gradient(left top, " + color1 + ", " + color2 + ")");
                loadingDiv.css("background", "-o-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                loadingDiv.css("background", "-moz-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                loadingDiv.css("background", "linear-gradient(to bottom right, " + color1 + ", " + color2 + ")");

                loadingDiv.show();

                loadingDiv.append(loadingText);
                loadingDiv.css("opacity", 1);

                var parHeight = loadingText.height();
                var parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                loadingText.css("margin-top", parMarginTop + "px");

                var re1 = '(selection)';	// Word 1
                var re2 = '(=)';	// Any Single Character 1
                var re3 = '([+-]?\\d*\\.\\d+)(?![-+0-9\\.])';	// Float 1
                var re4 = '(;|%3B)';	// Any Single Character 2
                var re5 = '([+-]?\\d*\\.\\d+)(?![-+0-9\\.])';	// Float 2
                var re6 = '(;|%3B)?';	// Any Single Character 3
                var re7 = '([+-]?\\d*\\.\\d+)?(?![-+0-9\\.])?';	// Float 3
                var re8 = '(;|%3B)?';	// Any Single Character 4
                var re9 = '([+-]?\\d*\\.\\d+)?(?![-+0-9\\.])?';	// Float 4

                var pattern = new RegExp(re1 + re2 + re3 + re4 + re5 + re6 + re7 + re8 + re9, ["i"]);

                var apiUrl = "";
                var shapeApiUrl = "";
                if (queryType === "Default") {
                    if (!passedData.query.includes("selection")) {
                        query = "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + passedData.query.split('serviceUri=')[1];
                        queryShape = null;
                    } else {
                        if (pattern.test(passedData.query)) {
                            //console.log("Service Map selection substitution");
                            query = passedData.query.replace(pattern, "selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng);
                        } else {
                            //console.log("Service Map selection addition");
                            query = passedData.query + "&selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng;
                        }
                        if (altViewMode == "BimShape" || altViewMode == "BimShapePopup") {
                            queryShape = query + "&valueName=geometry";
                            query = query + "&valueName=" + bubbleSelectedMetric[descBim];
                        }
                        query = "<?= $superServiceMapProxy ?>api/v1/iot-search/?" + query.split('?')[1];
                        queryShape = "<?= $superServiceMapProxy ?>api/v1/iot-search/?" + queryShape.split('?')[1];
                        if (!query.includes("&maxResults")) {
                            if (!query.includes("&queryId")) {
                                query = query + "&maxResults=0";
                            }
                        }
                    }
                } else if (queryType === "Sensor") {
                    if (event.query != null) {
                        query = "<?= $superServiceMapProxy ?>" + event.query;
                    } else if (query != null) {
                        query = "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + passedData.query.split('serviceUri=')[1];
                        queryShape = null;
                    }
                } else {
                    query = passedData.query;
                }

                if (passedData.targets && passedData.targets !== "") {
                    targets = passedData.targets.split(",");
                }
                else {
                    targets = [];
                }

                apiUrl = query + "&geometry=true&fullCount=false";
                if (queryShape != null) {
                    shapeApiUrl = queryShape + "&geometry=true&fullCount=false";
                }


                getSmartCityAPIData = fetchAjax(apiUrl, null, "GET", 'json', true, 0);
                // getShapeSmartCityAPIData = fetchAjax(shapeApiUrl, null, "GET", 'json', true, 0);

                var geoJsonData = null;
                var geoShapeData = null;

                // var getSmartCityAPIData = fetchAjax("../controllers/superservicemapProxy.php/api/v1?seleion=43.78435588315245;11.206140518188478;43.81861292561012;11.274290084838867&categories=Building_construction&maxResults=200&format=json&model=BuildingBIM-Model&geometry=true&fullCount=false", null, "GET", 'json', true, 0);
                //    var getColorMapData = getSmartCityAPIData.then(function(jsonData) {

                //$.when(getSmartCityAPIData, getShapeSmartCityAPIData).done(function(jsonData, shapeData) {
                getSmartCityAPIData.done(function (jsonData) {
                    let countNullGeometry = 0;
                    geoJsonData = jsonData;
                    if (geoJsonData.error == null && geoJsonData.failure == null) {
                        var realtimeDataJson = null;
                        var fatherGeoJsonNode = {};
                        var dataObj = {};
                        if (queryType === "Default") {
                            var countObjKeys = 0;
                            var objContainer = {};
                            if (geoJsonData.features) {
                                fatherGeoJsonNode = geoJsonData;
                            } else {
                                Object.keys(geoJsonData).forEach(function (key) {
                                    if (countObjKeys == 0) {
                                        if (geoJsonData.hasOwnProperty(key)) {
                                            fatherGeoJsonNode = geoJsonData[key];
                                        }
                                    } else {
                                        if (geoJsonData.hasOwnProperty(key)) {
                                            if (geoJsonData[key].features) {
                                                fatherGeoJsonNode.features = fatherGeoJsonNode.features.concat(geoJsonData[key].features);
                                            }
                                        }
                                    }
                                    countObjKeys++;
                                });
                            }

                        } else {
                            if (geoJsonData.hasOwnProperty("BusStop")) {
                                fatherGeoJsonNode = geoJsonData.BusStop;
                            } else {
                                if (geoJsonData.hasOwnProperty("Sensor")) {
                                    fatherGeoJsonNode = geoJsonData.Sensor;
                                } else {
                                    if (geoJsonData.hasOwnProperty("Service")) {
                                        fatherGeoJsonNode = geoJsonData.Service;
                                    } else {
                                        fatherGeoJsonNode = geoJsonData.Services;
                                    }
                                }
                            }
                        }

                        if (geoJsonData.hasOwnProperty("realtime")) {
                            realtimeDataJson = geoJsonData.realtime;
                        }

                        for (var i = 0; i < fatherGeoJsonNode.features.length; i++) {
                            if (passedData.floorNumber == null || passedData.modelInstance == "singleBuilding" || passedData.modelInstance == "singleDevice" || (passedData.floorNumber != null && fatherGeoJsonNode.features[i].properties.values && fatherGeoJsonNode.features[i].properties.values.identifierName != null && (passedData.floorNumber == fatherGeoJsonNode.features[i].properties.values.identifierName || checkFloorNumber(passedData.floorNumber, fatherGeoJsonNode.features[i].properties.values.identifierName)))) {
                                var shapeJsonString = null;
                                var shapeJson = null;

                                fatherGeoJsonNode.features[i].properties.targetWidgets = targets;
                                fatherGeoJsonNode.features[i].properties.color1 = color1;
                                fatherGeoJsonNode.features[i].properties.color2 = color2;
                                fatherGeoJsonNode.features[i].properties.pinattr = passedData.pinattr;
                                fatherGeoJsonNode.features[i].properties.pincolor = passedData.pincolor;
                                fatherGeoJsonNode.features[i].properties.symbolcolor = passedData.symbolcolor;
                                fatherGeoJsonNode.features[i].properties.iconFilePath = passedData.iconFilePath;
                                fatherGeoJsonNode.features[i].properties.altViewMode = passedData.altViewMode;

                                var maxValue = 0;
                                var valueObj = {};
                                if (fatherGeoJsonNode.features[i].properties.values != null) {
                                    if (geoJsonData.features[i].properties.values.hasOwnProperty("geometry")) {
                                        shapeJsonString = geoJsonData.features[i].properties.values["geometry"];
                                        if (shapeJsonString === "") {
                                            fatherGeoJsonNode.features.splice(i, 1);
                                            i--;
                                            continue;
                                        }
                                        if (IsJsonString(shapeJsonString)) {
                                            shapeJson = JSON.parse(shapeJsonString);
                                        } else {
                                            shapeJson = shapeJsonString;
                                        }
                                            fatherGeoJsonNode.features[i].geometry.coordinates = shapeJson.coordinates;
                                        }
                                    if (fatherGeoJsonNode.features[i].properties.values.hasOwnProperty(bubbleSelectedMetric[descBim])) {
                                        fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[descBim]] = fatherGeoJsonNode.features[i].properties.values[bubbleSelectedMetric[descBim]];
                                        //fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[descBim]] = fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[descBim]].replace(/"/g, "");
                                        if (isNaN(parseFloat(fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[descBim]]))) {
                                            if (shapeJson != null) {
                                                fatherGeoJsonNode.features[i].geometry.type = shapeJson.type;
                                            } else {
                                                countNullGeometry++;
                                            }
                                            continue;
                                        } else {
                                            if (fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[descBim]] > maxValue) {
                                                maxValue = fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[descBim]];
                                            }
                                        }
                                    } else {
                                        fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[descBim]] = 0;
                                        //continue;
                                    }
                                } else {
                                    if (fatherGeoJsonNode.features[i].properties.values == null && geoJsonData.hasOwnProperty("realtime")) {
                                        if (fatherGeoJsonNode.features[i].properties.realtimeAttributes.hasOwnProperty("geometry")) {
                                            if (shapeJsonString = geoJsonData.realtime.results.bindings[0]["geometry"] != null) {
                                                shapeJsonString = geoJsonData.realtime.results.bindings[0]["geometry"].value;
                                                if (IsJsonString(shapeJsonString)) {
                                                    shapeJson = JSON.parse(shapeJsonString);
                                                    fatherGeoJsonNode.features[i].geometry.coordinates = shapeJson.coordinates;
                                                }
                                            }
                                        }
                                        if (fatherGeoJsonNode.features[i].properties.realtimeAttributes.hasOwnProperty(bubbleSelectedMetric[descBim])) {
                                            var key = bubbleSelectedMetric[descBim];
                                            var obj = {};
                                            obj[key] = geoJsonData.realtime.results.bindings[0][bubbleSelectedMetric[descBim]].value;
                                            fatherGeoJsonNode.features[i].properties["lastValue"] = obj;
                                        }
                                    } else {
                                        fatherGeoJsonNode.features[i].properties[bubbleSelectedMetric[descBim]] = 0;
                                        //continue;
                                    }
                                }

                                //fatherGeoJsonNode.features[i].geometry.type = "MultiPolygon";
                                //let countNullGeometry = 0;
                                if (shapeJson != null) {
                                    fatherGeoJsonNode.features[i].geometry.type = shapeJson.type;
                                } else {
                                    countNullGeometry++;
                                }

                                dataObj.eventType = "bimShapeEvent";
                                dataObj.descBim = descBim;
                                dataObj.query = passedData.query;
                                dataObj.targets = passedData.targets;
                                dataObj.eventGenerator = passedData.eventGenerator;
                                dataObj.color1 = passedData.color1;
                                dataObj.color2 = passedData.color2;
                                dataObj.queryType = passedData.queryType;
                                dataObj.display = passedData.display;
                                dataObj.iconTextMode = passedData.iconTextMode;

                                //    map.eventsOnMap.push(dataObj);
                            } else if (passedData.floorNumber != null && fatherGeoJsonNode.features[i].properties.values && fatherGeoJsonNode.features[i].properties.values.identifierName != null && passedData.floorNumber != fatherGeoJsonNode.features[i].properties.values.identifierName) {
                                fatherGeoJsonNode.features[i] = [];
                            }
                        }

                        if (countNullGeometry > 0) {
                            console.log("Number of Devices with Empty or Null Geometry JSON: " + countNullGeometry);
                        }

                        i = 0;
                        while (i < fatherGeoJsonNode.features.length) {
                            if (Array.isArray(fatherGeoJsonNode.features[i]) && fatherGeoJsonNode.features[i].length == 0) {
                                fatherGeoJsonNode.features.splice(i, 1);
                            } else {
                                i++;
                            }
                        }

                        map.eventsOnMap.push(dataObj);
                        var colorBimMapName = "";
                        var legendBimFilePath = "";

                        if (passedData.floorNumber == null) {
                            if (fatherGeoJsonNode.features[0].properties.deviceModel === "buildingModelEnergy15Min" || fatherGeoJsonNode.features[0].properties.model === "buildingModelEnergy15Min") {
                                colorBimMapName = "colormap" + (bubbleSelectedMetric[descBim]).charAt(0).toUpperCase() + (bubbleSelectedMetric[descBim]).slice(1) + "_building";
                            } else {
                                colorBimMapName = "colormapshape" + bubbleSelectedMetric[descBim];
                            }
                        } else {
                            colorBimMapName = "colormap" + (bubbleSelectedMetric[descBim]).charAt(0).toUpperCase() + (bubbleSelectedMetric[descBim]).slice(1) + "_floor";
                        }
                        legendBimFilePath = '../img/heatmapsGradientLegends/' + colorBimMapName + '.png';

                        var getColorMapData = fetchAjax(heatmapUrl + "getColorMap.php?metricName=" + colorBimMapName, null, "GET", 'json', true, null);
                        getColorMapData.done(function (colorScale) {

                            bimColorScale = colorScale;
                            if (geoJsonLayerShape) {
                                map.defaultMapRef.removeLayer(geoJsonLayerShape);
                            }

                            try {
                                geoJsonLayerShape = L.geoJson(fatherGeoJsonNode, {
                                    //style: styleBimShape(fatherGeoJsonNode.features[0].properties.lastValue[bubbleSelectedMetric[descBim]]),
                                    style: styleBimShape,
                                    onEachFeature: onMapEntityClick
                                });
                                geoJsonLayerShape.addTo(map.defaultMapRef);

                                if (passedData.modelInstance == "singleBuilding" || passedData.modelInstance == "singleDevice") {
                                    map.defaultMapRef.setView([fatherGeoJsonNode.features[0].geometry.coordinates[0][0][1], fatherGeoJsonNode.features[0].geometry.coordinates[0][0][0]], 18);
                                }

                                if (geoJsonLayerShape) {
                                    try {
                                        geoJsonLayerShape.bringToFront();
                                    } catch {

                                    }
                                }

                                jQuery.event.trigger({
                                    type: "newBimShape",
                                });

                                // add legend to map
                                //map.legendHeatmap.addTo(map.defaultMapRef);
                                //map.eventsOnMap.push(heatmap);
                                var mapControlsContainer = document.getElementsByClassName("leaflet-control")[0];

                                var bimShapeLegendColors = L.control({ position: 'bottomleft' });

                                bimShapeLegendColors.onAdd = function (map) {
                                    var div = L.DomUtil.create('div', 'info legend');
                                    div.innerHTML += " <img src=" + legendBimFilePath + " height='100%'" + '<br>';
                                    return div;
                                };

                                bimShapeLegendColors.addTo(map.defaultMapRef);
                                //  map.eventsOnMap.push(heatmap);

                                event.legendColors = bimShapeLegendColors;
                                map.eventsOnMap.push(event);

                                loadingDiv.empty();
                                loadingDiv.append(loadOkText);

                                parHeight = loadOkText.height();
                                parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                loadOkText.css("margin-top", parMarginTop + "px");

                                setTimeout(function () {
                                    loadingDiv.css("opacity", 0);
                                    setTimeout(function () {
                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function () {
                                            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                        });
                                        loadingDiv.remove();
                                    }, 350);
                                }, 1000);

                                if (eventGenerator) {
                                    eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                                    eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("font-weight", "bold");
                                    eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("color", eventGenerator.attr("data-activeFontColor"));
                                    if (eventGenerator.parents("div.gisMapPtrContainer").find('a.gisPinLink').attr("data-symbolMode") === 'auto') {
                                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").html("near_me");
                                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("color", "white");
                                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("text-shadow", "2px 2px 4px black");
                                    } else {
                                        //Evidenziazione che gli eventi di questa query sono su mappa in caso di icona custom
                                        eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").show();
                                        eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").css("height", "100%");
                                    }

                                    eventGenerator.show();
                                }
                            } catch(err) {
                                loadingDiv.empty();
                                loadingDiv.append(loadKoText);

                                parHeight = loadKoText.height();
                                parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                loadKoText.css("margin-top", parMarginTop + "px");
                                console.log("Error: " + err);
                                setTimeout(function () {
                                    loadingDiv.css("opacity", 0);
                                    setTimeout(function () {
                                        loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                            $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                        });
                                        loadingDiv.remove();
                                    }, 350);
                                }, 1000);
                            }

                        });

                    } else {
                        gisLayersOnMap[event.descBim] = "loadError";

                        loadingDiv.empty();
                        loadingDiv.append(loadKoText);

                        parHeight = loadKoText.height();
                        parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                        loadKoText.css("margin-top", parMarginTop + "px");

                        setTimeout(function () {
                            loadingDiv.css("opacity", 0);
                            setTimeout(function () {
                                loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                    $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                });
                                loadingDiv.remove();
                            }, 350);
                        }, 1000);

                        if (eventGenerator) {
                            eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                            eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").show();

                            setTimeout(function () {
                                eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").hide();
                                eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").attr("data-onMap", "false");
                                eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").show();
                            }, 1500);
                        }

                        console.log("Error in getting GeoJSON from ServiceMap");
                        console.log(JSON.stringify(geoJsonData));
                    }
                });

                getSmartCityAPIData.fail(function (errorData) {
                    gisLayersOnMap[event.descBim] = "loadError";

                    loadingDiv.empty();
                    loadingDiv.append(loadKoText);

                    parHeight = loadKoText.height();
                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                    loadKoText.css("margin-top", parMarginTop + "px");

                    setTimeout(function () {
                        loadingDiv.css("opacity", 0);
                        setTimeout(function () {
                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                            });
                            loadingDiv.remove();
                        }, 350);
                    }, 1000);

                    if (eventGenerator) {
                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                        eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").show();

                        setTimeout(function () {
                            eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadErrorIcon").hide();
                            eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").attr("data-onMap", "false");
                            eventGenerator.parents("div.gisMapPtrContainer").find("a.gisPinLink").show();
                        }, 1500);
                    }

                    console.log("Error in getting GeoJSON Shapes from ServiceMap");
                    console.log(JSON.stringify(errorData));
                });

            }

            if (addMode === 'additive') {
                addBimShapeEventToMap();
            }

            if (addMode === 'exclusive') {
                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if (map.eventsOnMap[i].eventType !== 'bimShapeEvent') {
                        map.defaultMapRef.eachLayer(function (layer) {
                            map.defaultMapRef.removeLayer(layer);
                        });
                        map.eventsOnMap.length = 0;
                        break;
                    }
                }
                //Remove WidgetAlarm active pins
                $.event.trigger({
                    type: "removeAlarmPin",
                });
                //Remove WidgetEvacuationPlans active pins
                $.event.trigger({
                    type: "removeEvacuationPlanPin",
                });
                //Remove WidgetEvents active pins
                $.event.trigger({
                    type: "removeEventFIPin",
                });
                //Remove WidgetResources active pins
                $.event.trigger({
                    type: "removeResourcePin",
                });
                //Remove WidgetOperatorEvents active pins
                $.event.trigger({
                    type: "removeOperatorEventPin",
                });
                //Remove WidgetTrafficEvents active pins
                $.event.trigger({
                    type: "removeTrafficEventPin",
                });
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                    maxZoom: leafletMaxZoom,
                    maxNativeZoom: leafletNativeMaxZoom
                }).addTo(map.defaultMapRef);

                addBimShapeEventToMap();
            }

            //  resizeMapView(map.defaultMapRef);
        }
    });

    $(document).on('removeBimShape', function (event) {

        function removeBimShape(resetPageFlag) {
            if (geoJsonLayerShape !== null) {
                map.defaultMapRef.removeLayer(geoJsonLayerShape);
            }
        }

        if (event.target === map.mapName) {
            //    bimShapeOnMap = false;
            //    animationFlag = false;
            for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                if (map.eventsOnMap[i] && map.eventsOnMap[i].eventType && map.eventsOnMap[i].eventType === 'bimShapeEvent') {
                    removeBimShape(true);
                    map.eventsOnMap.splice(i, 1);
                } else if (map.eventsOnMap[i] && map.eventsOnMap[i].type && map.eventsOnMap[i].type === 'addBimShape') {
                    removeBimShapeColorLegend(i, true);
                    map.eventsOnMap.splice(i, 1);
                }
            }
        }

    });

    $(document).on('removeAlarm', function (event) {
        if (event.target === map.mapName) {
            let passedData = event.passedData;

            for (let j = 0; j < passedData.length; j++) {

                let lng = passedData[j].lng;
                let lat = passedData[j].lat;
                let eventType = passedData[j].eventType;
                let eventName = passedData[j].eventName;

                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if ((map.eventsOnMap[i].lng === lng) && (map.eventsOnMap[i].lat === lat) && (map.eventsOnMap[i].eventType === eventType) && (map.eventsOnMap[i].eventName === eventName)) {
                        map.defaultMapRef.removeLayer(map.eventsOnMap[i].marker);
                        map.eventsOnMap.splice(i, 1);
                    }
                }
            }

            if (lastPopup !== null) {
                lastPopup.closePopup();
            }
            //console.log(map.eventsOnMap.length);

            //   resizeMapView(map.defaultMapRef);
        }
    });
    $(document).on('removeEvacuationPlans', function (event) {
        if (event.target === map.mapName) {
            if (lastPopup !== null) {
                lastPopup.closePopup();
            }

            for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                if (map.eventsOnMap[i].eventType === 'evacuationPlan') {
                    map.defaultMapRef.removeLayer(map.eventsOnMap[i].polyGroup);
                    map.eventsOnMap.splice(i, 1);
                    //    resizeMapView(map.defaultMapRef);
                }
            }
            //console.log(map.eventsOnMap.length);
        }
    });
    $(document).on('removeSelectorPin', function (event) {
        if (event.target === map.mapName) {
            var passedData = event.passedData;

            var desc = passedData.desc;
            var display = passedData.display;

            if (desc == "") {
                desc = passedData.query;
            }

            if (stopGeometryAjax.hasOwnProperty(desc)) {
                stopGeometryAjax[desc] = true;
            }

            if (display !== 'geometries') {
                if (gisLayersOnMap[desc] && gisLayersOnMap[desc] !== "loadError") {
                    map.defaultMapRef.removeLayer(gisLayersOnMap[desc]);
                    for (var layer in gisLayersOnMap[desc]._layers) {
                        oms.removeMarker(gisLayersOnMap[desc]._layers[layer]);
                    }
                    if (gisGeometryLayersOnMap.hasOwnProperty(desc)) {
                        if (gisGeometryLayersOnMap[desc].length > 0) {
                            for (var i = 0; i < gisGeometryLayersOnMap[desc].length; i++) {
                                map.defaultMapRef.removeLayer(gisGeometryLayersOnMap[desc][i]);
                            }
                            delete gisGeometryLayersOnMap[desc];
                        }
                    }
                }
                delete gisLayersOnMap[desc];
            }
            else {
                if (gisGeometryLayersOnMap.hasOwnProperty(desc)) {
                    if (gisGeometryLayersOnMap[desc].length > 0) {
                        for (var i = 0; i < gisGeometryLayersOnMap[desc].length; i++) {
                            map.defaultMapRef.removeLayer(gisGeometryLayersOnMap[desc][i]);
                        }
                        delete gisGeometryLayersOnMap[desc];
                    }
                }
            }

            delete gisGeometryTankForFullscreen[desc];

            for (i = map.eventsOnMap.length - 1; i >= 0; i--) {
                if (!map.eventsOnMap[i]) continue;
                if ((map.eventsOnMap[i].eventType === 'selectorEvent') && (map.eventsOnMap[i].desc === desc)) {
                    map.eventsOnMap.splice(i, 1);
                }
            }

            //console.log(map.eventsOnMap.length);

            //  resizeMapView(map.defaultMapRef);
        }
    });
    $(document).on('removeBubbles', function (event) {
        if (event.target === map.mapName) {
            var passedData = event.passedData;

            var desc = passedData.desc;
            var display = passedData.display;

            if (desc == "") {
                desc = passedData.query;
            }

            map.defaultMapRef.removeLayer(bubbles[desc]);

            /*     if (stopGeometryAjax.hasOwnProperty(desc)) {
                     stopGeometryAjax[desc] = true;
                 }

                 if (display !== 'geometries') {
                     if (gisLayersOnMap[desc] && gisLayersOnMap[desc] !== "loadError") {
                         map.defaultMapRef.removeLayer(gisLayersOnMap[desc]);

                         if (gisGeometryLayersOnMap.hasOwnProperty(desc)) {
                             if (gisGeometryLayersOnMap[desc].length > 0) {
                                 for (var i = 0; i < gisGeometryLayersOnMap[desc].length; i++) {
                                     map.defaultMapRef.removeLayer(gisGeometryLayersOnMap[desc][i]);
                                 }
                                 delete gisGeometryLayersOnMap[desc];
                             }
                         }
                     }
                     delete gisLayersOnMap[desc];
                 }
                 else {
                     if (gisGeometryLayersOnMap.hasOwnProperty(desc)) {
                         if (gisGeometryLayersOnMap[desc].length > 0) {
                             for (var i = 0; i < gisGeometryLayersOnMap[desc].length; i++) {
                                 map.defaultMapRef.removeLayer(gisGeometryLayersOnMap[desc][i]);
                             }
                             delete gisGeometryLayersOnMap[desc];
                         }
                     }
                 }

                 delete gisGeometryTankForFullscreen[desc];  */

            for (i = map.eventsOnMap.length - 1; i >= 0; i--) {
                if (!map.eventsOnMap[i]) continue;
                if ((map.eventsOnMap[i].eventType === 'selectorEvent') && (map.eventsOnMap[i].desc === desc)) {
                    map.eventsOnMap.splice(i, 1);
                }
            }

            //console.log(map.eventsOnMap.length);

            //  resizeMapView(map.defaultMapRef);
        }
    });
    $(document).on('removeEventFI', function (event) {
        if (event.target === map.mapName) {
            let passedData = event.passedData;

            for (let j = 0; j < passedData.length; j++) {

                let lng = passedData[j].lng;
                let lat = passedData[j].lat;
                let eventType = passedData[j].eventType;
                let eventName = passedData[j].name;

                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if ((map.eventsOnMap[i].lng === lng) && (map.eventsOnMap[i].lat === lat) && (map.eventsOnMap[i].eventType === eventType) && (map.eventsOnMap[i].name === eventName)) {
                        map.defaultMapRef.removeLayer(map.eventsOnMap[i].marker);
                        map.eventsOnMap.splice(i, 1);
                    }
                }
            }

            if (lastPopup !== null) {
                lastPopup.closePopup();
            }
            //console.log(map.eventsOnMap.length);

            //  resizeMapView(map.defaultMapRef);
        }
    });
    $(document).on('removeResource', function (event) {
        if (event.target === map.mapName) {
            let passedData = event.passedData;

            for (let j = 0; j < passedData.length; j++) {

                let lng = passedData[j].lng;
                let lat = passedData[j].lat;
                let eventName = passedData[j].eventName;
                let eventType = passedData[j].eventType;

                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if ((map.eventsOnMap[i].lng === lng) && (map.eventsOnMap[i].lat === lat) && (map.eventsOnMap[i].eventType === eventType) && (map.eventsOnMap[i].eventName === eventName)) {
                        map.defaultMapRef.removeLayer(map.eventsOnMap[i].marker);
                        map.eventsOnMap.splice(i, 1);
                    }
                }
            }

            if (lastPopup !== null) {
                lastPopup.closePopup();
            }
            //console.log(map.eventsOnMap.length);

            //   resizeMapView(map.defaultMapRef);
        }
    });
    $(document).on('removeOperatorEvent', function (event) {
        if (event.target === map.mapName) {
            let passedData = event.passedData;

            for (let j = 0; j < passedData.length; j++) {

                let lng = passedData[j].lng;
                let lat = passedData[j].lat;
                let eventType = passedData[j].eventType;
                let eventName = passedData[j].name;

                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if ((map.eventsOnMap[i].lng === lng) && (map.eventsOnMap[i].lat === lat) && (map.eventsOnMap[i].eventType === eventType) && (map.eventsOnMap[i].name === eventName)) {
                        map.defaultMapRef.removeLayer(map.eventsOnMap[i].marker);
                        map.eventsOnMap.splice(i, 1);
                    }
                }
            }

            if (lastPopup !== null) {
                lastPopup.closePopup();
            }
            //console.log(map.eventsOnMap.length);

            //  resizeMapView(map.defaultMapRef);
        }
    });

    $(document).on('removeGeoInfoPin', function (event) {
        if (event.target === map.mapName) {
            let passedData = event.passedData;

            for (let j = 0; j < passedData.length; j++) {

                let lng = passedData[j].lng;
                let lat = passedData[j].lat;
                let id = passedData[j].id;
                let eventType = passedData[j].eventType;

                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if ((map.eventsOnMap[i].lng === lng) && (map.eventsOnMap[i].lat === lat) && (map.eventsOnMap[i].eventType === eventType) && (map.eventsOnMap[i].id === id)) {
                        map.defaultMapRef.removeLayer(map.eventsOnMap[i].marker);
                        map.eventsOnMap.splice(i, 1);
                    }
                }
            }

            if (lastPopup !== null) {
                lastPopup.closePopup();
            }
            //console.log(map.eventsOnMap.length);

            //  resizeMapView(map.defaultMapRef);
        }
    });

    $(document).on('removeCustomTrajectory', function (event) {
        //console.log("removeCustomTRajectory sent")
        if (event.target === map.mapName) {
            let passedData = event.passedData;
            //console.log(map.eventsOnMap.length);
            for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                //console.log(map.eventsOnMap[i]); //cerco gli enventi gisusti sulla mappa
                if (map.eventsOnMap[i][0].eventType === event.passedData[0].eventType && map.eventsOnMap[i][0].id === event.passedData[0].id) {
                    for (marker of map.eventsOnMap[i].markers) { //rimuovo i marker
                        map.defaultMapRef.removeLayer(marker);
                        //map.eventsOnMap.splice(i, 1);
                    }
                    for (trajects of map.eventsOnMap[i].trajects) { // e le traiettorie
                        map.defaultMapRef.removeLayer(trajects);
                        //map.eventsOnMap.splice(i, 1);
                    }
                    for (controls of map.eventsOnMap[i].controls) { // e i routing controlsssss
                        controls.remove(); //map.defaultMapRef.removeLayer(trajects);
                        //map.eventsOnMap.splice(i, 1);
                    }
                }
            }
        }
    });

    $(document).on('removeTrafficEvent', function (event) {
        if (event.target === map.mapName) {
            let passedData = event.passedData;

            for (let j = 0; j < passedData.length; j++) {

                let lng = passedData[j].lng;
                let lat = passedData[j].lat;
                let eventType = passedData[j].eventType;
                let eventName = passedData[j].eventName;

                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                    if ((map.eventsOnMap[i].lng === lng) && (map.eventsOnMap[i].lat === lat) && (map.eventsOnMap[i].eventType === eventType) && (map.eventsOnMap[i].eventName === eventName)) {
                        map.defaultMapRef.removeLayer(map.eventsOnMap[i].marker);
                        map.eventsOnMap.splice(i, 1);
                    }
                }
            }

            if (lastPopup !== null) {
                lastPopup.closePopup();
            }

            //console.log(map.eventsOnMap.length);

            //  resizeMapView(map.defaultMapRef);
        }
    });
    $(document).on('removeTrafficRealTimeDetails', function (event) {
        if (event.target === map.mapName) {

            for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                if (map.eventsOnMap[i].eventType === "trafficRealTimeDetails") {
                    map.defaultMapRef.removeLayer(map.eventsOnMap[i].marker);
                    map.defaultMapRef.removeControl(map.eventsOnMap[i].legend);
                    map.defaultMapRef.removeLayer(map.eventsOnMap[i].trafficLayer);
                    map.eventsOnMap.splice(i, 1);
                }
            }

            //  resizeMapView(map.defaultMapRef);
        }
    });
    $(document).on('removeHeatmap', function (event) {

        function removeHeatmap(resetPageFlag) {
            if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
                if (resetPageFlag == true) {
                    current_page = 0;     // CTR SE VA BENE BISOGNA DISTINGUERE IL CASO CHE SI STIA NAVIGANDO LA STESSA HEATMAP_NAME OPPURE UN'ALTRA NUOVA HEATMP_NAME
                    current_radius = null;
                    current_opacity = null;
                    changeRadiusOnZoom = false;
                    estimateRadiusFlag = false;
                    estimatedRadius = null;
                    wmsDatasetName = null;
                }
                map.testData = [];
                map.heatmapLayer.setData({ data: [] });
                map.defaultMapRef.removeLayer(map.heatmapLayer);
                if (resetPageFlag != true) {
                    if (map.cfg["radius"] != current_radius) {
                        setOption('radius', current_radius, 1);
                    }
                    if (map.cfg["maxOpacity"] != current_opacity) {
                        setOption('maxOpacity', current_opacity, 2);
                    }
                }
                map.defaultMapRef.removeControl(map.legendHeatmap);
                /*    if(map.heatmapLegendColors) {
                        map.defaultMapRef.removeControl(map.heatmapLegendColors);
                    }*/
            } else {    // NEW WMS HEATMAP
                if (resetPageFlag == true) {
                    current_page = 0;
                }
                map.defaultMapRef.removeLayer(wmsLayer);
                map.defaultMapRef.removeControl(map.legendHeatmap);
            }
        }

        function removeHeatmapColorLegend(index, resetPageFlag) {
            if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
                if (resetPageFlag == true) {
                    current_page = 0;     // CTR SE VA BENE BISOGNA DISTINGUERE IL CASO CHE SI STIA NAVIGANDO LA STESSA HEATMAP_NAME OPPURE UN'ALTRA NUOVA HEATMP_NAME
                    current_radius = null;
                    current_opacity = null;
                    changeRadiusOnZoom = false;
                    estimateRadiusFlag = false;
                    estimatedRadius = null;
                    wmsDatasetName = null;
                }
                map.testData = [];
                map.heatmapLayer.setData({ data: [] });
                map.defaultMapRef.removeLayer(map.heatmapLayer);
                if (resetPageFlag != true) {
                    if (map.cfg["radius"] != current_radius) {
                        setOption('radius', current_radius, 1);
                    }
                    if (map.cfg["maxOpacity"] != current_opacity) {
                        setOption('maxOpacity', current_opacity, 2);
                    }
                }
                map.defaultMapRef.removeControl(map.eventsOnMap[index].legendColors);
            } else {    // NEW WMS HEATMAP
                if (resetPageFlag == true) {
                    current_page = 0;
                }
                map.defaultMapRef.removeControl(map.eventsOnMap[index].legendColors);
                map.defaultMapRef.removeLayer(wmsLayer);
            }
        }

        if (event.target === map.mapName) {
            for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                if (event.isTrafficHeatmap) {
                    // rimuovi traffic heatmap
                    if (map.eventsOnMap[i].eventType === 'traffic_heatmap') {
                        if (trafficWmsLayer != null) {
                            map.defaultMapRef.removeLayer(trafficWmsLayer);
                            trafficWmsLayer = null;
                        } else if (newTfrLayer != null) {
                            map.defaultMapRef.removeLayer(newTfrLayer);
                            newTfrLayer = null;
                        }
                        map.defaultMapRef.removeControl(map.trafficLegendHeatmap);
                        map.defaultMapRef.removeControl(map.eventsOnMap[i + 1].legendColors);
                        map.eventsOnMap.splice(i, 2);
                        break;
                    } else if (map.eventsOnMap[i]._url && map.eventsOnMap[i]._url.includes("animate")) {
                        map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                        map.defaultMapRef.removeControl(map.trafficLegendHeatmap);
                        map.defaultMapRef.removeControl(map.eventsOnMap[i + 1].legendColors);
                        map.eventsOnMap.splice(i, 2);
                        break;
                    }

                } else if (i > 0 && map.eventsOnMap[i - 1].eventType === 'traffic_heatmap') {
                    // logica per evitare di rimuovere layer di trafficflowmanager
                } else if (map.eventsOnMap[i].eventType === 'traffic_heatmap') {
                    // logica per evitare di rimuovere layer di trafficflowmanager
                } else if (i > 0 && map.eventsOnMap[i - 1]._url && map.eventsOnMap[i - 1]._url.includes("animate") && map.eventsOnMap[i - 1].options.pane.includes("TrafficFlowManager")) {
                    // logica per evitare di rimuovere layer di trafficflowmanager
                } else if (map.eventsOnMap[i]._url && map.eventsOnMap[i]._url.includes("animate") && map.eventsOnMap[i].options.pane.includes("TrafficFlowManager")) {
                    // logica per evitare di rimuovere layer di trafficflowmanager
                } else if (map.eventsOnMap[i].eventType === 'heatmap') {
                    removeHeatmap(true);
                    map.eventsOnMap.splice(i, 1);
                } else if (map.eventsOnMap[i].type === 'addHeatmap') {
                    removeHeatmapColorLegend(i, true);
                    map.eventsOnMap.splice(i, 1);
                } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                    if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails') {
                        map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                        map.eventsOnMap.splice(i, 1);
                        removeHeatmap(true);
                    }
                }
            }
        }
        map.defaultMapRef.off('click', heatmapClick);
    });

    $(document).on('removeOD', function (event) {

        function removeOd(resetPageFlag) {
            if (resetPageFlag == true) {
                current_page = 0;
            }
            if (geojson_layer !== null) {
                map.defaultMapRef.removeLayer(geojson_layer);
            }
            if (geojson_layer_all !== null) {
                map.defaultMapRef.removeLayer(geojson_layer_all);
            }
            if (sourcePolygon !== null) {
                map.defaultMapRef.removeLayer(sourcePolygon);
            }
            map.defaultMapRef.removeControl(map.legendOd);
            map.defaultMapRef.removeControl(map.flowInfo);
        }

        function removeOdColorLegend(index, resetPageFlag) {
            if (resetPageFlag == true) {
                current_page = 0;
            }
            map.defaultMapRef.removeControl(map.eventsOnMap[index].legendColors);
        }

        if (event.target === map.mapName) {
            odOnMap = false;
            animationFlag = false;
            for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                if (map.eventsOnMap[i].eventType === 'od') {
                    removeOd(true);
                    map.eventsOnMap.splice(i, 1);
                } else if (map.eventsOnMap[i].type === 'addOD') {
                    removeOdColorLegend(i, true);
                    map.eventsOnMap.splice(i, 1);
                } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                    if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails') {
                        map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                        map.eventsOnMap.splice(i, 1);
                        removeOd(true);
                    }
                }
            }
        }
        map.defaultMapRef.off('click', odmapClick);
        if (nodeRedClick != null) {
            map.defaultMapRef.on('click', nodeRedClick);
        }
        $(document).off('newOdTargetData', newOdTargetData);
        $(document).off('newOdSourceData', newOdSourceData);
        map.defaultMapRef.off('zoomend', showAllPolyOdMapZoomend);
        map.defaultMapRef.off('moveend', showAllPolyOdMapMoveend);
        map.defaultMapRef.off('newOdDatetime', newOdDateTimeFunc);

    });

    $(document).on('toggleAddMode', function (event) {
        addMode = event.addMode;
        //console.log(addMode);
    });

            }

    // Funzione che risponde all'evento resize del widget, indotto o dal ridimensionatore manuale dell'editor di dashboard oppure dalla dashboard stessa in modalità responsive
    function resizeWidget() {
        setWidgetLayout(hostFile, widgetName, widgetContentColor, widgetHeaderColor, widgetHeaderFontColor, showHeader, headerHeight, hasTimer);
    }

    //Fine definizioni di funzione

    //Inizio del main script

    /*IMPORTANTE - Chiamata al modulo server che reperisce i parametri di costruzione del widget dal database (tipicamente
    * da tabella Config_widget_dashboard, la quale memorizza un record per ogni istanza di widget. Tale record viene scritto
    * quando il widget viene creato
    */
    //////////
    const currentURI = window.location.href;
    // Controlla se contiene la stringa "preview.php"
    const containsPreview = currentURI.includes("preview.php");
    // Stampa il risultato del controllo
    console.log(containsPreview);
    if (containsPreview) {
        //widgetData.params = null;
        var latLng = "<?= escapeForJS($_REQUEST['latLng']) ?>";
        //Parametri di costruzione del widget (struttura e aspetto)
        showTitle = '';
        widgetContentColor = "rgba(255,255,255,1)";
        fontSize = null;
        fontColor = null;
        hasTimer = "no";
        chartColor = null;
        dataLabelsFontSize = null;
        dataLabelsFontColor = null;
        chartLabelsFontSize = null;
        chartLabelsFontColor = null;
        appId = null;
        flowId = null;
        nodeId = null;
        nrMetricType = null;
        sm_based = "no";
        rowParameters = null;
        sm_field = null;
        addMode = "additive";
        enableFullscreenModal = "yes";
        enableFullscreenTab = "no";
        geoServerUrl = 'https://wmsserver.snap4city.org/';
        heatmapUrl = 'https://heatmap.snap4city.org/';
        nodeRedInputName = null;
        nrInputId = null;
        code = null;
        metricName = "<?= escapeForJS($_REQUEST['id_metric']) ?>";
        widgetTitle = "Selector - Map";
        widgetHeaderColor = "rgba(51,204,255,1)";
        widgetHeaderFontColor = "rgba(255,255,255,1)";
        sizeRowsWidget = 75;
        styleParameters = null;
        //widgetParameters = JSON.parse("{\"latLng\":[43.76971,11.255751],\"zoom\":8}");
        widgetParameters = JSON.parse("{\"latLng\":" + latLng + ",\"zoom\":10}");
        wsConnect = null;
        console.log('metricName: ' + metricName);
        $('#' + mapOptionsDivName).hide();


        setWidgetLayout(hostFile, widgetName, widgetContentColor, widgetHeaderColor, widgetHeaderFontColor, showHeader, headerHeight, hasTimer);
        $('#<?= str_replace('.', ' _ ', str_replace(' - ', '  _ ', $_REQUEST[' name_w '])) ?>_div').parents('li.gs_w').off('resizeWidgets');
        $('#<?= str_replace('.  ', ' _ ', str_replace(' - ', ' _ ', $_REQUEST[' name_w '])) ?>_div').parents('li.gs_w').on('resizeWidgets', resizeWidget);


        $("#" + widgetName + "_buttonsDiv").css("height", "100%");
        $("#" + widgetName + "_buttonsDiv").css("float", "left");
        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(2).css("font-size", "20px");
        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(2).hover(function () {
            $(this).find("span").css("color", "red");
        }, function () {
            $(this).find("span").css("color", widgetHeaderFontColor);
        });
        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(3).css("font-size", "20px");
        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(3).hover(function () {
            $(this).find("span").css("color", "red");
        }, function () {
            $(this).find("span").css("color", widgetHeaderFontColor);
        });
        console.log('hostFile: ' + hostFile);
        if (hostFile === "config") {
            if ((enableFullscreenModal === 'yes') && (enableFullscreenTab === 'yes')) {
                $("#" + widgetName + "_buttonsDiv").css("width", "50px");
                titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 50 - 25 - 2));
                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).show();
                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).show();
            } else {
                if ((enableFullscreenModal === 'yes') && (enableFullscreenTab === 'no')) {
                    $("#" + widgetName + "_buttonsDiv").css("width", "25px");
                    titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 25 - 25 - 2));
                    $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).show();
                    $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).hide();
                } else {
                    if ((enableFullscreenModal === 'no') && (enableFullscreenTab === 'yes')) {
                        $("#" + widgetName + "_buttonsDiv").css("width", "25px");
                        titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 25 - 25 - 2));
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).hide();
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).show();
                    } else {
                        $("#" + widgetName + "_buttonsDiv").css("width", "0px");
                        $("#" + widgetName + "_buttonsDiv").hide();
                        titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 0 - 25 - 2));
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).hide();
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).hide();
                    }
                }
            }
        } else {
            if ((enableFullscreenTab === 'yes') && (enableFullscreenModal === 'yes')) {
                $("#" + widgetName + "_buttonsDiv").css("width", "50px");
                titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 50 - 2));
                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).show();
                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).show();
            } else {
                if ((enableFullscreenTab === 'yes') && (enableFullscreenModal === 'no')) {
                    $("#" + widgetName + "_buttonsDiv").css("width", "25px");
                    titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 25 - 2));
                    $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).hide();
                    $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).show();
                } else {
                    if ((enableFullscreenTab === 'no') && (enableFullscreenModal === 'yes')) {
                        $("#" + widgetName + "_buttonsDiv").css("width", "25px");
                        titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 25 - 2));
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).show();
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).hide();
                    } else {
                        $("#" + widgetName + "_buttonsDiv").hide();
                        titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 2));
                    }
                }
            }
        }

        $("#" + widgetName + "_titleDiv").css("width", titleWidth + "px");

        if (firstLoad === false) {
            showWidgetContent(widgetName);
        } else {
            setupLoadingPanel(widgetName, widgetContentColor, firstLoad);
        }
        populateWidget();
        nodeRedClick = function (e) {
            let eventJson = new Object();
            eventJson.latitude = e.latlng.lat;
            eventJson.longitude = e.latlng.lng;
            currentValue = JSON.stringify(eventJson);
            if (nodeId != null) {
                triggerEventOnIotApp(map.defaultMapRef, currentValue);
            }
        }
        if (metricName != 'Map' && nodeId != null) {
            map.defaultMapRef.on('click', nodeRedClick)
        }
        setTimeout(function () {
            map.default3DMapRef = initMapsAndListeners(map);
            setTimeout(function () {
                if (defaultOrthomapMenuItem != null) {
                    if (defaultOrthomapMenuItem.id != null) {
                        if (defaultOrthomapMenuItem.external == true) {
                            $('#defaultMap').addClass('hidden');
                        }
                        $('#' + defaultOrthomapMenuItem.id).removeClass('hidden');
                    }
                }
            }, 500);
        }, 3000);
    } else {

        //////////
        $.ajax({
            //    url: "../controllers/getWidgetParams.php",
            url: "../widgets/getParametersWidgets.php",
            type: "GET",
            data: {
                //   widgetName: "<?= str_replace('.', '_', str_replace('-', '_', escapeForJS($_REQUEST['name_w']))) ?>"
                nomeWidget: ["<?= str_replace('.', '_', str_replace('-', '_', escapeForJS($_REQUEST['name_w']))) ?>"]
            },
            async: true,
            dataType: 'json',
            success: function (widgetData) {
                widgetData.params = widgetData.param;
                //Parametri di costruzione del widget (struttura e aspetto)
                showTitle = widgetData.params.showTitle;
                widgetContentColor = widgetData.params.color_w;
                fontSize = widgetData.params.fontSize;
                fontColor = widgetData.params.fontColor;
                hasTimer = widgetData.params.hasTimer;
                chartColor = widgetData.params.chartColor;
                dataLabelsFontSize = widgetData.params.dataLabelsFontSize;
                dataLabelsFontColor = widgetData.params.dataLabelsFontColor;
                chartLabelsFontSize = widgetData.params.chartLabelsFontSize;
                chartLabelsFontColor = widgetData.params.chartLabelsFontColor;
                appId = widgetData.params.appId;
                flowId = widgetData.params.flowId;
                nodeId = widgetData.params.nodeId;
                nrMetricType = widgetData.params.nrMetricType;
                sm_based = widgetData.params.sm_based;
                rowParameters = widgetData.params.rowParameters;
                sm_field = widgetData.params.sm_field;
                addMode = widgetData.params.viewMode;
                enableFullscreenModal = widgetData.params.enableFullscreenModal;
                enableFullscreenTab = widgetData.params.enableFullscreenTab;
                geoServerUrl = widgetData.geoServerUrl;
                heatmapUrl = widgetData.heatmapUrl;
                nodeRedInputName = widgetData.params.name;
                nrInputId = widgetData.params.nrInputId;
                code = widgetData.params.code;
                connections = widgetData.params.connections;
                widgetParams = widgetData.params;

                getOrganizationParams(function (params) {
                    orgParams = params[0];
                });

                //    if (rowParameters && !JSON.parse(rowParameters).type.includes("remove")) {
                if (rowParameters) {
                    checkAndViewFromNR(rowParameters);
                }

                if (widgetData.params.infoJson != "yes") {
                    $('#' + mapOptionsDivName).hide();
                }

                if (((embedWidget === true) && (embedWidgetPolicy === 'auto')) || ((embedWidget === true) && (embedWidgetPolicy === 'manual') && (showTitle === "no")) || ((embedWidget === false) && (showTitle === "no"))) {
                    showHeader = false;
                }
                else {
                    showHeader = true;
                }

                metricName = "<?= escapeForJS($_REQUEST['id_metric']) ?>";
                widgetTitle = widgetData.params.title_w;
                widgetHeaderColor = widgetData.params.frame_color_w;
                widgetHeaderFontColor = widgetData.params.headerFontColor;
                sizeRowsWidget = parseInt(widgetData.params.size_rows);
                styleParameters = JSON.parse(widgetData.params.styleParameters);
                widgetParameters = JSON.parse(widgetData.params.parameters);
                wsConnect = widgetParameters.wsConnect;

                // if (metricName != 'Map' && nodeId != null) {
                if (nodeId != null) {
                    openWs(widgetName);
                }
                if (socket == null && wsConnect == "yes") {
                    newWSConnect();
                }

                setWidgetLayout(hostFile, widgetName, widgetContentColor, widgetHeaderColor, widgetHeaderFontColor, showHeader, headerHeight, hasTimer);

                $('#<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_div').parents('li.gs_w').off('resizeWidgets');
                $('#<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_div').parents('li.gs_w').on('resizeWidgets', resizeWidget);

                if (widgetParameters.mode && widgetParameters.mode == "ckeditor" && widgetData.params.code != null && widgetData.params.code != "null") {
                    code = widgetData.params.code;
                    var text_ck_area = document.createElement("text_ck_area");
                    text_ck_area.innerHTML = code;
                    var newInfoDecoded = text_ck_area.innerText;
                    newInfoDecoded = newInfoDecoded.replaceAll("function execute()", "function execute_" + "<?= $_REQUEST['name_w'] ?>(param)");

                    var elem = document.createElement('script');
                    elem.type = 'text/javascript';
                    // elem.id = "<?= $_REQUEST['name_w'] ?>_code";
                    // elem.src = newInfoDecoded;
                    elem.innerHTML = newInfoDecoded;
                    try {
                        $('#<?= $_REQUEST['name_w'] ?>_code').append(elem);
                    } catch (e) {
                        console.log("Error in appending JS function to DOM on " + widgetName);
                    }

                    $('#<?= $_REQUEST['name_w'] ?>_code').css("display", "none");
                }
                ////////////////////////////////////

                $("#" + widgetName + "_buttonsDiv").css("height", "100%");
                $("#" + widgetName + "_buttonsDiv").css("float", "left");

                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(2).css("font-size", "20px");
                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(2).hover(function () {
                    $(this).find("span").css("color", "red");
                }, function () {
                    $(this).find("span").css("color", widgetHeaderFontColor);
                });
                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(3).css("font-size", "20px");
                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(3).hover(function () {
                    $(this).find("span").css("color", "red");
                }, function () {
                    $(this).find("span").css("color", widgetHeaderFontColor);
                });

                if (hostFile === "config") {
                    if ((enableFullscreenModal === 'yes') && (enableFullscreenTab === 'yes')) {
                        $("#" + widgetName + "_buttonsDiv").css("width", "50px");
                        titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 50 - 25 - 2));
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).show();
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).show();
                    }
                    else {
                        if ((enableFullscreenModal === 'yes') && (enableFullscreenTab === 'no')) {
                            $("#" + widgetName + "_buttonsDiv").css("width", "25px");
                            titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 25 - 25 - 2));
                            $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).show();
                            $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).hide();
                        }
                        else {
                            if ((enableFullscreenModal === 'no') && (enableFullscreenTab === 'yes')) {
                                $("#" + widgetName + "_buttonsDiv").css("width", "25px");
                                titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 25 - 25 - 2));
                                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).hide();
                                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).show();
                            }
                            else {
                                $("#" + widgetName + "_buttonsDiv").css("width", "0px");
                                $("#" + widgetName + "_buttonsDiv").hide();
                                titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 0 - 25 - 2));
                                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).hide();
                                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).hide();
                            }
                        }
                    }
                }
                else {
                    if ((enableFullscreenTab === 'yes') && (enableFullscreenModal === 'yes')) {
                        $("#" + widgetName + "_buttonsDiv").css("width", "50px");
                        titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 50 - 2));
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).show();
                        $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).show();
                    }
                    else {
                        if ((enableFullscreenTab === 'yes') && (enableFullscreenModal === 'no')) {
                            $("#" + widgetName + "_buttonsDiv").css("width", "25px");
                            titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 25 - 2));
                            $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).hide();
                            $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).show();
                        }
                        else {
                            if ((enableFullscreenTab === 'no') && (enableFullscreenModal === 'yes')) {
                                $("#" + widgetName + "_buttonsDiv").css("width", "25px");
                                titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 25 - 2));
                                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(0).show();
                                $("#" + widgetName + "_buttonsDiv div.singleBtnContainer").eq(1).hide();
                            }
                            else {
                                $("#" + widgetName + "_buttonsDiv").hide();
                                titleWidth = parseInt(parseInt($("#" + widgetName + "_div").width() - 25 - 2));
                            }
                        }
                    }
                }

                $("#" + widgetName + "_titleDiv").css("width", titleWidth + "px");

                if (firstLoad === false) {
                    showWidgetContent(widgetName);
                }
                else {
                    setupLoadingPanel(widgetName, widgetContentColor, firstLoad);
                }
                populateWidget();
                //   globalMapView = true;

                //if (metricName != 'Map' && nodeId != null) {
                // if (nodeId != null) {
                //     map.defaultMapRef.on('click', nodeRedClick = function(e) {
                //         //    alert('Map Clicked!');
                //         let eventJson = new Object();
                //         eventJson.latitude = e.latlng.lat;
                //         eventJson.longitude = e.latlng.lng;
                //         currentValue = JSON.stringify(eventJson);
                //         triggerEventOnIotApp(map.defaultMapRef, currentValue);
                //     })
                // }
                nodeRedClick = function (e) {
                    //    alert('Map Clicked!');
                    let eventJson = new Object();
                    eventJson.latitude = e.latlng.lat;
                    eventJson.longitude = e.latlng.lng;
                    currentValue = JSON.stringify(eventJson);
                    if (nodeId != null) {
                        triggerEventOnIotApp(map.defaultMapRef, currentValue);
                    }
                }
                if (metricName != 'Map' && nodeId != null) {
                    map.defaultMapRef.on('click', nodeRedClick)
                }
                getCoordsClick = function (e) {
                    var selectedData = {};
                    var selectedDataJson = "";
                    selectedData.event = "mapClick";
                    selectedData.coordinates = {};
                    selectedData.coordinates.latitude = e.latlng.lat;
                    selectedData.coordinates.longitude = e.latlng.lng;
                    if (connections != null) {
                        selectedData.connections = connections;
                    }
                    selectedDataJson = JSON.stringify(selectedData);
                    if (widgetParameters.mode && widgetParameters.mode == "ckeditor" && code) {
                        try {
                            execute_<?= $_REQUEST['name_w'] ?>(selectedDataJson);
                        } catch (e) {
                            console.log("Error in JS function from map click on " + widgetName);
                        }
                    }
                }
                if (widgetParameters.mode && widgetParameters.mode == "ckeditor" && widgetData.params.code != null && widgetData.params.code != "null") {
                    map.defaultMapRef.on('click', getCoordsClick);
                }

                if (widgetData.params.code != null && widgetData.params.code != "null") {
                    let code = widgetData.params.code;
                    var text_ck_area = document.createElement("text_ck_area");
                    text_ck_area.innerHTML = code;
                    var newInfoDecoded = text_ck_area.innerText;
                    newInfoDecoded = newInfoDecoded.replaceAll("function execute()", "function execute_" + "<?= $_REQUEST['name_w'] ?>(param)");

                    var elem = document.createElement('script');
                    elem.type = 'text/javascript';
                    elem.innerHTML = newInfoDecoded;
                    try {
                        $('#<?= $_REQUEST['name_w'] ?>_code').append(elem);
                        $('#<?= $_REQUEST['name_w'] ?>_code').css("display", "none");
                    } catch (e) {
                        console.log("Error in appending JS function to DOM on " + widgetName);
                    }
                }

                // parte mappa 3D - CORTI
                setTimeout(function () {
                    map.default3DMapRef = initMapsAndListeners(map);
                    setTimeout(function () {
                        if (defaultOrthomapMenuItem != null) {
                            if (defaultOrthomapMenuItem.id != null) {
                                if (defaultOrthomapMenuItem.external == true) {
                                    $('#defaultMap').addClass('hidden');
                                }
                                $('#' + defaultOrthomapMenuItem.id).removeClass('hidden');
                            }
                        }
                    }, 500);
                }, 3000);
                // hide fullscreen
                $('#<?= $_REQUEST['name_w'] ?>_buttonsDiv').addClass('hidden');

            },
            error: function (errorData) {

            }
        });
    }
    //Risponditore ad evento resize
    $("#<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>").on('customResizeEvent', function (event) {
        resizeWidget();
    });

    //Usata solo per widget con grafico Highchart al proprio interno (non è il nostro caso)
    $(document).on('resizeHighchart_' + widgetName, function (event) {
        showHeader = event.showHeader;
    });

    createFullscreenModal();

    //Avvio del conto alla rovescia per il ricaricamento periodico del widget
    //countdownRef = startCountdown(widgetName, timeToReload, <?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>, metricNameFromDriver, widgetTitleFromDriver, widgetHeaderColorFromDriver, widgetHeaderFontColorFromDriver, fromGisExternalContent, fromGisExternalContentServiceUri, fromGisExternalContentField, fromGisExternalContentRange, fromGisMarker, fromGisMapRef, fromGisFakeId);

    $('#<?= $_REQUEST['name_w'] ?>_buttonsDiv a.iconFullscreenModal').click(function () {

        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen h4.modal-title").html($("#<?= $_REQUEST['name_w'] ?>_titleDiv").html());
        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen iframe").hide();

        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen div.modalLinkOpenBodyMap").hide();
        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen div.modalLinkOpenGisMap").hide();
        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen div.modalLinkOpenBodyDefaultMap").show();


        //Creazione mappa
        setTimeout(function () {
            var mapdiv = "<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap";
            var latInit = 43.769789;
            var lngInit = 11.255694;
            //    fullscreendefaultMapRef = L.map(mapdiv).setView([43.769789, 11.255694], 11);
            //    fullscreendefaultMapRef = L.map(mapdiv).setView([43.769789, 11.255694], widgetParameters.zoom);
            if (widgetParameters.latLng[0] != null && widgetParameters.latLng[0] != '') {
                latInit = widgetParameters.latLng[0];
            }
            if (widgetParameters.latLng[1] != null && widgetParameters.latLng[1] != '') {
                lngInit = widgetParameters.latLng[1];
            }
            if (fullscreenHeatmapFirstInstantiation === false) {
                fullscreendefaultMapRef = L.map(mapdiv).setView([latInit, lngInit], widgetParameters.zoom);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                    maxZoom: leafletMaxZoom,
                    maxNativeZoom: leafletNativeMaxZoom
                }).addTo(fullscreendefaultMapRef);
                fullscreendefaultMapRef.attributionControl.setPrefix('');
                fullscreenHeatmapFirstInstantiation = true;
            }

            //Popolamento mappa (se ci sono eventi su mappa originaria)
            //if ($('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen input.fullscreenEventPoint').length > 0) {}
            if (map.eventsOnMap.length > 0) {

                for (let i = 0; i < map.eventsOnMap.length; i++) {

                    if (map.eventsOnMap[i].type === 'alarmEvent') {
                        let lat = map.eventsOnMap[i].lat;
                        let lng = map.eventsOnMap[i].lng;
                        let eventType = map.eventsOnMap[i].eventType;
                        let eventName = map.eventsOnMap[i].eventName;
                        let eventStartDate = map.eventsOnMap[i].eventStartDate;
                        let eventStartTime = map.eventsOnMap[i].eventStartTime;
                        let eventSeverity = map.eventsOnMap[i].eventSeverity;

                        //Creazione dell'icona custom per il pin
                        switch (eventSeverity) {
                            case "MINOR":
                                mapPinImg = '../img/alarmIcons/' + alarmTypes[eventType].mapIconLow;
                                severityColor = "#ffcc00";
                                break;

                            case "MAJOR":
                                mapPinImg = '../img/alarmIcons/' + alarmTypes[eventType].mapIconMed;
                                severityColor = "#ff9900";
                                break;

                            case "CRITICAL":
                                mapPinImg = '../img/alarmIcons/' + alarmTypes[eventType].mapIconHigh;
                                severityColor = "#ff6666";
                                break;
                        }

                        let pinIcon = new L.DivIcon({
                            className: null,
                            html: '<img src="' + mapPinImg + '" class="leafletPin" />',
                            iconAnchor: [18, 36]
                        });

                        let markerLocation = new L.LatLng(lat, lng);
                        let marker = new L.Marker(markerLocation, { icon: pinIcon });

                        //Creazione del popup per il pin appena creato
                        let popupText = "<span class='mapPopupTitle'>" + eventName + "</span>" +
                            "<span class='mapPopupLine'><i>Start date: </i>" + eventStartDate + " - " + eventStartTime + "</span>" +
                            "<span class='mapPopupLine'><i>Event type: </i>" + alarmTypes[eventType].desc.toUpperCase() + "</span>" +
                            "<span class='mapPopupLine'><i>Event severity: </i><span style='background-color: " + severityColor + "'>" + eventSeverity.toUpperCase() + "</span></span>";

                        fullscreendefaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [-5, -40], maxWidth: 600 }).openPopup();
                    }
                    if (map.eventsOnMap[i].eventType === 'evacuationPlan') {
                        let plansObj = map.eventsOnMap[i].plansObj;
                        let planId = map.eventsOnMap[i].planId;
                        let evacuationColors = map.eventsOnMap[i].colors;

                        shownPolyGroup = L.featureGroup();


                        for (let j = 0; j < plansObj[planId].payload.evacuation_paths.length; j++) {
                            path = [];

                            for (let i = 0; i < plansObj[planId].payload.evacuation_paths[j].coords.length; i++) {
                                let point = [];
                                point[0] = plansObj[planId].payload.evacuation_paths[j].coords[i].latitude;
                                point[1] = plansObj[planId].payload.evacuation_paths[j].coords[i].longitude;
                                path.push(point);
                            }

                            let polyline = L.polyline(path, { color: evacuationColors[j % 6] });
                            shownPolyGroup.addLayer(polyline);
                        }

                        fullscreendefaultMapRef.addLayer(shownPolyGroup);
                    }
                    if (map.eventsOnMap[i].eventType === 'selectorEvent') {

                        var mapBounds = fullscreendefaultMapRef.getBounds();
                        var query = map.eventsOnMap[i].query;
                        var targets = map.eventsOnMap[i].targets;
                        var eventGenerator = map.eventsOnMap[i].eventGenerator;
                        var color1 = map.eventsOnMap[i].color1;
                        var color2 = map.eventsOnMap[i].color2;
                        var queryType = map.eventsOnMap[i].queryType;
                        var desc = map.eventsOnMap[i].desc;
                        var display = map.eventsOnMap[i].display;

                        var re1 = '(selection)';	// Word 1
                        var re2 = '(=)';	// Any Single Character 1
                        var re3 = '([+-]?\\d*\\.\\d+)(?![-+0-9\\.])';	// Float 1
                        var re4 = '(;|%3B)';	// Any Single Character 2
                        var re5 = '([+-]?\\d*\\.\\d+)(?![-+0-9\\.])';	// Float 2
                        var re6 = '(;|%3B)?';	// Any Single Character 3
                        var re7 = '([+-]?\\d*\\.\\d+)?(?![-+0-9\\.])?';	// Float 3
                        var re8 = '(;|%3B)?';	// Any Single Character 4
                        var re9 = '([+-]?\\d*\\.\\d+)?(?![-+0-9\\.])?';	// Float 4

                        var pattern = new RegExp(re1 + re2 + re3 + re4 + re5 + re6 + re7 + re8 + re9, ["i"]);

                        if (queryType === "Default") {
                            if (map.eventsOnMap[i].query.includes("datamanager/api/v1/poidata/")) {
                                if (map.eventsOnMap[i].desc != "My POI") {
                                    myPOIId = map.eventsOnMap[i].query.split("datamanager/api/v1/poidata/")[1];
                                    apiUrl = "../controllers/myPOIProxy.php";
                                    dataForApi = myPOIId;
                                    query = map.eventsOnMap[i].query;
                                } else {
                                    apiUrl = "../controllers/myPOIProxy.php";
                                    dataForApi = "All";
                                    query = map.eventsOnMap[i].query;
                                }
                            } else if (map.eventsOnMap[i].query.includes("/iot/") && !passedData.query.includes("/api/v1/")) {
                                query = "<?= $superServiceMapProxy ?>api/v1/?serviceUri=" + map.eventsOnMap[i].query + "&format=json";
                            } else {
                                if (pattern.test(query)) {
                                    query = query.replace(pattern, "selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng);
                                } else {
                                    query = query + "&selection=" + mapBounds["_southWest"].lat + ";" + mapBounds["_southWest"].lng + ";" + mapBounds["_northEast"].lat + ";" + mapBounds["_northEast"].lng;
                                }
                                query = "<?= $superServiceMapProxy ?>" + query;
                            }
                        }
                        else if (queryType === "MyPOI") {
                            if (map.eventsOnMap[i].desc != "My POI") {
                                myPOIId = map.eventsOnMap[i].query.split("datamanager/api/v1/poidata/")[1];
                                apiUrl = "../controllers/myPOIProxy.php";
                                dataForApi = myPOIId;
                                query = map.eventsOnMap[i].query;
                            } else {
                                apiUrl = "../controllers/myPOIProxy.php";
                                dataForApi = "All";
                                query = map.eventsOnMap[i].query;
                            }

                        }
                        else {
                            query = map.eventsOnMap[i].query;
                        }

                        if (targets !== "") {
                            targets = targets.split(",");
                        }
                        else {
                            targets = [];
                        }

                        if (queryType != "MyPOI" && !map.eventsOnMap[i].query.includes("datamanager/api/v1/poidata/")) {
                            apiUrl = query + "&geometry=true&fullCount=false";
                        }

                        //    if (queryType === "Sensor" && query.includes("%2525")) {
                        if (query.includes("%2525") && !query.includes("%252525")) {
                            let queryPart1 = query.split("/resource/")[0];
                            let queryPart2 = (query.split("/resource/")[1]).split("&format=")[0];
                            let queryPart3 = query.split("&format=")[1];
                            if (queryPart3 != undefined) {
                                apiUrl = queryPart1 + "/resource/" + encodeURI(queryPart2) + "&format=" + queryPart3;
                            } else {
                                apiUrl = queryPart1 + "/resource/" + encodeURI(queryPart2);
                            }
                        }

                        $.ajax({
                            //    url: query + "&geometry=true&fullCount=false",
                            url: apiUrl,
                            type: "GET",
                            data: {},
                            async: true,
                            timeout: 0,
                            dataType: 'json',
                            success: function (geoJsonData) {
                                var fatherGeoJsonNode = null;

                                if (queryType === "Default") {
                                    var countObjKeys = 0;
                                    var objContainer = {};
                                    Object.keys(geoJsonData).forEach(function (key) {
                                        if (countObjKeys == 0) {
                                            if (geoJsonData.hasOwnProperty(key)) {
                                                fatherGeoJsonNode = geoJsonData[key];
                                            }
                                        } else {
                                            if (geoJsonData.hasOwnProperty(key)) {
                                                if (geoJsonData[key].features) {
                                                    fatherGeoJsonNode.features = fatherGeoJsonNode.features.concat(geoJsonData[key].features);
                                                }
                                            }
                                        }
                                        countObjKeys++;
                                    });
                                    /*    if (geoJsonData.hasOwnProperty("BusStops")) {
                                            fatherGeoJsonNode = geoJsonData.BusStops;
                                        }
                                        else {
                                            if (geoJsonData.hasOwnProperty("SensorSites")) {
                                                fatherGeoJsonNode = geoJsonData.SensorSites;
                                            }
                                            else {
                                                fatherGeoJsonNode = geoJsonData.Services;
                                            }
                                        }*/
                                }
                                else if (queryType === "MyPOI") {
                                    fatherGeoJsonNode.features = [];
                                    if (map.eventsOnMap[i].desc != "My POI") {
                                        fatherGeoJsonNode.features[0] = geoJsonData;
                                    } else {
                                        fatherGeoJsonNode.features = geoJsonData;
                                    }
                                    fatherGeoJsonNode.type = "FeatureCollection";
                                }
                                else {
                                    var countObjKeys = 0;
                                    var objContainer = {};
                                    Object.keys(geoJsonData).forEach(function (key) {
                                        if (countObjKeys == 0) {
                                            if (geoJsonData.hasOwnProperty(key)) {
                                                fatherGeoJsonNode = geoJsonData[key];
                                            }
                                        } else {
                                            if (geoJsonData.hasOwnProperty(key)) {
                                                if (geoJsonData[key].features) {
                                                    fatherGeoJsonNode.features = fatherGeoJsonNode.features.concat(geoJsonData[key].features);
                                                }
                                            }
                                        }
                                        countObjKeys++;
                                    });

                                }

                                for (var i = 0; i < fatherGeoJsonNode.features.length; i++) {

                                    fatherGeoJsonNode.features[i].properties.targetWidgets = targets;
                                    fatherGeoJsonNode.features[i].properties.color1 = color1;
                                    fatherGeoJsonNode.features[i].properties.color2 = color2;
                                }

                                if (gisLayersOnMap.hasOwnProperty(desc) && (display !== 'geometries')) {
                                    gisLayersOnMap[desc] = L.geoJSON(fatherGeoJsonNode, {
                                        pointToLayer: gisPrepareCustomMarkerFullScreen,
                                        onEachFeature: onEachFeature
                                    }).addTo(fullscreendefaultMapRef);
                                }

                                //eventGenerator.parents("div.gisMapPtrContainer").find("i.gisLoadingIcon").hide();
                                eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("font-weight", "bold");
                                eventGenerator.parents('div.gisMapPtrContainer').siblings('div.gisQueryDescContainer').find('p.gisQueryDescPar').css("color", eventGenerator.attr("data-activeFontColor"));
                                if (eventGenerator.parents("div.gisMapPtrContainer").find('a.gisPinLink').attr("data-symbolMode") === 'auto') {
                                    eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").html("near_me");
                                    eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("color", "white");
                                    eventGenerator.parents("div.gisMapPtrContainer").find("i.gisPinIcon").css("text-shadow", "2px 2px 4px black");
                                }
                                else {
                                    //Evidenziazione che gli eventi di questa query sono su mappa in caso di icona custom
                                    eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").show();
                                    eventGenerator.parents("div.gisMapPtrContainer").find("div.gisPinCustomIconUp").css("height", "100%");
                                }

                                eventGenerator.show();

                                var wkt = null;

                                if (display !== 'pins') {
                                    stopGeometryAjax[desc] = false;
                                    gisGeometryTankForFullscreen[desc] = {
                                        capacity: fatherGeoJsonNode.features.length,
                                        shown: false,
                                        tank: [],
                                        lastConsumedIndex: 0
                                    };

                                    for (var i = 0; i < fatherGeoJsonNode.features.length; i++) {
                                        if (fatherGeoJsonNode.features[i].properties.hasOwnProperty('hasGeometry') && fatherGeoJsonNode.features[i].properties.hasOwnProperty('serviceUri')) {
                                            if (fatherGeoJsonNode.features[i].properties.hasGeometry === true) {
                                                //gisGeometryServiceUriToShowFullscreen[event.desc].push(fatherGeoJsonNode.features[i].properties.serviceUri);

                                                $.ajax({
                                                    url: "<?= $superServiceMapProxy; ?>api/v1/?serviceUri=" + fatherGeoJsonNode.features[i].properties.serviceUri,
                                                    type: "GET",
                                                    data: {},
                                                    async: true,
                                                    timeout: 0,
                                                    dataType: 'json',
                                                    success: function (geometryGeoJson) {
                                                        if (!stopGeometryAjax[desc]) {
                                                            // Creazione nuova istanza del parser Wkt
                                                            wkt = new Wkt.Wkt();

                                                            // Lettura del WKT dalla risposta
                                                            wkt.read(geometryGeoJson.Service.features[0].properties.wktGeometry);

                                                            var ciclePathFeature = [
                                                                {
                                                                    type: "Feature",
                                                                    properties: geometryGeoJson.Service.features[0].properties,
                                                                    geometry: wkt.toJson()
                                                                }
                                                            ];

                                                            if (!gisGeometryLayersOnMap.hasOwnProperty(desc)) {
                                                                gisGeometryLayersOnMap[desc] = [];
                                                            }

                                                            gisGeometryLayersOnMap[desc].push(L.geoJSON(ciclePathFeature, {}).addTo(fullscreendefaultMapRef));
                                                            gisGeometryTankForFullscreen[desc].tank.push(ciclePathFeature);
                                                        }
                                                    },
                                                    error: function (geometryErrorData) {
                                                        console.log("Ko");
                                                        console.log(JSON.stringify(geometryErrorData));
                                                    }
                                                });
                                            }
                                        }
                                    }
                                }
                            },
                        });
                    }
                    if (map.eventsOnMap[i].eventType === 'eventFI') {
                        let lat = map.eventsOnMap[i].lat;
                        let lng = map.eventsOnMap[i].lng;
                        let categoryIT = map.eventsOnMap[i].categoryIT;

                        let name = map.eventsOnMap[i].name;
                        if (name.includes('?')) {
                            name = name.replace(/\?/g, "'");
                        }

                        let place = map.eventsOnMap[i].place;
                        if (place.includes('?')) {
                            place = place.replace(/\?/g, "'");
                        }

                        let startDate = map.eventsOnMap[i].startDate;
                        let endDate = map.eventsOnMap[i].endDate;
                        let startTime = map.eventsOnMap[i].startTime;
                        let freeEvent = map.eventsOnMap[i].freeEvent;
                        let address = map.eventsOnMap[i].address;
                        if (address.includes('?')) {
                            address = address.replace(/\?/g, "'");
                        }

                        let civic = map.eventsOnMap[i].civic;
                        let price = map.eventsOnMap[i].price;
                        let phone = map.eventsOnMap[i].phone;
                        let descriptionIT = map.eventsOnMap[i].descriptionIT;
                        if (descriptionIT.includes('?')) {
                            descriptionIT = descriptionIT.replace(/\?/g, "'");
                        }

                        let website = map.eventsOnMap[i].website;
                        let colorClass = map.eventsOnMap[i].colorClass;
                        let mapIconName = map.eventsOnMap[i].mapIconName;

                        let mapPinImg = '../img/eventsIcons/' + mapIconName + '.png';

                        let pinIcon = new L.DivIcon({
                            className: null,
                            html: '<img src="' + mapPinImg + '" class="leafletPin" />',
                            iconAnchor: [18, 36]
                        });

                        let markerLocation = new L.LatLng(lat, lng);
                        let marker = new L.Marker(markerLocation, { icon: pinIcon });

                        //Creazione del popup per il pin appena creato
                        let popupText = '<h3 class="' + colorClass + ' recreativeEventMapTitle">' + name + '</h3>';
                        popupText += '<div class="recreativeEventMapBtnContainer"><button class="recreativeEventMapDetailsBtn recreativeEventMapBtn ' + colorClass + ' recreativeEventMapBtnActive" type="button">Details</button><button class="recreativeEventMapDescriptionBtn recreativeEventMapBtn ' + colorClass + '" type="button">Description</button><button class="recreativeEventMapTimingBtn recreativeEventMapBtn ' + colorClass + '" type="button">Timing</button><button class="recreativeEventMapContactsBtn recreativeEventMapBtn ' + colorClass + '" type="button">Contacts</button></div>';

                        popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDetailsContainer">';
                        if ((place !== 'undefined') || (address !== 'undefined')) {
                            if (categoryIT !== 'undefined') {
                                popupText += '<b>Category: </b>' + categoryIT;
                            }

                            if (place !== 'undefined') {
                                popupText += '<br/>';
                                popupText += '<b>Location: </b>' + place;
                            }

                            if (address !== 'undefined') {
                                popupText += '<br/>';
                                popupText += '<b>Address: </b>' + address;
                                if (civic !== 'undefined') {
                                    popupText += ' ' + civic;
                                }
                            }

                            if (freeEvent !== 'undefined') {
                                popupText += '<br/>';
                                if ((freeEvent !== 'yes') && (freeEvent !== 'YES') && (freeEvent !== 'Yes')) {
                                    if (price !== 'undefined') {
                                        popupText += '<b>Price (€) : </b>' + price + "<br>";
                                    }
                                    else {
                                        popupText += '<b>Price (€) : </b>N/A<br>';
                                    }
                                }
                                else {
                                    popupText += '<b>Free event: </b>' + freeEvent + '<br>';
                                }
                            }
                        }
                        else {
                            popupText += 'No further details available';
                        }
                        popupText += '</div>';

                        popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDescContainer">';
                        if (descriptionIT !== 'undefined') {
                            popupText += descriptionIT;
                        }
                        else {
                            popupText += 'No description available';
                        }
                        popupText += '</div>';

                        popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapTimingContainer">';
                        if ((startDate !== 'undefined') || (endDate !== 'undefined') || (startTime !== 'undefined')) {
                            popupText += '<b>From: </b>';
                            if (startDate !== 'undefined') {
                                popupText += startDate;
                            }
                            else {
                                popupText += 'N/A';
                            }
                            popupText += '<br/>';

                            popupText += '<b>To: </b>';
                            if (endDate !== 'undefined') {
                                popupText += endDate;
                            }
                            else {
                                popupText += 'N/A';
                            }
                            popupText += '<br/>';

                            if (startTime !== 'undefined') {
                                popupText += '<b>Times: </b>' + startTime + '<br/>';
                            }
                            else {
                                popupText += '<b>Times: </b>N/A<br/>';
                            }

                        }
                        else {
                            popupText += 'No timings info available';
                        }
                        popupText += '</div>';

                        popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapContactsContainer">';
                        if ((phone !== 'undefined') || (website !== 'undefined')) {
                            if (phone !== 'undefined') {
                                popupText += '<b>Phone: </b>' + phone + '<br/>';
                            }
                            else {
                                popupText += '<b>Phone: </b>N/A<br/>';
                            }

                            if (website !== 'undefined') {
                                if (website.includes('http') || website.includes('https')) {
                                    popupText += '<b><a href="' + website + '" target="_blank">Website</a></b><br>';
                                }
                                else {
                                    popupText += '<b><a href="' + website + '" target="_blank">Website</a></b><br>';
                                }
                            }
                            else {
                                popupText += '<b>Website: </b>N/A';
                            }
                        }
                        else {
                            popupText += 'No contacts info available';
                        }
                        popupText += '</div>';

                        fullscreendefaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [-5, -40], maxWidth: 300 });

                        lastPopup.on('popupopen', function () {
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapDetailsBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapDetailsBtn').click(function () {
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDataContainer').hide();
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDetailsContainer').show();
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapDescriptionBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapDescriptionBtn').click(function () {
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDataContainer').hide();
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDescContainer').show();
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapTimingBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapTimingBtn').click(function () {
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDataContainer').hide();
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapTimingContainer').show();
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });

                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapContactsBtn').off('click');
                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpenBodyDefaultMap button.recreativeEventMapContactsBtn').click(function () {
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapDataContainer').hide();
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap div.recreativeEventMapContactsContainer').show();
                                $('#' + widgetName + '_modalLinkOpenBodyDefaultMap button.recreativeEventMapBtn').removeClass('recreativeEventMapBtnActive');
                                $(this).addClass('recreativeEventMapBtnActive');
                            });
                        });

                        lastPopup.openPopup();
                    }
                    if (map.eventsOnMap[i].eventType === 'resource') {
                        let lat = map.eventsOnMap[i].lat;
                        let lng = map.eventsOnMap[i].lng;
                        let eventName = map.eventsOnMap[i].eventName;
                        let eventStartDate = map.eventsOnMap[i].eventStartDate;
                        let eventStartTime = map.eventsOnMap[i].eventStartTime;

                        mapPinImg = '../img/resourceIcons/metroMap.png';

                        pinIcon = new L.DivIcon({
                            className: null,
                            html: '<img src="' + mapPinImg + '" class="leafletPin" />',
                            iconAnchor: [18, 36]
                        });

                        var markerLocation = new L.LatLng(lat, lng);
                        var marker = new L.Marker(markerLocation, { icon: pinIcon });

                        //Creazione del popup per il pin appena creato
                        var popupText = "<span class='mapPopupTitle'>" + eventName.toUpperCase() + "</span>" +
                            "<span class='mapPopupLine'>" + eventStartDate + " - " + eventStartTime + "</span>";

                        fullscreendefaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [-5, -40] }).openPopup();
                    }
                    if (map.eventsOnMap[i].eventType === 'OperatorEvent') {
                        let lat = map.eventsOnMap[i].lat;
                        let lng = map.eventsOnMap[i].lng;
                        let eventStartDate = map.eventsOnMap[i].eventStartDate;
                        let eventStartTime = map.eventsOnMap[i].eventStartTime;
                        let eventPeopleNumber = parseInt(map.eventsOnMap[i].eventPeopleNumber);
                        let eventOperatorName = map.eventsOnMap[i].eventOperatorName;
                        let eventColor = map.eventsOnMap[i].eventColor;


                        let markerLocation = new L.LatLng(lat, lng);
                        let marker = new L.Marker(markerLocation);

                        //Creazione del popup per il pin appena creato
                        popupText = "<span class='mapPopupTitle'>" + eventColor.toUpperCase() + "</span>" +
                            "<span class='mapPopupLine'>" + eventStartDate + " - " + eventStartTime + "</span>" +
                            //  "<span class='mapPopupLine'>PEOPLE INVOLVED: " + eventPeopleNumber + "</span>" +
                            "<span class='mapPopupLine'>TICKET NUMBER: " + eventPeopleNumber + "</span>" +
                            "<span class='mapPopupLine'>OPERATOR: " + eventOperatorName.toUpperCase() + "</span>";

                        fullscreendefaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [0, 0] }).openPopup();
                    }
                    if (map.eventsOnMap[i].type === 'trafficEvent') {
                        let lat = map.eventsOnMap[i].lat;
                        let lng = map.eventsOnMap[i].lng;
                        let eventType = map.eventsOnMap[i].eventType;
                        let eventSubtype = map.eventsOnMap[i].eventSubtype;
                        let eventName = map.eventsOnMap[i].eventName;
                        let eventStartDate = map.eventsOnMap[i].eventStartDate;
                        let eventStartTime = map.eventsOnMap[i].eventStartTime;
                        let eventSeverity = map.eventsOnMap[i].eventSeverity;
                        let eventseveritynum = map.eventsOnMap[i].eventseveritynum;


                        //Creazione dell'icona custom per il pin
                        switch (eventSeverity) {
                            case "Low":
                                mapPinImg = '../img/trafficIcons/' + trafficEventTypes["type" + eventType].mapIconLow;
                                severityColor = "#ffcc00";
                                break;

                            case "Med":
                                mapPinImg = '../img/trafficIcons/' + trafficEventTypes["type" + eventType].mapIconMed;
                                severityColor = "#ff9900";
                                break;

                            case "High":
                                mapPinImg = '../img/trafficIcons/' + trafficEventTypes["type" + eventType].mapIconHigh;
                                severityColor = "#ff6666";
                                break;
                        }

                        let pinIcon = new L.DivIcon({
                            className: null,
                            html: '<img src="' + mapPinImg + '" class="leafletPin" />',
                            iconAnchor: [18, 36]
                        });

                        let markerLocation = new L.LatLng(lat, lng);
                        let marker = new L.Marker(markerLocation, { icon: pinIcon });

                        //Creazione del popup per il pin appena creato
                        popupText = "<span class='mapPopupTitle'>" + eventName + "</span>" +
                            "<span class='mapPopupLine'><i>Start date</i>: " + eventStartDate + " - " + eventStartTime + "</span>" +
                            "<span class='mapPopupLine'><i>Event type</i>: " + trafficEventTypes["type" + eventType].desc.toUpperCase() + "</span>" +
                            "<span class='mapPopupLine'><i>Event subtype</i>: " + trafficEventSubTypes["subType" + eventSubtype].toUpperCase() + "</span>" +
                            "<span class='mapPopupLine'><i>Event severity</i>: " + eventseveritynum + " - <span style='background-color: " + severityColor + "'>" + eventSeverity.toUpperCase() + "</span></span>";

                        fullscreendefaultMapRef.addLayer(marker);
                        lastPopup = marker.bindPopup(popupText, { offset: [-5, -40], maxWidth: 600 }).openPopup();
                    }
                    if (map.eventsOnMap[i].eventType === 'trafficRealTimeDetails') {

                        var event = map.eventsOnMap[i];

                        var myMarker = new L.LayerGroup();

                        $.ajax({
                            //    url: "../trafficRTDetails/sensorsCoord.json",
                            url: "https://firenzetraffic.km4city.org/trafficRTDetails/sensorsCoord.php",
                            type: "GET",
                            async: false,
                            cache: false,
                            dataType: 'json',
                            success: function (_sensors) {
                                sensors = JSON.parse(_sensors);
                                for (var i = 0; i < sensors.length; i++) {
                                    if (sensors[i].sensorLat > event.minLat && sensors[i].sensorLat < event.maxLat && sensors[i].sensorLong > event.minLng && sensors[i].sensorLong < event.maxLng) {
                                        var mark = L.circleMarker([sensors[i].sensorLat, sensors[i].sensorLong]);
                                        mark.addTo(myMarker);
                                    }
                                }
                                myMarker.addTo(fullscreendefaultMapRef);
                            }
                        });

                        map.defaultMapRef.on('click', function (e) {
                            var bnds = map.defaultMapRef.getBounds()
                            console.log(bnds.getSouth() + ";" + bnds.getWest() + ";" + bnds.getNorth() + ";" + bnds.getEast());
                            if (roads == null)
                                loadRoads();
                            else {
                            }
                        });

                        var wktLayer = new L.LayerGroup();
                        var roads = null;
                        var time = 0;

                        loadRoads();

                        function loadRoads() {
                            defaults = {
                                icon: new L.DivIcon({ className: "geo-icon" }),
                                editable: true,
                                color: '#AA0000',
                                weight: 2.5,
                                opacity: 1,
                                fillColor: '#AA0000',
                                fillOpacity: 1
                            };

                            $.ajax({
                                //    url: "http://localhost/dashboardSmartCity/trafficRTDetails/roads/read.php" + "?sLat=" + event.minLat + "&sLong=" + event.minLng + "&eLat=" + event.maxLat + "&eLong=" + event.maxLng + "&zoom=" + event.zm,
                                url: "https://firenzetraffic.km4city.org/trafficRTDetails/roads/read.php" + "?sLat=" + event.minLat + "&sLong=" + event.minLng + "&eLat=" + event.maxLat + "&eLong=" + event.maxLng + "&zoom=" + event.zm,     // MOD GP
                                type: "GET",
                                async: true,
                                dataType: 'json',
                                success: function (_roads) {
                                    roads = JSON.parse(JSON.stringify(_roads));

                                    loadDensity();
                                },
                                error: function (err) {
                                    console.log(err);
                                    alert("error see log json");
                                }
                            });
                        }

                        function loadDensity() {
                            $.ajax({
                                //    url: "http://localhost/dashboardSmartCity/trafficRTDetails/density/read.php" + "?sLat=" + event.minLat + "&sLong=" + event.minLng + "&eLat=" + event.maxLat + "&eLong=" + event.maxLng + "&zoom=" + event.zm,
                                url: "https://firenzetraffic.km4city.org/trafficRTDetails/density/read.php" + "?sLat=" + event.minLat + "&sLong=" + event.minLng + "&eLat=" + event.maxLat + "&eLong=" + event.maxLng + "&zoom=" + event.zm,   // MOD GP
                                type: "GET",
                                async: false,
                                cache: false,
                                dataType: 'json',
                                success: function (_density) {
                                    density = JSON.parse(JSON.stringify(_density));

                                    for (var i = 0; i < roads.length; i++) {
                                        if (density.hasOwnProperty((roads[i].road))) {
                                            roads[i].data = density[roads[i].road].data;
                                        }
                                    }

                                    time = 0;
                                    draw(time);
                                    console.log("@time " + time);
                                },
                                error: function (err) {
                                    console.log(err);
                                    alert("error see log json");
                                }
                            });
                        }

                        function draw(t) {
                            if (roads == null)
                                return;
                            //wktLayer.clearLayers();
                            for (var i = 0; i < roads.length; i++) {
                                var segs = roads[i].segments;
                                for (var j = 0; j < segs.length; j++) {
                                    var seg = segs[j];
                                    if (typeof seg.start != "undefined") {
                                        var wktPoint = "POINT(" + seg.start.long + " " + seg.start.lat + ")";
                                        var wktLine = "LINESTRING(" + seg.start.long + " " + seg.start.lat + "," + seg.end.long + " " + seg.end.lat + ")";

                                        try {
                                            if (!jQuery.isEmptyObject(roads[i].data[0])) {
                                                var value = Number(roads[i].data[t][seg.id].replace(",", "."));
                                                //console.log(value);
                                                var green = 0.3;
                                                var yellow = 0.6;
                                                var orange = 0.9;
                                                if (seg.Lanes == 2) {
                                                    green = 0.6;
                                                    yellow = 1.2;
                                                    orange = 1.8;
                                                }
                                                if (seg.FIPILI == 1) {
                                                    green = 0.25;
                                                    yellow = 0.5;
                                                    orange = 0.75;
                                                }
                                                if (seg.Lanes == 3) {
                                                    green = 0.9;
                                                    yellow = 1.5;
                                                    orange = 2;
                                                }
                                                if (seg.Lanes == 4) {
                                                    green = 1.2;
                                                    yellow = 1.6;
                                                    orange = 2;
                                                }
                                                if (seg.Lanes == 5) {
                                                    green = 1.6;
                                                    yellow = 2;
                                                    orange = 2.4;
                                                }
                                                if (seg.Lanes == 6) {
                                                    green = 2;
                                                    yellow = 2.4;
                                                    orange = 2.8;
                                                }
                                                if (value <= green)
                                                    defaults.color = "#00ff00";
                                                else if (value <= yellow)
                                                    defaults.color = "#ffff00";
                                                else if (value <= orange)
                                                    defaults.color = "#ff8c00";
                                                else
                                                    defaults.color = "#ff0000";
                                                defaults.fillColor = defaults.color;

                                                if (!seg.obj) {
                                                    var wkt = new Wkt.Wkt();
                                                    wkt.read(wktLine, "newMap");
                                                    obj = wkt.toObject(defaults);
                                                    obj.options.trafficFlow = true;
                                                    obj.addTo(wktLayer);
                                                    seg.obj = obj;

                                                } else {
                                                    seg.obj.setStyle(defaults);
                                                }
                                            }
                                        } catch (e) {
                                            console.log(e);
                                        }
                                    }
                                }
                            }
                            wktLayer.addTo(fullscreendefaultMapRef);
                        }

                        //Create legend
                        var legend = L.control({ position: 'bottomright' });

                        legend.onAdd = function (map) {

                            var div = L.DomUtil.create('div', 'info legend'),
                                grades = ["Legend"],
                                //    labels = ["http://localhost/dash/trafficRTDetails/legend.png"];
                                labels = ["https://firenzetraffic.km4city.org/trafficRTDetails/legend.png"];   // MOD GP

                            // loop through our density intervals and generate a label with a colored square for each interval
                            for (var i = 0; i < grades.length; i++) {
                                div.innerHTML +=
                                    grades[i] + (" <img src=" + labels[i] + " height='120' width='80' background='#cccccc'>") + '<br>';
                            }

                            return div;
                        };

                        legend.addTo(fullscreendefaultMapRef);
                    }
                    if (map.eventsOnMap[i].eventType === 'heatmap' || map.eventsOnMap[i].eventType === undefined) {

                        fullscreendefaultMapRef.off('click');

                        function prepareCustomMarkerForPointAndClickFullScreen(dataObj, color1, color2) {
                            var latLngId = dataObj.latitude + "" + dataObj.longitude;
                            latLngId = latLngId.replace(".", "");
                            latLngId = latLngId.replace(".", "");//Incomprensibile il motivo ma con l'espressione regolare /./g non funziona

                            var popupText = '<h3 class="recreativeEventMapTitle" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + '); text-transform: none;">' + dataObj.mapName + '</h3>';

                            popupText += '<div class="recreativeEventMapBtnContainer"><span data-id="' + latLngId + '" class="recreativeEventMapDetailsBtn recreativeEventMapBtn recreativeEventMapBtnActive" style="background: ' + color1 + '; background: -webkit-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -o-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: -moz-linear-gradient(right, ' + color1 + ', ' + color2 + '); background: linear-gradient(to right, ' + color1 + ', ' + color2 + ');">Heatmap Details</span></div>';

                            popupText += '<div class="recreativeEventMapDataContainer recreativeEventMapDetailsContainer" style="height:100px; width:270px;">';

                            popupText += '<table id="' + latLngId + '" class="gisPopupGeneralDataTable" style="width:90%">';
                            //Intestazione
                            popupText += '<thead>';
                            popupText += '<th style="background: ' + color2 + '">Description</th>';
                            popupText += '<th style="background: ' + color2 + '">Value</th>';
                            popupText += '</thead>';

                            //Corpo
                            popupText += '<tbody>';

                            var dateTime = new Date(dataObj.dataTime);// Milliseconds to date
                            dateTime = dateTime.getDate() + "\/" + parseInt(dateTime.getMonth() + 1) + "\/" + dateTime.getFullYear() + " " + dateTime.getHours() + ":" + dateTime.getMinutes() + ":" + dateTime.getSeconds();

                            popupText += '<tr><td style="text-align:left; font-size: 12px;">Date & Time:</td><td style="font-size: 12px;">' + dateTime + '</td></tr>';
                            popupText += '<tr><td style="text-align:left; font-size: 12px;">Metric Name:</td><td style="font-size: 12px;">' + dataObj.metricName + '</td></tr>';
                            popupText += '<tr><td style="text-align:left; font-size: 12px;">Heatmap Value:</td><td style="font-size: 12px;">' + dataObj.value + '</td></tr>';
                            popupText += '<tr><td style="text-align:left; font-size: 12px;">Coordinates:</td><td style="font-size: 12px;">' + dataObj.latitude + ', ' + dataObj.longitude + '</td></tr>';

                            return popupText;
                        }

                        fullscreendefaultMapRef.on('click', function (e) {
                            if (map.testMetadata.metadata.file != 1) {
                                var heatmapPointAndClickData = null;
                                //  alert("Click on Map !");
                                var pointAndClickCoord = e.latlng;
                                var pointAndClickLat = pointAndClickCoord.lat.toFixed(5);
                                var pointAndClickLng = pointAndClickCoord.lng.toFixed(5);
                                //    var pointAndClickApiUrl = "https://heatmap.snap4city.org/interp.php?latitude=" + pointAndClickLat + "&longitude=" + pointAndClickLng + "&dataset=" + map.testMetadata.metadata.mapName + "&date=" + map.testMetadata.metadata.date;
                                var pointAndClickApiUrl = heatmapUrl + "interp.php?latitude=" + pointAndClickLat + "&longitude=" + pointAndClickLng + "&dataset=" + map.testMetadata.metadata.mapName + "&date=" + map.testMetadata.metadata.date;
                                $.ajax({
                                    url: pointAndClickApiUrl,
                                    async: true,
                                    success: function (heatmapPointAndClickData) {
                                        var popupData = {};
                                        popupData.mapName = heatmapPointAndClickData.mapName;
                                        popupData.latitude = pointAndClickLat;
                                        popupData.longitude = pointAndClickLng;
                                        popupData.metricName = heatmapPointAndClickData.metricName;
                                        popupData.dataTime = heatmapPointAndClickData.date;
                                        if (heatmapPointAndClickData.value) {
                                            popupData.value = heatmapPointAndClickData.value.toFixed(5);
                                            var customPointAndClickContent = prepareCustomMarkerForPointAndClickFullScreen(popupData, "#C2D6D6", "#D1E0E0")
                                            //   var pointAndClickPopup = L.popup(customPointAndClickMarker).openOn(map.defaultMapRef);
                                            var popup = L.popup()
                                                .setLatLng(pointAndClickCoord)
                                                .setContent(customPointAndClickContent)
                                                .openOn(fullscreendefaultMapRef);
                                        }
                                    },
                                    error: function (errorData) {
                                        console.log("Ko Point&Click Heatmap API");
                                        console.log(JSON.stringify(errorData));
                                    }
                                });
                            }
                        });

                        // CANCELLARE PRIMA IL LAYER PRCEDENTE !!!

                        if (fullscreenHeatmapFirstInst != true) {
                            for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                                if (map.eventsOnMap[i].eventType === 'heatmap') {
                                    removeHeatmap(false);
                                    //    removeHeatmapColorLegend(i, false);
                                    //  map.eventsOnMap.splice(i, 1);
                                } else if (map.eventsOnMap[i].eventType === undefined) {
                                    removeHeatmap(false);
                                }
                            }
                        } else {
                            fullscreenHeatmapFirstInst = false;
                        }

                        legendHeatmapFullscreen = L.control({ position: 'topright' });


                        window.addHeatmapFromFullscreenClient = function (animationFlag) {
                            //  function addHeatMapFromClient() {

                            var color1 = passedParams.color1;
                            var color2 = passedParams.color2;
                            var desc = passedParams.desc;

                            var loadingDiv = $('<div class="gisMapModalLoadingDiv"></div>');

                            if ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapModalLoadingDiv').length > 0) {
                                loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapModalLoadingDiv').last());
                            }
                            else {
                                loadingDiv.insertAfter($('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen'));
                            }

                            loadingDiv.css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - ($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapModalLoadingDiv').length * loadingDiv.height())) + "px");
                            loadingDiv.css("left", ($('#<?= $_REQUEST['name_w'] ?>_div').width() - loadingDiv.width()) + "px");

                            var loadingText = $('<p class="gisMapModalLoadingDivTextPar">adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="' + spinIcon + '" style="font-size: 30px"></i></p>');
                            var loadOkText = $('<p class="gisMapModalLoadingDivTextPar"><b>' + desc.toLowerCase() + '</b> added to map<br><i class="fa fa-check" style="font-size: 30px"></i></p>');
                            var loadKoText = $('<p class="gisMapModalLoadingDivTextPar">error adding <b>' + desc.toLowerCase() + '</b> to map<br><i class="fa fa-close" style="font-size: 30px"></i></p>');

                            loadingDiv.css("background", color1);
                            loadingDiv.css("background", "-webkit-linear-gradient(left top, " + color1 + ", " + color2 + ")");
                            loadingDiv.css("background", "-o-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                            loadingDiv.css("background", "-moz-linear-gradient(bottom right, " + color1 + ", " + color2 + ")");
                            loadingDiv.css("background", "linear-gradient(to bottom right, " + color1 + ", " + color2 + ")");

                            loadingDiv.show();

                            loadingDiv.append(loadingText);
                            loadingDiv.css("opacity", 1);

                            var parHeight = loadingText.height();
                            var parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                            loadingText.css("margin-top", parMarginTop + "px");

                            let heatmap = {};
                            heatmap.eventType = "heatmap";

                            /*   map.testData = {
                                   //   max: 8,
                                   data: heatmapData[current_page].data
                               };  */

                            //heatmap recommender metadata
                            map.testMetadata = {
                                //   max: 8,
                                metadata: heatmapData[current_page].metadata
                            };

                            if (map.testMetadata.metadata.metricName !== undefined) {
                                heatmapMetricName = map.testMetadata.metadata.metricName
                            } else {
                                heatmapMetricName = "airTemperature";
                                mapName = "WMS_PROVA";
                            }

                            if (map.testMetadata.metadata.mapName !== undefined) {
                                mapName = map.testMetadata.metadata.mapName;
                            } else {
                                mapName = "WMS_PROVA";
                            }

                            if (map.testMetadata.metadata.date !== undefined) {
                                mapDate = map.testMetadata.metadata.date;
                            } else {
                                mapDate = "DATA";
                            }

                            $.ajax({
                                url: "../controllers/getHeatmapRange.php",
                                type: "GET",
                                data: {
                                    metricName: heatmapMetricName
                                },
                                async: true,
                                dataType: 'json',
                                success: function (data) {
                                    try {
                                        if (data['detail'] == "Ok") {
                                            //  if (data['heatmapRange'].length > 1) {

                                            if (data['heatmapRange'][0]) {
                                                heatmapRange = data['heatmapRange'];
                                                initHeatmapLayer(heatmapRange);   // OLD-API
                                                // Gestione della sincronia dei check-box del cambio raggio on zoom e computo raggio su base dati dopo aggiornamento legenda

                                            } else {
                                                heatmapRange = [];
                                            }

                                            if (baseQuery.includes("heatmap.php")) {    // OLD HEATMAP


                                                //    let dataQuery = "https://heatmap.snap4city.org/data/" + mapName + "/" + heatmapMetricName + "/" + mapDate.replace(" ", "T") + "Z/0";
                                                let dataQuery = heatmapUrl + "data/" + mapName + "/" + heatmapMetricName + "/" + mapDate.replace(" ", "T") + "Z/0";

                                                $.ajax({
                                                    url: dataQuery,
                                                    type: "GET",
                                                    data: {
                                                    },
                                                    async: true,
                                                    cache: false,
                                                    dataType: 'json',
                                                    success: function (heatmapResData) {
                                                        if (heatmapResData['data']) {
                                                            //    heatmapRange = heatmapData['heatmapRange'];
                                                            initHeatmapLayer(heatmapRange);   // OLD-API
                                                            // Set current_radius come variabile globale per essere sincronizzata attraverso le varie azioni (zoom ecc...)
                                                            if (current_radius == null) {
                                                                current_radius = map.cfg.radius;
                                                            }
                                                            if (current_opacity == null) {
                                                                current_opacity = map.cfg.maxOpacity;
                                                            }

                                                        } else {
                                                            heatmapRange = [];
                                                        }

                                                        if (baseQuery.includes("heatmap.php")) {    // OLD HEATMAP
                                                            map.testData = {
                                                                //   max: 8,
                                                                data: heatmapResData.data
                                                            };

                                                            //heatmap recommender metadata
                                                            map.testMetadata = {
                                                                //   max: 8,
                                                                metadata: heatmapResData.metadata
                                                            };

                                                            if (heatmapRange[0].range1Inf == null) {
                                                                if (heatmapMetricName == "EAQI" || heatmapMetricName == "CAQI") {
                                                                    heatmapRange[0].range1Inf = heatmapRange[0].range4Inf;
                                                                } else if (heatmapMetricName == "CO" || heatmapMetricName == "Benzene") {
                                                                    heatmapRange[0].range1Inf = heatmapRange[0].range3Inf;
                                                                    heatmapRange[0].range10Inf = heatmapRange[0].range8Inf;
                                                                }
                                                            }

                                                            fullscreenHeatmap.setData({ max: heatmapRange[0].range10Inf, min: heatmapRange[0].range1Inf, data: map.testData.data });
                                                            fullscreendefaultMapRef.addLayer(fullscreenHeatmap);   // OLD HEATMAP
                                                            //    if (estimateRadiusFlag === true) {
                                                            var distArray = [];             // MODALITA HEATMAP ON DATA DISTANCE
                                                            if (heatmapResData.length > 20) {
                                                                for (k = 0; k < 20; k++) {
                                                                    distArray[k] = distance(heatmapResData[k].latitude, heatmapResData[k].latitude, heatmapResData[k + 1].latitude, heatmapResData[k + 1].latitude, "K");
                                                                }

                                                                var sum = 0;
                                                                for (var i = 0; i < distArray.length; i++) {
                                                                    sum += distArray[i];
                                                                }
                                                                estimatedRadius = sum / distArray.length;
                                                                if (estimatedRadius <= 1) {
                                                                    estimatedRadius = 2;
                                                                }
                                                                //   if (estimateRadiusFlag === true) {
                                                            } else {
                                                                estimatedRadius = current_radius;
                                                            }

                                                            metresPerPixel = 40075016.686 * Math.abs(Math.cos(fullscreendefaultMapRef.getCenter().lat * Math.PI / 180)) / Math.pow(2, fullscreendefaultMapRef.getZoom() + 8);
                                                            var initRadius = ((estimatedRadius * 1000) / metresPerPixel) / 50;
                                                            if (current_page == 0) {
                                                                setOption('radius', initRadius.toFixed(1), 1);
                                                            } else {
                                                                setOption('radius', current_radius.toFixed(1), 1);
                                                            }
                                                            //   }
                                                        } else {                    // NEW HEATMAP

                                                            map.defaultMapRef.createPane('Snap4City:' + wmsDatasetName);    // CORTI
                                                            map.defaultMapRef.getPane('Snap4City:' + wmsDatasetName).style.zIndex = 420;    // CORTI

                                                            //   var timestampISO = "2019-01-23T20:20:15.000Z";
                                                            var timestamp = map.testMetadata.metadata.date;
                                                            var timestampISO = timestamp.replace(" ", "T") + ".000Z";
                                                            //    wmsLayerFullscreen = L.tileLayer.wms("https://wmsserver.snap4city.org/geoserver/Snap4City/wms", {
                                                            wmsLayerFullscreen = L.tileLayer.wms(geoServerUrl + "geoserver/Snap4City/wms", {
                                                                layers: 'Snap4City:' + wmsDatasetName,
                                                                format: 'image/png',
                                                                crs: L.CRS.EPSG4326,
                                                                transparent: true,
                                                                opacity: current_opacity,
                                                                time: timestampISO,
                                                                //  bbox: [24.7926004025304,60.1025194986424,25.1905923952885,60.2516802986263],
                                                                tiled: true,
                                                                //  attribution: "IGN ©"
                                                                pane: 'Snap4City:' + wmsDatasetName	// CORTI
                                                            }).addTo(fullscreendefaultMapRef);
                                                            //   current_opacity = 0.5;

                                                        }

                                                        // add legend to map
                                                        legendHeatmapFullscreen.addTo(fullscreendefaultMapRef);
                                                        map.eventsOnMap.push(heatmap);
                                                        var mapControlsContainer = document.getElementsByClassName("leaflet-control")[0];

                                                        //    var legendImgPath = heatmapRange[0].iconPath;
                                                        //     div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';
                                                        heatmapLegendColorsFullscreen = L.control({ position: 'bottomleft' });

                                                        heatmapLegendColorsFullscreen.onAdd = function (map) {

                                                            var div = L.DomUtil.create('div', 'info legend'),
                                                                grades = ["Legend"];
                                                            //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
                                                            var legendImgPath = heatmapRange[0].iconPath; // OLD-API
                                                            div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';    /// OLD-API
                                                            return div;
                                                        };

                                                        heatmapLegendColorsFullscreen.addTo(fullscreendefaultMapRef);

                                                        if (changeRadiusOnZoom) {
                                                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad').prop('checked', true);
                                                            if (estimateRadiusFlag) {
                                                                $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad').prop('disabled', true);
                                                            }
                                                        }

                                                        if (estimateRadiusFlag) {
                                                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad').prop('checked', true);
                                                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad').prop('disabled', false);
                                                        } else {
                                                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad').prop('disabled', false);
                                                        }

                                                        loadingDiv.empty();
                                                        loadingDiv.append(loadOkText);

                                                        parHeight = loadOkText.height();
                                                        parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                                        loadOkText.css("margin-top", parMarginTop + "px");

                                                        setTimeout(function () {
                                                            loadingDiv.css("opacity", 0);
                                                            setTimeout(function () {
                                                                loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapModalLoadingDiv").each(function (i) {
                                                                    $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapModalLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                                });
                                                                loadingDiv.remove();
                                                            }, 350);
                                                        }, 1000);


                                                    },
                                                    error: function (errorData) {
                                                        console.log("Ko Heatmap");
                                                        console.log(JSON.stringify(errorData));

                                                        loadingDiv.empty();
                                                        loadingDiv.append(loadKoText);

                                                        parHeight = loadKoText.height();
                                                        parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                                        loadKoText.css("margin-top", parMarginTop + "px");

                                                        setTimeout(function () {
                                                            loadingDiv.css("opacity", 0);
                                                            setTimeout(function () {
                                                                loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapModalLoadingDiv").each(function (i) {
                                                                    $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapModalLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                                });
                                                                loadingDiv.remove();
                                                            }, 350);
                                                        }, 1000);

                                                    }
                                                });


                                            } else {
                                                if (animationFlag === false) {
                                                    // NEW HEATMAP

                                                    map.defaultMapRef.createPane('Snap4City:' + wmsDatasetName);    // CORTI
                                                    map.defaultMapRef.getPane('Snap4City:' + wmsDatasetName).style.zIndex = 420;    // CORTI

                                                    var timestamp = map.testMetadata.metadata.date;
                                                    var timestampISO = timestamp.replace(" ", "T") + ".000Z";
                                                    //    wmsLayerFullscreen = L.tileLayer.wms("https://wmsserver.snap4city.org/geoserver/Snap4City/wms", {
                                                    wmsLayerFullscreen = L.tileLayer.wms(geoServerUrl + "geoserver/Snap4City/wms", {
                                                        layers: 'Snap4City:' + wmsDatasetName,
                                                        format: 'image/png',
                                                        crs: L.CRS.EPSG4326,
                                                        transparent: true,
                                                        opacity: current_opacity,
                                                        time: timestampISO,
                                                        //  bbox: [24.7926004025304,60.1025194986424,25.1905923952885,60.2516802986263],
                                                        tiled: true,
                                                        //  attribution: "IGN ©"
                                                        pane: 'Snap4City:' + wmsDatasetName	// CORTI
                                                    }).addTo(fullscreendefaultMapRef);

                                                    // add legend to map
                                                    legendHeatmapFullscreen.addTo(fullscreendefaultMapRef);
                                                    heatmapLegendColorsFullscreen = L.control({ position: 'bottomleft' });

                                                    heatmapLegendColorsFullscreen.onAdd = function (map) {

                                                        var div = L.DomUtil.create('div', 'info legend'),
                                                            grades = ["Legend"];
                                                        //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
                                                        var legendImgPath = heatmapRange[0].iconPath;         // OLD-API
                                                        div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';    // OLD-API
                                                        return div;
                                                    };

                                                    heatmapLegendColorsFullscreen.addTo(fullscreendefaultMapRef);
                                                    map.eventsOnMap.push(heatmap);
                                                    //    event.legendColors = heatmapLegendColorsFullscreen;

                                                    loadingDiv.empty();
                                                    loadingDiv.append(loadOkText);

                                                    parHeight = loadOkText.height();
                                                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                                    loadOkText.css("margin-top", parMarginTop + "px");

                                                    setTimeout(function () {
                                                        loadingDiv.css("opacity", 0);
                                                        setTimeout(function () {
                                                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                            });
                                                            loadingDiv.remove();
                                                        }, 350);
                                                    }, 1000);
                                                } else {
                                                    // ANIMATION WMS HEATMAP

                                                    map.defaultMapRef.createPane('Snap4City:' + wmsDatasetName);    // CORTI
                                                    map.defaultMapRef.getPane('Snap4City:' + wmsDatasetName).style.zIndex = 420;    // CORTI

                                                    var animationCurrentDayTimestamp = [];
                                                    var animationCurrentDayFwdTimestamp = [];
                                                    var animationCurrentDayBckwdTimestamp = [];
                                                    var animationStringTimestamp = "";
                                                    var timestamp = map.testMetadata.metadata.date;
                                                    //    var timestampISO = timestamp.replace(" ", "T") + ".000Z";
                                                    var day = timestamp.substring(0, 10);
                                                    if (current_page == 0) {
                                                        var offsetFwd = current_page;
                                                        while (heatmapData[offsetFwd].metadata['date'].substring(0, 10) == day) {
                                                            animationCurrentDayFwdTimestamp.push(heatmapData[offsetFwd].metadata['date'].replace(" ", "T") + ".000Z");
                                                            offsetFwd++;
                                                        }
                                                    } else if (current_page == numHeatmapPages() - 1) {
                                                        var offsetBckwd = current_page - 1;
                                                        while (heatmapData[offsetBckwd].metadata['date'].substring(0, 10) == day) {
                                                            animationCurrentDayBckwdTimestamp.push(heatmapData[offsetBckwd].metadata['date'].replace(" ", "T") + ".000Z");
                                                            offsetBckwd--;
                                                            if (offsetBckwd < 0) {
                                                                break;
                                                            }
                                                        }
                                                    } else {
                                                        var offsetFwd = current_page;
                                                        while (heatmapData[offsetFwd].metadata['date'].substring(0, 10) == day) {
                                                            animationCurrentDayFwdTimestamp.push(heatmapData[offsetFwd].metadata['date'].replace(" ", "T") + ".000Z");
                                                            offsetFwd++;
                                                        }
                                                        var offsetBckwd = current_page - 1;
                                                        while (heatmapData[offsetBckwd].metadata['date'].substring(0, 10) == day) {
                                                            animationCurrentDayBckwdTimestamp.push(heatmapData[offsetBckwd].metadata['date'].replace(" ", "T") + ".000Z");
                                                            offsetBckwd--;
                                                            if (offsetBckwd < 0) {
                                                                break;
                                                            }
                                                        }
                                                    }

                                                    animationCurrentDayTimestamp = animationCurrentDayFwdTimestamp.reverse().concat(animationCurrentDayBckwdTimestamp);
                                                    //    animationCurrentDayTimestamp = animationCurrentDayTimestamp.reverse();
                                                    animationStringTimestamp = animationCurrentDayTimestamp.join(",");

                                                    var bboxJson = {};
                                                    $.ajax({
                                                        //    url: "https://heatmap.snap4city.org/bbox.php?layer=" + map.testMetadata.metadata.mapName,
                                                        url: heatmapUrl + "bbox.php?layer=" + map.testMetadata.metadata.mapName,
                                                        type: "GET",
                                                        async: false,
                                                        dataType: 'json',
                                                        success: function (resultBbox) {
                                                            bboxJson = resultBbox;
                                                        },
                                                        error: function (errbbox) {
                                                            alert("Error in retrieving bounding box for current heatmap: " + mapName);
                                                            console.log(errbbox);
                                                        }
                                                    });

                                                    var upEastLat = parseFloat(bboxJson['maxy']);
                                                    var upEastLon = parseFloat(bboxJson['maxx']);
                                                    var bottomWestLat = parseFloat(bboxJson['miny']);
                                                    var bottomWestLon = parseFloat(bboxJson['minx']);
                                                    //    var imageUrl = 'https://wmsserver.snap4city.org/geoserver/wms/animate?LAYERS=' + wmsDatasetName + '&aparam=time&avalues=' + animationStringTimestamp + '&format=image/gif;subtype=animated&format_options=gif_loop_continuosly:true;layout:message;gif_frames_delay:500&transparent=true';
                                                    var imageUrl = geoServerUrl + 'geoserver/wms/animate?LAYERS=' + wmsDatasetName + '&aparam=time&avalues=' + animationStringTimestamp + '&format=image/gif;subtype=animated&format_options=gif_loop_continuosly:true;layout:message;gif_frames_delay:500&transparent=true';
                                                    var imageBounds = [[bottomWestLat, bottomWestLon], [upEastLat, upEastLon]];
                                                    var overlayOpacity = current_opacity;

                                                    // ANIMATED GIF LAYER
                                                    var animatedLayer = L.imageOverlay(imageUrl, imageBounds, { opacity: overlayOpacity, pane: 'Snap4City:' + wmsDatasetName }).addTo(fullscreendefaultMapRef);

                                                    // add legend to map
                                                    map.legendHeatmap.addTo(map.defaultMapRef);
                                                    //    $("<?= $_REQUEST['name_w'] ?>_animation").prop("checked",true);
                                                    document.getElementById("<?= $_REQUEST['name_w'] ?>_animation").checked = true;
                                                    //     $("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").slider({ disabled: "true" });
                                                    $("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").slider('disable');
                                                    //     document.getElementById("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").slider({ disabled: "true" });
                                                    //     document.getElementById("<?= $_REQUEST['name_w'] ?>_slidermaxOpacity").slider({ disabled: "true" });
                                                    map.eventsOnMap.push(animatedLayer);
                                                    var mapControlsContainer = document.getElementsByClassName("leaflet-control")[0];

                                                    var heatmapLegendColors = L.control({ position: 'bottomleft' });

                                                    heatmapLegendColors.onAdd = function (map) {

                                                        var div = L.DomUtil.create('div', 'info legend'),
                                                            grades = ["Legend"];
                                                        //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
                                                        var legendImgPath = heatmapRange[0].iconPath; // OLD-API
                                                        div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';    /// OLD-API
                                                        return div;
                                                    };

                                                    // add legend to map
                                                    legendHeatmapFullscreen.addTo(fullscreendefaultMapRef);
                                                    map.eventsOnMap.push(heatmap);
                                                    var mapControlsContainer = document.getElementsByClassName("leaflet-control")[0];

                                                    //    var legendImgPath = heatmapRange[0].iconPath;
                                                    //     div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';
                                                    heatmapLegendColorsFullscreen = L.control({ position: 'bottomleft' });

                                                    heatmapLegendColorsFullscreen.onAdd = function (map) {

                                                        var div = L.DomUtil.create('div', 'info legend'),
                                                            grades = ["Legend"];
                                                        //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
                                                        var legendImgPath = heatmapRange[0].iconPath; // OLD-API
                                                        div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';    /// OLD-API
                                                        return div;
                                                    };

                                                    heatmapLegendColorsFullscreen.addTo(fullscreendefaultMapRef);

                                                    if (changeRadiusOnZoom) {
                                                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad').prop('checked', true);
                                                        if (estimateRadiusFlag) {
                                                            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad').prop('disabled', true);
                                                        }
                                                    }

                                                    if (estimateRadiusFlag) {
                                                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad').prop('checked', true);
                                                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad').prop('disabled', false);
                                                    } else {
                                                        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad').prop('disabled', false);
                                                    }

                                                    loadingDiv.empty();
                                                    loadingDiv.append(loadOkText);

                                                    parHeight = loadOkText.height();
                                                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                                    loadOkText.css("margin-top", parMarginTop + "px");

                                                    setTimeout(function () {
                                                        loadingDiv.css("opacity", 0);
                                                        setTimeout(function () {
                                                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapModalLoadingDiv").each(function (i) {
                                                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapModalLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                            });
                                                            loadingDiv.remove();
                                                        }, 350);
                                                    }, 1000);
                                                }
                                            }

                                        } else {
                                            console.log("Ko Heatmap");
                                            console.log(JSON.stringify(errorData));

                                            loadingDiv.empty();
                                            loadingDiv.append(loadKoText);

                                            parHeight = loadKoText.height();
                                            parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                            loadKoText.css("margin-top", parMarginTop + "px");

                                            setTimeout(function () {
                                                loadingDiv.css("opacity", 0);
                                                setTimeout(function () {
                                                    loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                        $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                    });
                                                    loadingDiv.remove();
                                                }, 350);
                                            }, 1000);

                                        }
                                    } catch (err) {
                                        loadingDiv.empty();
                                        loadingDiv.append(loadKoText);

                                        parHeight = loadKoText.height();
                                        parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                        loadKoText.css("margin-top", parMarginTop + "px");
                                        console.log("Error: " + err);
                                        setTimeout(function () {
                                            loadingDiv.css("opacity", 0);
                                            setTimeout(function () {
                                                loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                    $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                                });
                                                loadingDiv.remove();
                                            }, 350);
                                        }, 1000);
                                    }
                                },
                                error: function (errorData) {
                                    console.log("Ko Heatmap");
                                    console.log(JSON.stringify(errorData));

                                    loadingDiv.empty();
                                    loadingDiv.append(loadKoText);

                                    parHeight = loadKoText.height();
                                    parMarginTop = Math.floor((loadingDiv.height() - parHeight) / 2);
                                    loadKoText.css("margin-top", parMarginTop + "px");

                                    setTimeout(function () {
                                        loadingDiv.css("opacity", 0);
                                        setTimeout(function () {
                                            loadingDiv.nextAll("#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv").each(function (i) {
                                                $(this).css("top", ($('#<?= $_REQUEST['name_w'] ?>_div').height() - (($('#<?= $_REQUEST['name_w'] ?>_content div.gisMapLoadingDiv').length - 1) * loadingDiv.height())) + "px");
                                            });
                                            loadingDiv.remove();
                                        }, 350);
                                    }, 1000);

                                }
                            });

                        }


                        function distance(lat1, lon1, lat2, lon2, unit) {   // unit: 'K' for Kilometers
                            if ((lat1 == lat2) && (lon1 == lon2)) {
                                return 0;
                            }
                            else {
                                var radlat1 = Math.PI * lat1 / 180;
                                var radlat2 = Math.PI * lat2 / 180;
                                var theta = lon1 - lon2;
                                var radtheta = Math.PI * theta / 180;
                                var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
                                if (dist > 1) {
                                    dist = 1;
                                }
                                dist = Math.acos(dist);
                                dist = dist * 180 / Math.PI;
                                dist = dist * 60 * 1.1515;
                                if (unit == "K") { dist = dist * 1.609344 }
                                if (unit == "N") { dist = dist * 0.8684 }
                                return dist;
                            }
                        }

                        function getRadius() {
                            var radius;
                            var currentZoom = fullscreendefaultMapRef.getZoom();
                            if (estimateRadiusFlag && estimatedRadius) {
                                metresPerPixel = 40075016.686 * Math.abs(Math.cos(fullscreendefaultMapRef.getCenter().lat * Math.PI / 180)) / Math.pow(2, currentZoom + 8);
                                radius = ((estimatedRadius * 1000) / metresPerPixel) / 50;
                                if (radius > 1000) {

                                } else if (radius > 1) {
                                    if (currentZoom < prevZoom) {
                                        prevZoom = currentZoom;
                                        return radius / 1.2;
                                    } else {
                                        prevZoom = currentZoom;
                                        return radius / 1.2;
                                    }
                                } else {
                                    prevZoom = currentZoom;
                                    return 1;
                                }
                            }
                            if (prevZoom == null) {
                                prevZoom = widgetParameters.zoom;
                            }
                            if (currentZoom === 7) {
                                radius = 1;
                            }
                            else if (currentZoom === 8) {
                                radius = 1;
                            }
                            else if (currentZoom === 9) {
                                radius = 1;
                            }
                            else if (currentZoom === 10) {
                                if (currentZoom > prevZoom) {
                                    radius = 2;
                                } else {
                                    radius = 1;
                                }
                            }
                            else if (currentZoom === 11) {
                                if (currentZoom > prevZoom) {
                                    radius = 3.5;
                                } else {
                                    radius = 2;
                                }
                            }
                            else if (currentZoom === 12) {
                                if (currentZoom > prevZoom) {
                                    radius = 10;
                                } else {
                                    radius = 3.5;
                                }
                            }
                            else if (currentZoom === 13) {
                                if (currentZoom > prevZoom) {
                                    radius = 16;
                                } else {
                                    radius = 10;
                                }
                            }
                            else if (currentZoom === 14) {
                                if (currentZoom > prevZoom) {
                                    radius = 31;
                                } else {
                                    radius = 16;
                                }
                            }
                            else if (currentZoom === 15) {
                                if (currentZoom > prevZoom) {
                                    radius = 60;
                                } else {
                                    radius = 31;
                                }
                            }
                            else if (currentZoom === 16) {
                                if (currentZoom > prevZoom) {
                                    radius = 80;
                                } else {
                                    radius = 60;
                                }
                            }
                            else if (currentZoom === 17) {
                                if (currentZoom > prevZoom) {
                                    radius = 100;
                                } else {
                                    radius = 80;
                                }
                            }
                            else if (currentZoom === 18) {
                                if (currentZoom > prevZoom) {
                                    radius = 130;
                                } else {
                                    radius = 100;
                                }
                            }
                            prevZoom = currentZoom;
                            return radius;
                        }

                        //    fullscreendefaultMapRef.on('zoomstart', function(ev) {
                        fullscreendefaultMapRef.on('zoomend', function (ev) {
                            // zoom level changed... adjust heatmap layer options!
                            if (changeRadiusOnZoom === true) {
                                if (prevZoom === null) {
                                    prevZoom = widgetParameters.zoom;
                                }

                                if (baseQuery.includes("heatmap.php")) {    // OLD HEATMAP
                                    // INSERIRE CAMBIO SLIDER ZOOM
                                    document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_sliderradius").value = parseFloat(getRadius()).toFixed(1);
                                    setOption('radius', getRadius(), 1)           // MODALITA HEATMAP ON ZOOM
                                }
                            }
                        });

                        function initHeatmapLayer(heatmapRangeObject) {

                            var heatmapCfg = {};

                            map.cfg = JSON.parse(heatmapRangeObject[0].leafletConfigJSON);
                            //    map.cfg['blur'] = 0.85;
                            if (map.cfg == null) {
                                map.cfg = {};
                            }

                            if (current_radius != null) {
                                map.cfg['radius'] = current_radius;
                            }
                            if (current_opacity != null) {
                                map.cfg['maxOpacity'] = current_opacity;
                            }

                            fullscreenHeatmap = new HeatmapOverlay(map.cfg);
                            //map.heatmapLayer.zIndex = 20;
                            //  map.legendHeatmap = L.control({position: 'topright'});
                        }

                        function nextHeatmapPage() {
                            animationFlag = false;
                            if (current_page > 0) {
                                current_page--;
                                changeHeatmapPage(current_page);

                                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                                    if (map.eventsOnMap[i].eventType === 'heatmap') {
                                        removeHeatmap(false);
                                        map.eventsOnMap.splice(i, 1);
                                    } else if (map.eventsOnMap[i].eventType === undefined && map.eventsOnMap[i].type === undefined) {
                                        fullscreendefaultMapRef.eachLayer(function (layer) {
                                            fullscreendefaultMapRef.removeLayer(layer);
                                        });
                                        removeHeatmap(false);
                                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                            attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                                            maxZoom: leafletMaxZoom,
                                            maxNativeZoom: leafletNativeMaxZoom
                                        }).addTo(fullscreendefaultMapRef);
                                    }
                                }

                                if (addMode === 'additive') {
                                    //  if (baseQuery.includes("heatmap.php")) {
                                    // addHeatmapToMap();
                                    addHeatmapFromFullscreenClient(false);
                                    /*    } else {
                                            // addHeatmapFromWMSClient();        // TBD
                                        }*/
                                }
                                if (addMode === 'exclusive') {
                                    fullscreendefaultMapRef.eachLayer(function (layer) {
                                        fullscreendefaultMapRef.removeLayer(layer);
                                    });
                                    map.eventsOnMap.length = 0;

                                    //Remove WidgetAlarm active pins
                                    $.event.trigger({
                                        type: "removeAlarmPin",
                                    });
                                    //Remove WidgetEvacuationPlans active pins
                                    $.event.trigger({
                                        type: "removeEvacuationPlanPin",
                                    });
                                    //Remove WidgetEvents active pins
                                    $.event.trigger({
                                        type: "removeEventFIPin",
                                    });
                                    //Remove WidgetResources active pins
                                    $.event.trigger({
                                        type: "removeResourcePin",
                                    });
                                    //Remove WidgetOperatorEvents active pins
                                    $.event.trigger({
                                        type: "removeOperatorEventPin",
                                    });
                                    //Remove WidgetTrafficEvents active pins
                                    $.event.trigger({
                                        type: "removeTrafficEventPin",
                                    });
                                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                                        maxZoom: leafletMaxZoom,
                                        maxNativeZoom: leafletNativeMaxZoom
                                    }).addTo(fullscreendefaultMapRef);

                                    addHeatmapFromClient();
                                }

                            }
                        }

                        //   window.nextHeatmapPage = function()
                        function prevHeatmapPage() {
                            animationFlag = false;
                            if (current_page < numHeatmapPages() - 1) {
                                current_page++;
                                changeHeatmapPage(current_page);

                                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                                    if (map.eventsOnMap[i].eventType === 'heatmap') {
                                        removeHeatmap(false);
                                        //    removeHeatmapColorLegend(i, false);
                                        map.eventsOnMap.splice(i, 1);
                                    } else if (map.eventsOnMap[i].eventType === undefined && map.eventsOnMap[i].type === undefined) {
                                        //  fullscreendefaultMapRef.removeLayer(map.eventsOnMap[i]);
                                        fullscreendefaultMapRef.eachLayer(function (layer) {
                                            fullscreendefaultMapRef.removeLayer(layer);
                                        });
                                        removeHeatmap(false);
                                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                            attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                                            maxZoom: leafletMaxZoom,
                                            maxNativeZoom: leafletNativeMaxZoom
                                        }).addTo(fullscreendefaultMapRef);
                                    }
                                }

                                if (addMode === 'additive') {
                                    //  if (baseQuery.includes("heatmap.php")) {
                                    // addHeatmapToMap();
                                    addHeatmapFromFullscreenClient(false);
                                    /*    } else {
                                            // addHeatmapFromWMSClient();        // TBD
                                        }*/
                                }
                                if (addMode === 'exclusive') {
                                    fullscreendefaultMapRef.eachLayer(function (layer) {
                                        fullscreendefaultMapRef.removeLayer(layer);
                                    });
                                    map.eventsOnMap.length = 0;

                                    //Remove WidgetAlarm active pins
                                    $.event.trigger({
                                        type: "removeAlarmPin",
                                    });
                                    //Remove WidgetEvacuationPlans active pins
                                    $.event.trigger({
                                        type: "removeEvacuationPlanPin",
                                    });
                                    //Remove WidgetEvents active pins
                                    $.event.trigger({
                                        type: "removeEventFIPin",
                                    });
                                    //Remove WidgetResources active pins
                                    $.event.trigger({
                                        type: "removeResourcePin",
                                    });
                                    //Remove WidgetOperatorEvents active pins
                                    $.event.trigger({
                                        type: "removeOperatorEventPin",
                                    });
                                    //Remove WidgetTrafficEvents active pins
                                    $.event.trigger({
                                        type: "removeTrafficEventPin",
                                    });
                                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                        attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                                        maxZoom: leafletMaxZoom,
                                        maxNativeZoom: leafletNativeMaxZoom
                                    }).addTo(fullscreendefaultMapRef);

                                    addHeatmapFromFullscreenClient(false);
                                }
                            }
                        }

                        function animateFullscreenHeatmap() {
                            for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                                if (map.eventsOnMap[i].eventType === 'heatmap') {
                                    removeHeatmap(false);
                                    map.eventsOnMap.splice(i, 1);
                                } else if (map.eventsOnMap[i].type === 'addHeatmap') {
                                    removeHeatmapColorLegend(i, false);
                                    map.eventsOnMap.splice(i, 1);
                                } else if (map.eventsOnMap[i] !== null && map.eventsOnMap[i] !== undefined) {
                                    if (map.eventsOnMap[i].eventType != 'trafficRealTimeDetails') {
                                        map.defaultMapRef.removeLayer(map.eventsOnMap[i]);
                                        map.eventsOnMap.splice(i, 1);
                                    }
                                }
                            }
                            if (animationFlag === false) {
                                animationFlag = true;
                                addHeatmapFromFullscreenClient(animationFlag);
                            } else {
                                animationFlag = false;
                                for (let i = map.eventsOnMap.length - 1; i >= 0; i--) {
                                    if (map.eventsOnMap[i].eventType === 'heatmap') {
                                        removeHeatmap(false);
                                        //    removeHeatmapColorLegend(i, false);
                                        map.eventsOnMap.splice(i, 1);
                                    } /*else if (map.eventsOnMap[i].type === 'addHeatmap') {
                                                removeHeatmapColorLegend(i, false);
                                                map.eventsOnMap.splice(i, 1);
                                            }*/
                                }
                                addHeatmapFromFullscreenClient(animationFlag);
                            }
                        }

                        function changeHeatmapPage(page) {
                            var btn_next = document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_nextButt");
                            var btn_prev = document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_prevButt");
                            var heatmapDescr = document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_heatMapDescr");

                            // Validate page
                            if (numHeatmapPages() > 1) {
                                if (page < 1) page = 1;
                                if (page > numHeatmapPages()) page = numHeatmapPages();

                                if (current_page == 0) {
                                    btn_next.style.visibility = "hidden";
                                } else {
                                    btn_next.style.visibility = "visible";
                                }

                                if (current_page == numHeatmapPages() - 1) {
                                    btn_prev.style.visibility = "hidden";
                                } else {
                                    btn_prev.style.visibility = "visible";
                                }
                            }

                            if (current_page < numHeatmapPages()) {
                                //  $("#modalLinkOpenHeatMapDescr").text(heatmapData[current_page].metadata[0].date); // OLD-API
                                //   heatmapDescr.text(heatmapData[current_page].metadata.date);
                                //heatmapDescr.firstChild.wholeText = heatmapData[current_page].metadata.date;
                                // heatmapData[current_page].metadata[0].date

                                if (heatmapData[current_page].metadata != null) {
                                    heatmapDescr.firstChild.wholeText = heatmapData[current_page].metadata.date;
                                } else {
                                    heatmapDescr.firstChild.wholeText = heatmapData[current_page].dateTime;
                                }
                            }
                        }

                        function numHeatmapPages() {
                            //   return Math.ceil(heatmapData.length / records_per_page);
                            return heatmapData.length;
                        }


                        function updateChangeRadiusOnZoom(htmlElement) {
                            if (htmlElement.checked) {
                                changeRadiusOnZoom = true;
                                $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad").attr('disabled', false);
                            } else {
                                changeRadiusOnZoom = false;
                                $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad").attr('disabled', true);
                            }
                            //  $("#radiusEstCnt").toggle(htmlElement.checked);
                        }

                        function computeRadiusOnData(htmlElement) {
                            if (htmlElement.checked) {
                                estimateRadiusFlag = true;
                                $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad").attr('disabled', true);
                            } else {
                                estimateRadiusFlag = false;
                                $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad").attr('disabled', false);
                            }
                        }

                        function setOption(option, value, decimals) {
                            if (baseQuery.includes("heatmap.php")) {
                                if (option == "radius") {       // AGGIUNGERE SE FLAG è TRUE SI METTE IL VALORE DI CONFIG
                                    if (resetPageFlag) {
                                        if (resetPageFlag === true) {
                                            current_radius = map.cfg['radius'];
                                        } else {
                                            current_radius = Math.max(value, 2);
                                        }
                                    } else {
                                        current_radius = Math.max(value, 2);
                                    }
                                    map.cfg["radius"] = current_radius.toFixed(1);
                                    if (decimals) {
                                        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_range" + option).text(parseFloat(current_radius).toFixed(parseInt(decimals)));
                                        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slider" + option).attr("value", parseFloat(current_radius).toFixed(parseInt(decimals)));
                                    }
                                } else if (option == "maxOpacity") {
                                    if (resetPageFlag) {
                                        if (resetPageFlag === true) {
                                            current_opacity = map.cfg['maxOpacity'];
                                        } else {
                                            current_opacity = value;
                                        }
                                    } else {
                                        current_opacity = value;
                                    }
                                    map.cfg["maxOpacity"] = current_opacity;
                                    if (decimals) {
                                        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_range" + option).text(parseFloat(current_opacity).toFixed(parseInt(decimals)));
                                        $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slider" + option).attr("value", parseFloat(current_opacity).toFixed(parseInt(decimals)));
                                    }
                                }
                                // update the heatmap with the new configuration
                                //  map.heatmapLayer.configure(map.cfg);
                                fullscreenHeatmap.configure(map.cfg);
                            } else {
                                if (option == "maxOpacity") {
                                    if (wmsLayerFullscreen) {
                                        wmsLayerFullscreen.setOpacity(value);
                                        current_opacity = value;
                                        if (decimals) {
                                            $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_range" + option).text(parseFloat(current_opacity).toFixed(parseInt(decimals)));
                                            $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slider" + option).attr("value", parseFloat(current_opacity).toFixed(parseInt(decimals)));
                                        }
                                    }
                                }
                                fullscreenHeatmap.configure(map.cfg);
                            }

                        }

    function upSlider(color, step, decimals, max) {
        let value = $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slider" + color).attr("value");
        if (parseFloat(parseFloat(value) + parseFloat(step)) <= max) {
            $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_range" + color).text(parseFloat(parseFloat(value) + parseFloat(step)).toFixed(parseInt(decimals)));
            document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slider" + color).value = parseFloat(parseFloat(value) + parseFloat(step)).toFixed(parseInt(decimals));
            $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slider" + color).trigger('change');
        }
    }

    function downSlider(color, step, decimals, min) {
        let value = $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slider" + color).attr("value");
        if (parseFloat(parseFloat(value) - parseFloat(step)) >= min) {
            $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_range" + color).text(parseFloat(parseFloat(value) - parseFloat(step)).toFixed(parseInt(decimals)));
            document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slider" + color).value = parseFloat(parseFloat(value) - parseFloat(step)).toFixed(parseInt(decimals));
            $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slider" + color).trigger('change');
        }
    }

    function removeHeatmap(resetPageFlag) {
        if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
            if (resetPageFlag == true) {
                current_page = 0;     // CTR SE VA BENE BISOGNA DISTINGUERE IL CASO CHE SI STIA NAVIGANDO LA STESSA HEATMAP_NAME OPPURE UN'ALTRA NUOVA HEATMP_NAME
                current_radius = null;
                current_opacity = null;
                changeRadiusOnZoom = false;
                estimateRadiusFlag = false;
                estimatedRadius = null;
                wmsDatasetName = null;
            }
            //   map.testData = [];
            if (wmsLayerFullscreen) {
                fullscreendefaultMapRef.removeLayer(wmsLayerFullscreen);
                wmsLayerFullscreen = null;
            } else {
                fullscreenHeatmap.setData({ data: [] });
                fullscreendefaultMapRef.removeLayer(fullscreenHeatmap);
                fullscreenHeatmap = null;
            }
            if (resetPageFlag != true) {
                if (map.cfg["radius"] != current_radius) {
                    setOption('radius', current_radius, 1);
                }
                if (map.cfg["maxOpacity"] != current_opacity) {
                    setOption('maxOpacity', current_opacity, 2);
                }
            }
            fullscreendefaultMapRef.removeControl(legendHeatmapFullscreen);
            if (heatmapLegendColorsFullscreen) {
                fullscreendefaultMapRef.removeControl(heatmapLegendColorsFullscreen);
            }
        } else {    // NEW WMS HEATMAP
            if (resetPageFlag == true) {
                current_page = 0;
            }
            if (fullscreenHeatmap) {
                fullscreenHeatmap.setData({ data: [] });
                fullscreendefaultMapRef.removeLayer(fullscreenHeatmap);
                fullscreenHeatmap = null;
            }
            if (wmsLayerFullscreen) {
                fullscreendefaultMapRef.removeLayer(wmsLayerFullscreen);
                wmsLayerFullscreen = null;
            }
            fullscreendefaultMapRef.removeControl(legendHeatmapFullscreen);
            fullscreendefaultMapRef.removeControl(heatmapLegendColorsFullscreen);
        }
    }

    function removeHeatmapColorLegend(index, resetPageFlag) {
        if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
            if (resetPageFlag == true) {
                current_page = 0;     // CTR SE VA BENE BISOGNA DISTINGUERE IL CASO CHE SI STIA NAVIGANDO LA STESSA HEATMAP_NAME OPPURE UN'ALTRA NUOVA HEATMP_NAME
                current_radius = null;
                current_opacity = null;
                changeRadiusOnZoom = false;
                estimateRadiusFlag = false;
                estimatedRadius = null;
                wmsDatasetName = null;
            }
            map.testData = [];
            fullscreenHeatmap.setData({ data: [] });
            fullscreendefaultMapRef.removeLayer(fullscreenHeatmap);
            if (resetPageFlag != true) {
                if (map.cfg["radius"] != current_radius) {
                    setOption('radius', current_radius, 1);
                }
                if (map.cfg["maxOpacity"] != current_opacity) {
                    setOption('maxOpacity', current_opacity, 2);
                }
            }
            //    fullscreendefaultMapRef.removeControl(map.eventsOnMap[index].legendColors);
            fullscreendefaultMapRef.removeControl(heatmapLegendColorsFullscreen);
        } else {    // NEW WMS HEATMAP
            if (resetPageFlag == true) {
                current_page = 0;
            }
            //    fullscreendefaultMapRef.removeControl(map.eventsOnMap[index].legendColors);
            fullscreendefaultMapRef.removeControl(heatmapLegendColorsFullscreen);
            if (wmsLayerFullscreen) {
                fullscreendefaultMapRef.removeLayer(wmsLayerFullscreen);
            }
        }
    }

    function updateChangeRadiusOnZoom(htmlElement) {
        if (htmlElement.checked) {
            changeRadiusOnZoom = true;
            $("#<?= $_REQUEST['name_w'] ?>_estimateRad").attr('disabled', false);
        } else {
            changeRadiusOnZoom = false;
            $("#<?= $_REQUEST['name_w'] ?>_estimateRad").attr('disabled', true);
        }
        //  $("#radiusEstCnt").toggle(htmlElement.checked);
    }

    function computeRadiusOnData(htmlElement) {
        if (htmlElement.checked) {
            estimateRadiusFlag = true;
            $("#<?= $_REQUEST['name_w'] ?>_changeRad").attr('disabled', true);
        } else {
            estimateRadiusFlag = false;
            $("#<?= $_REQUEST['name_w'] ?>_changeRad").attr('disabled', false);
        }
    }

    legendHeatmapFullscreen.onAdd = function () {
        let legendHeatmapDiv = L.DomUtil.create('div');
        legendHeatmapDiv.id = "heatmapLegend";
        // disable interaction of this div with map
        if (L.Browser.touch) {
            L.DomEvent.disableClickPropagation(legendHeatmapDiv);
            L.DomEvent.on(legendHeatmapDiv, 'mousewheel', L.DomEvent.stopPropagation);
        } else {
            L.DomEvent.on(legendHeatmapDiv, 'click', L.DomEvent.stopPropagation);
        }
        legendHeatmapDiv.style.width = "340px";
        legendHeatmapDiv.style.fontWeight = "bold";
        legendHeatmapDiv.style.background = "#cccccc";
        //map.legendHeatmap.style.background = "-webkit-gradient(linear, left top, left bottom, from(#eeeeee), to(#cccccc))";
        legendHeatmapDiv.style.padding = "10px";

        //categories = ['blue', 'cyan', 'green', 'yellowgreen', 'yellow', 'gold', 'orange', 'darkorange', 'tomato', 'orangered', 'red'];
        let colors = [];
        /*   colors['blue'] = '#0000FF';
           colors['cyan'] = '#00FFFF';
           colors['green'] = '#008000';
           colors['yellowgreen'] = '#9ACD32';
           colors['yellow'] = '#FFFF00';
           colors['gold'] = '#FFD700';
           colors['orange'] = '#FFA500';
           colors['darkorange'] = '#FF8C00';
           colors['orangered'] = '#FF4500';
           colors['tomato'] = '#FF6347';
           colors['red'] = '#FF0000';  */
        colors['blue'] = 'rgb(0,0,255)';
        colors['cyan'] = 'rgb(0,153,255)';
        colors['green'] = 'rgb(0,153,0)';
        colors['yellowgreen'] = 'rgb(0,255,0)';
        colors['yellow'] = 'rgb(255,255,0)';
        colors['gold'] = 'rgb(255,187,0)';
        colors['orange'] = 'rgb(255,102,0)';
        colors['red'] = 'rgb(255,0,0)';
        colors['darkred'] = 'rgb(153,0,0)';
        colors['maroon'] = 'rgb(84, 0, 0)';
        //   colors['red'] = '#FF0000';
        let colors_value = [];
        colors_value['blue'] = 'rgb(0,0,255)';
        colors_value['cyan'] = 'rgb(0,153,255)';
        colors_value['green'] = 'rgb(0,153,0)';
        colors_value['yellowgreen'] = 'rgb(0,255,0)';
        colors_value['yellow'] = 'rgb(255,255,0)';
        colors_value['gold'] = 'rgb(255,187,0)';
        colors_value['orange'] = 'rgb(255,102,0)';
        colors_value['red'] = 'rgb(255,0,0)';
        colors_value['darkred'] = 'rgb(153,0,0)';
        colors_value['maroon'] = 'rgb(84, 0, 0)';
        //  colors_value['red'] = '#FF0000';
        //   legendHeatmapDiv.innerHTML += '<div class="textTitle" style="text-align:center">' + heatmapMetricName + '</div>';
        //    legendHeatmapDiv.innerHTML += '<div class="textTitle" style="text-align:center">' + map.testMetadata.metadata[0].mapName + + '</div>'; // OLD-API
        legendHeatmapDiv.innerHTML += '<div class="textTitle" style="text-align:center">' + mapName + '</div>';
        legendHeatmapDiv.innerHTML += '<div class="text">' + '<?php echo ucfirst(isset($_REQUEST["profile"]) ? $_REQUEST["profile"] : "Heatmap Controls"); ?>' + '</div>';
                                  /*  if (!baseQuery.includes("heatmap.php")) {
                                        legendHeatmapDiv.innerHTML += '<div id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_controlsContainer" style="height: 20px"><div class="text"  style="width: 50 %; float:left">' + '<?php echo ucfirst(isset($_REQUEST["profile"]) ? $_REQUEST["profile"] : "Heatmap Controls:"); ?></div><div class="text" style="width: 50 %; float:right"><label class="switch"><input type="checkbox" id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_animation"><div class="slider round"><span class="animationOn"></span><span class="animationOff" style="color: black; text - align: right">24H</span><span class="animationOn" style="color: black; text - align: right">Static</span></div></label></div></div>';
    } else {
        legendHeatmapDiv.innerHTML += '<div class="text">' + '<?php echo ucfirst(isset($_REQUEST["profile"]) ? $_REQUEST["profile"] : "Heatmap Controls:"); ?></div>';
    }*/
    // radius
    if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
        legendHeatmapDiv.innerHTML +=
            '<div id="heatmapRadiusControl" style="margin-top:10px">' +
            '<div style="display:inline-block; vertical-align:super;">Radius (px):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>' +
            '<div id= "<?= $_REQUEST['name_w'] ?>_modalLinkOpen_downSlider_radius" style="display:inline-block; vertical-align:super; color: #0078A8">&#10094;</div>&nbsp;&nbsp;&nbsp;' +
            //  '<input id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_sliderradius" style="display:inline-block; vertical-align:baseline; width:auto" type="range" min="0" max="0.0010" value="0.0008" step="0.00001">' +
            //  '<input id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_sliderradius" style="display:inline-block; vertical-align:baseline; width:auto" type="range" min="1" max="' + estimatedRadius * 50 + '" value="' + current_radius + '" step="' + Math.floor((estimatedRadius * 50)/40) + '">' +
            '<input id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_sliderradius" style="display:inline-block; vertical-align:baseline; width:auto" type="range" min="1" max="' + estimatedRadius * 30 + '" value="' + current_radius + '" step="2">' +
            '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<div id="upSlider_radius" style="display:inline-block; vertical-align:super; color: #0078A8">&#10095;</div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
            '<span id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_rangeradius" style="display:inline-block; vertical-align:super;">' + current_radius + '</span>' +
            '</div>';
    }
    // max opacity
    legendHeatmapDiv.innerHTML +=
        '<div id="heatmapOpacityControl">' +
        '<div style="display:inline-block; vertical-align:super;">Max Opacity: &nbsp;&nbsp;&nbsp;&nbsp;</div>' +
        '<div id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_downSlider_opacity" style="display:inline-block; vertical-align:super; color: #0078A8">&#10094;</div>&nbsp;&nbsp;&nbsp;' +
        '<input id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slidermaxOpacity" style="display:inline-block; vertical-align:baseline; width:auto" type="range" min="0" max="1" value="' + current_opacity + '" step="0.01">' +
        '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<div id="upSlider_opacity" style="display:inline-block;vertical-align:super; color: #0078A8">&#10095;</div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
        '<span id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_rangemaxOpacity" style="display:inline-block;vertical-align:super;">' + current_opacity + '</span>' +
        '</div>';
    legendHeatmapDiv.innerHTML +=
        '<div id="heatmapNavigationCnt">' +
        '<input type="button" id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_prevButt" value="< Prev" style="float: left"/>' +
        '<input type="button" id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_nextButt" value="Next >" style="float: right"/>' +
        //  '<div id="modalLinkOpenHeatMapDescr" style="text-align: center">' + map.testMetadata.metadata[0].date + '</p>' +  // OLD-API
        '<div id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_heatMapDescr" style="text-align: center">' + mapDate + '</p>' +
        '</div>';
    if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
        legendHeatmapDiv.innerHTML +=
            '<div id="radiusCnt">' +
            // '<input type="checkbox" name="checkfield" id="g01-01" onchange="updateChangeRadiusOnZoom(this)"/> Change Radius on Zoom' +
            '<input type="checkbox" name="checkfield" id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad"/> Change Radius on Zoom' +
            '</div>';
        legendHeatmapDiv.innerHTML +=
            '<div id="radiusEstCnt">' +
            // '<input type="checkbox" name="checkfield" id="g01-01" onchange="updateChangeRadiusOnZoom(this)"/> Change Radius on Zoom' +
            '<input type="checkbox" name="checkfield" id="<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad" disabled="true"/> Estimate Radius Based on Data' +
            '</div>';
    }

    function checkLegend() {
                                      /*  if(document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_downSlider_radius") == null){
        setTimeout(checkLegend, 500);
    }
                                        else {   */
        if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
            document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_sliderradius").addEventListener("input", function () { setOption('radius', this.value, 1) }, false);
        }
        document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_slidermaxOpacity").addEventListener("input", function () { setOption('maxOpacity', this.value, 2) }, false);

        if (!baseQuery.includes("heatmap.php")) {
            document.getElementById("<?= $_REQUEST['name_w'] ?>_animation").addEventListener("click", function () { animateFullscreenHeatmap() }, false);
        }

        document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_prevButt").addEventListener("click", function () { prevHeatmapPage() }, false);
        document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_nextButt").addEventListener("click", function () { nextHeatmapPage() }, false);

        if (baseQuery.includes("heatmap.php")) {   // OLD HEATMAP
            document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad").addEventListener("change", function () { updateChangeRadiusOnZoom(this) }, false);
            document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad").addEventListener("change", function () { computeRadiusOnData(this) }, false);
        }

        if (current_page == 0) {
            document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_nextButt").style.visibility = "hidden";
        } else {
            document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_nextButt").style.visibility = "visible";
        }

        if (current_page == numHeatmapPages() - 1) {
            document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_prevButt").style.visibility = "hidden";
        } else {
            document.getElementById("<?= $_REQUEST['name_w'] ?>_modalLinkOpen_prevButt").style.visibility = "visible";
        }
        //    }
    }
    setTimeout(checkLegend, 500);

    return legendHeatmapDiv;
                                };

    if (current_radius != null) {
        map.cfg['radius'] = current_radius;
    }
    if (current_opacity != null) {
        map.cfg['maxOpacity'] = current_opacity;
    }

    //   map.heatmapLayer.setData({max:heatmapRange[0].range10Inf, min:heatmapRange[0].range1Inf, data:map.testData.data});

    fullscreenHeatmap = new HeatmapOverlay(map.cfg);

    if (baseQuery.includes("heatmap.php")) {
        fullscreenHeatmap.setData(map.testData);
        fullscreendefaultMapRef.addLayer(fullscreenHeatmap);
    } else {
        if (animationFlag === false) {

            map.defaultMapRef.createPane('Snap4City:' + wmsDatasetName);    // CORTI
            map.defaultMapRef.getPane('Snap4City:' + wmsDatasetName).style.zIndex = 420;    // CORTI

            var timestamp = map.testMetadata.metadata.date;
            var timestampISO = timestamp.replace(" ", "T") + ".000Z";
            //    wmsLayerFullscreen = L.tileLayer.wms("https://wmsserver.snap4city.org/geoserver/Snap4City/wms", {
            wmsLayerFullscreen = L.tileLayer.wms(geoServerUrl + "geoserver/Snap4City/wms", {
                layers: 'Snap4City:' + wmsDatasetName,
                format: 'image/png',
                crs: L.CRS.EPSG4326,
                transparent: true,
                opacity: current_opacity,
                time: timestampISO,
                //  bbox: [24.7926004025304,60.1025194986424,25.1905923952885,60.2516802986263],
                tiled: true,   // TESTARE COME ANTWERP ??
                //  attribution: "IGN ©"
                pane: 'Snap4City:' + wmsDatasetName	// CORTI
            }).addTo(fullscreendefaultMapRef);
        } else {
            // ANIMATION WMS HEATMAP

            map.defaultMapRef.createPane('Snap4City:' + wmsDatasetName);    // CORTI
            map.defaultMapRef.getPane('Snap4City:' + wmsDatasetName).style.zIndex = 420;    // CORTI

            var animationCurrentDayTimestamp = [];
            var animationCurrentDayFwdTimestamp = [];
            var animationCurrentDayBckwdTimestamp = [];
            var animationStringTimestamp = "";
            var timestamp = map.testMetadata.metadata.date;
            //    var timestampISO = timestamp.replace(" ", "T") + ".000Z";
            var day = timestamp.substring(0, 10);
            if (current_page == 0) {
                var offsetFwd = current_page;
                while (heatmapData[offsetFwd].metadata['date'].substring(0, 10) == day) {
                    animationCurrentDayFwdTimestamp.push(heatmapData[offsetFwd].metadata['date'].replace(" ", "T") + ".000Z");
                    offsetFwd++;
                }
            } else if (current_page == numHeatmapPages() - 1) {
                var offsetBckwd = current_page - 1;
                while (heatmapData[offsetBckwd].metadata['date'].substring(0, 10) == day) {
                    animationCurrentDayBckwdTimestamp.push(heatmapData[offsetBckwd].metadata['date'].replace(" ", "T") + ".000Z");
                    offsetBckwd--;
                    if (offsetBckwd < 0) {
                        break;
                    }
                }
            } else {
                var offsetFwd = current_page;
                while (heatmapData[offsetFwd].metadata['date'].substring(0, 10) == day) {
                    animationCurrentDayFwdTimestamp.push(heatmapData[offsetFwd].metadata['date'].replace(" ", "T") + ".000Z");
                    offsetFwd++;
                }
                var offsetBckwd = current_page - 1;
                while (heatmapData[offsetBckwd].metadata['date'].substring(0, 10) == day) {
                    animationCurrentDayBckwdTimestamp.push(heatmapData[offsetBckwd].metadata['date'].replace(" ", "T") + ".000Z");
                    offsetBckwd--;
                    if (offsetBckwd < 0) {
                        break;
                    }
                }
            }

            animationCurrentDayTimestamp = animationCurrentDayFwdTimestamp.reverse().concat(animationCurrentDayBckwdTimestamp);
            //    animationCurrentDayTimestamp = animationCurrentDayTimestamp.reverse();
            animationStringTimestamp = animationCurrentDayTimestamp.join(",");

            var bboxJson = {};
            $.ajax({
                //    url: "https://heatmap.snap4city.org/bbox.php?layer=" + map.testMetadata.metadata.mapName,
                url: heatmapUrl + "bbox.php?layer=" + map.testMetadata.metadata.mapName,
                type: "GET",
                async: false,
                dataType: 'json',
                success: function (resultBbox) {
                    bboxJson = resultBbox;
                },
                error: function (errbbox) {
                    alert("Error in retrieving bounding box for current heatmap: " + mapName);
                    console.log(errbbox);
                }
            });

            var upEastLat = parseFloat(bboxJson['maxy']);
            var upEastLon = parseFloat(bboxJson['maxx']);
            var bottomWestLat = parseFloat(bboxJson['miny']);
            var bottomWestLon = parseFloat(bboxJson['minx']);
            //    var imageUrl = 'https://wmsserver.snap4city.org/geoserver/wms/animate?LAYERS=' + wmsDatasetName + '&aparam=time&avalues=' + animationStringTimestamp + '&format=image/gif;subtype=animated&format_options=gif_loop_continuosly:true;layout:message;gif_frames_delay:500&transparent=true';
            var imageUrl = geoServerUrl + 'geoserver/wms/animate?LAYERS=' + wmsDatasetName + '&aparam=time&avalues=' + animationStringTimestamp + '&format=image/gif;subtype=animated&format_options=gif_loop_continuosly:true;layout:message;gif_frames_delay:500&transparent=true';
            var imageBounds = [[bottomWestLat, bottomWestLon], [upEastLat, upEastLon]];
            var overlayOpacity = current_opacity;

            // ANIMATED GIF LAYER
            var animatedLayer = L.imageOverlay(imageUrl, imageBounds, { opacity: overlayOpacity, pane: 'Snap4City:' + wmsDatasetName }).addTo(fullscreendefaultMapRef);

        }
    }

    //  fullscreendefaultMapRef.addLayer(map.heatmapLayer);

    legendHeatmapFullscreen.addTo(fullscreendefaultMapRef);

    heatmapLegendColorsFullscreen = L.control({ position: 'bottomleft' });

    heatmapLegendColorsFullscreen.onAdd = function (map) {

        var div = L.DomUtil.create('div', 'info legend'),
            grades = ["Legend"];
        //    labels = ["http://localhost/dashboardSmartCity/trafficRTDetails/legend.png"];
        var legendImgPath = heatmapRange[0].iconPath;
        div.innerHTML += " <img src=" + legendImgPath + " height='100%'" + '<br>';
        return div;
    };

    heatmapLegendColorsFullscreen.addTo(fullscreendefaultMapRef);

    if (changeRadiusOnZoom) {
        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad').prop('checked', true);
        if (estimateRadiusFlag) {
            $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_changeRad').prop('disabled', true);
        }
    }

    if (estimateRadiusFlag) {
        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad').prop('checked', true);
        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad').prop('disabled', false);
    } else {
        $('#<?= $_REQUEST['name_w'] ?>_modalLinkOpen_estimateRad').prop('disabled', false);
    }

                            }

                          //  resizeMapView(fullscreendefaultMapRef);
                        }

                    }
                }, 750);    // PANTALEO - AUMENTARE UN PO' IL VALORE DI setTimeOut QUI SE LA MAPPA NON CARICA ABBASTANZA VELOCEMENTE SE HA UNA HEATMAP DI DEFAULT

    $("#<?= $_REQUEST['name_w'] ?>_modalLinkOpen").modal('show');

            });


    var openWs = function (widget) {
        try {
            <?php
            echo 'wsRetryActive = "' . $wsRetryActive . '";' . "\n";
            echo 'wsRetryTime = ' . $wsRetryTime . ';' . "\n";
            echo 'wsUrl="' . $wsProtocol . '://' . $wsServerAddress . ':' . $wsServerPort . '/' . $wsPath . '";' . "\n";
            ?>
            //webSocket = new WebSocket(wsUrl);
            initWebsocket(widget, wsUrl, null, wsRetryTime * 1000, function (socket) {
                console.log('socket initialized!');
                //do something with socket...
                //Window.webSockets["<?= $_REQUEST['name_w'] ?>"] = socket;
                openWsConn(widget);
            }, function () {
                console.log('init of socket failed!');
            });
            //   webSocket.addEventListener('open', openWsConn);
            //   webSocket.addEventListener('close', wsClosed);
        }
        catch (e) {
            wsClosed();
        }
    };

    var manageIncomingWsMsg = function (msg) {
        var msgObj = JSON.parse(msg.data);
        console.log(msgObj);
        if (msgObj.msgType == "DataToEmitter") {
            if (currentValue != msgObj.newValue) {
                updatedEverFlag = true;
                updatedFlag = true;
                lastValueOk = msgObj.newValue;
                //  showUpdateResult("Device OK");
            }
        }
        if (msgObj.msgType == "DataToEmitterAck") {
            /*    $.event.trigger({
                    type: "addSelectorPin",
                    //    type: "addBubbleChart",
                    target: widgetName,
                    passedData: JSON.parse('{"desc":"Traffic Sensors","query":"https:\/\/servicemap.disit.org\/WebAppGrafo\/api\/v1\/?queryId=76e0be36369db8598c6573716e84ae6c&format=json","color1":"rgba(201,24,0,1)","color2":"rgba(201,24,0,0.36)","targets":"w_METRO588_1755_widgetTimeTrend22614","display":"undefined","queryType":"Default","iconTextMode":"icon","pinattr":"square","pincolor":"Default","symbolcolor":"undefined","iconFilePath":"..\/img\/widgetSelectorIconsPool\/subnature\/TransferServiceAndRenting_SensorSite.svg","altViewMode":"","bubbleSelectedMetric":""}')
                }); */
            if (lastValueOk) {
                //   currentValue = lastValueOk;
                lastValueOk = null;
                //    handleMouseDown();
                //    handleExtUpdate();
                $('#<?= $_REQUEST['name_w'] ?>_onOffButton').off('click');
                //    showUpdateResult("Device OK");
            } else {
                var webSocket = Window.webSockets[msgObj.widgetUniqueName];
                if (!webSocket.ackReceived) {
                    clearTimeout(webSocket.timeout);
                    webSocket.ackReceived = true;
                    console.log(msgObj.widgetUniqueName + " ACK ackReceived:" + webSocket.ackReceived)
                    webSocket.onAck({ result: "Ok", widgetName: msgObj.widgetUniqueName });
                }
            }

            //    if (rowParameters) {
            //        checkAndViewFromNR(rowParameters);
            //     }
        }
        if (msgObj.msgType == "newNRMetricData") {
            checkAndViewFromNR(msgObj.newValue);
        }
    };

    var openWsConn = function (widget) {
        var webSocket = Window.webSockets[widget];
        var wsRegistration = {
            msgType: "ClientWidgetRegistration",
            userType: "widgetInstance",
            //   metricName: encodeURIComponent(metricName),
            widgetUniqueName: "<?= $_REQUEST['name_w'] ?>"
        };
        webSocket.send(JSON.stringify(wsRegistration));
        /*setTimeout(function(){
            var webSocket = Window.webSockets[widget];
            webSocket.removeEventListener('message', manageIncomingWsMsg);
            webSocket.close();
        }, (timeToReload - 2)*1000);*/

        webSocket.addEventListener('message', manageIncomingWsMsg);
    };

    var wsClosed = function (e) {
        var webSocket = Window.webSockets["<?= $_REQUEST['name_w'] ?>"];
        webSocket.removeEventListener('message', manageIncomingWsMsg);
        if (wsRetryActive === 'yes') {
            setTimeout(openWs, parseInt(wsRetryTime * 1000));
        }
    };


    function initWebsocket(widget, url, existingWebsocket, retryTimeMs, success, failed) {
        if (!existingWebsocket || existingWebsocket.readyState != existingWebsocket.OPEN) {
            if (existingWebsocket) {
                existingWebsocket.close();
            }
            var websocket = new WebSocket(url);
            websocket.widget = widget;
            console.log("store websocket for " + widget)
            Window.webSockets[widget] = websocket;
            websocket.onopen = function () {
                console.info('websocket opened! url: ' + url);
                success(websocket);
            };
            websocket.onclose = function () {
                console.info('websocket closed! url: ' + url + " reconnect in " + retryTimeMs + "ms");
                //reconnect after a retryTime
                setTimeout(function () {
                    initWebsocket(widget, url, existingWebsocket, retryTimeMs, success, failed);
                }, retryTimeMs);
            };
            websocket.onerror = function (e) {
                console.info('websocket error! url: ' + url);
                console.info(e);
            };
        } else {
            success(existingWebsocket);
        }
        return;
    };

    function checkAndViewFromNR(rowParams) {
        if (rowParams) {
            var rowParamsObject = rowParams;
            if (IsJsonString(rowParams)) {
                rowParamsObject = JSON.parse(rowParams);
            }
            if (rowParamsObject.length) {
                for (const rowParamsObj of rowParamsObject) {
                    viewFromNRSingleObj(rowParamsObj);
                }
            } else {
                viewFromNRSingleObj(rowParamsObject);
            }
        }
    }

    function viewFromNRSingleObj(rowParamsObj) {
        var type = rowParamsObj['type'];
        var target = rowParamsObj['target'];
        var passedData = rowParamsObj['passedData'];
        var passedParams = null;
        if (rowParamsObj['passedParams']) passedParams = rowParamsObj['passedParams'];
        if (passedData && (passedData.altViewMode == "DynamicCustomPin" && socket == null)) {
            wsConnect = "yes";
            altViewMode = passedData.altViewMode;
            newWSConnect();
            setTimeout(function () {
                $.event.trigger({
                    type: type,
                    target: target,
                    passedData: passedData,
                    passedParams: passedParams
                });
            }, 2000);
        } else {
            if (!rowParamsObj.isTrafficHeatmap && type != null) {
                setTimeout(function () {
                    $.event.trigger({
                        type: type,
                        target: target,
                        passedData: passedData,
                        passedParams: passedParams
                    });
                }, 1000);
            } else {
                if (type != null) {
                    setTimeout(function () {
                        $.event.trigger({
                            type: type,
                            target: target,
                            passedData: passedData,
                            passedParams: passedParams,
                            isTrafficHeatmap: rowParamsObj.isTrafficHeatmap
                        });
                    }, 1000);
                }
            }
        }
    }

    function newWSConnect() {
        try {
            if (socket == null) {
                subscribedWsDevices = [];
                socket = io.connect("<?= $ssoEndpoint ?>", { "path": "/synoptics/socket.io" });
                //socket = io.connect("https://www.snap4city.org/", {"path": "/synoptics/socket.io"});
                //socket = io.connect("https://www.snap4city.org/", {"path": "/synopticsdev/socket.io"});

                socket.on('connect', () => {
                    try {
                        console.log("New WS Connected. Socket ID: " + socket.id);

                        if ("<?= $_SESSION['refreshToken'] ?>" != null && "<?= $_SESSION['refreshToken'] ?>" != "") {
                            tryingAuth = true;
                            $.ajax({
                                url: "../controllers/getAccessToken.php",
                                data: {
                                    refresh_token: "<?= $_SESSION['refreshToken'] ?>"
                                },
                                type: "GET",
                                async: true,
                                dataType: 'json',
                                success: function (dataSso) {
                                    try {
                                        if (socket != null && socket.connected) {
                                            socket.emit("authenticate", dataSso.accessToken);
                                        }
                                    } catch (errajax) {
                                        console.log("Error in ajax authencticate: " + errajax.message);
                                    }
                                },
                                error: function (errorData) {

                                }
                            });
                        }

                        socket.on("authenticate", function (data) {
                            try {
                                // console.log(JSON.parse(data))
                                // aggiorna var provando a fare authenticate
                                tryingAuth = false;

                            } catch (errAuth) {
                                console.log("Error in authencticate new WS: " + errAuth.message);
                            }
                        });

                        socket.on("subscribe", function (dataSub) {
                            try {
                                let subscribeObj = JSON.parse(dataSub);
                                console.log(subscribeObj);
                                if (subscribeObj.status != "OK") {

                                    socket.emit("subscribe", subscribeObj.request);
                                    socket.emit("subscribe", subscribeObj.request.split(" ")[0] + " __location");

                                } else {
                                    subscribedWsDevices.push(subscribeObj.request);
                                }
                            } catch (errSub) {
                                console.log("Error in subscribe new WS: " + errSub.message);
                            }
                        });
                    } catch (er) {
                        consoloe.log("Error on Connect new WS.")
                    }
                });

                socket.on('disconnect', function (data) {
                    try {
                        console.log("DISCONNECTED!");
                        //    socket = null;
                        //   newWSConnect();
                    } catch (errSub) {
                        console.log("Catch event in disconnect new WS: " + errSub.message);
                    }
                });
            }
        } catch (e) {
            console.log("Error in wsConnect.")
        }

    }

    function subscribeWsDevice(serviceUri, attr, currentCustomSvgLayer, isMobile) {

        //    console.log("Subscribe invoked for : " + serviceUri);
        // Controllo se mi sto autenticando
        try {
            if (tryingAuth != true) {
                if (!subscribedWsDevices.includes(serviceUri + " " + attr)) {
                    socket.off("update " + serviceUri + " " + attr);
                    socket.on("update " + serviceUri + " " + attr, function (data) {
                        try {
                            let updateObj = JSON.parse(data);
                            console.log(updateObj);
                            var countCustomPin = 0;
                            gisLayersOnMap[currentCustomSvgLayer].eachLayer(function (marker) {
                                try {
                                    countCustomPin++;
                                    if (marker.feature.properties.serviceUri == serviceUri) {
                                        let svgContainerUpdt = null;
                                        //   let tplPath = feature.properties.iconFilePath;
                                        svgContainerUpdt = $('<div id="' + widgetName + '_svgCtn' + countCustomPin + '">');
                                        $("#" + widgetName).append(svgContainerUpdt);
                                        if (updateObj.lastValue == null) {
                                            updateObj.lastValue = 0;
                                        }
                                        buildSvgIcon(marker.feature.properties.iconFilePath, updateObj.lastValue, 'error', null, svgContainerUpdt, widgetName, "map", countCustomPin, totalSvgCnt, currentCustomSvgLayer, svgContainerArray, true, serviceUri);
                                    }
                                } catch (errlayer) {
                                    console.log("Error in displaying new marker (new WS): " + errlayer.message);
                                }
                            });
                        } catch (errUpdt) {
                            console.log("Error in update new WS: " + errUpdt.message);
                        }
                    });
                    if (isMobile) {
                        socket.off("update " + serviceUri + " __location");
                        socket.on("update " + serviceUri + " __location", function (data) {
                            try {
                                let updateObj = JSON.parse(data);
                                console.log(updateObj);
                                var countCustomPin = 0;
                                gisLayersOnMap[currentCustomSvgLayer].eachLayer(function (marker) {
                                    try {
                                        countCustomPin++;
                                        if (marker.feature.properties.serviceUri == serviceUri) {
                                            if (updateObj.lastValue["latitude"] && updateObj.lastValue["longitude"]) {
                                                var newLatLng = new L.LatLng(updateObj.lastValue["latitude"], updateObj.lastValue["longitude"]);
                                                marker.setLatLng(newLatLng);
                                            }
                                        }
                                    } catch (errlayer) {
                                        console.log("Error in displaying new marker (new WS): " + errlayer.message);
                                    }
                                });
                            } catch (errUpdt) {
                                console.log("Error in update new WS: " + errUpdt.message);
                            }
                        });
                    }

                    setTimeout(function () {
                        try {
                            if (!subscribedWsDevices.includes(serviceUri + " " + attr)) {
                                socket.emit("subscribe", serviceUri + " " + attr);
                                if (isMobile) {
                                    socket.emit("subscribe", serviceUri + " __location");
                                }
                            }
                        } catch (err) {
                            console.log("Error in subscribe emit (new WS): " + err.message);
                        }
                    }, Math.floor(Math.random() * (1000 - 100 + 1) + 100));
                }
            } else {
                setTimeout(function () {
                    try {
                        subscribeWsDevice(serviceUri, attr, currentCustomSvgLayer, isMobile);
                    } catch (err) {
                        console.log("Error in subscribe reattempt (new WS): " + err.message);
                    }
                }, 1000);
            }
        } catch (err) {
            console.log("Error in subscribeWsDevice method (new WS): " + err.message);
        }
    }

    //// 3D Map - CORTI
    layersCreated = []; // layers created but not added to map
    layersAddedToMap = []; // layers already added to map

    function initMapsAndListeners(map) {
        let map2D = map.defaultMapRef;
        let map2DName = "<?= $_REQUEST['name_w'] ?>_map";

        //                removeAllLayers(map.default3DMapRef);

        // ready
        //    map2D.panTo(new L.LatLng(43.769789, 11.255694));

        // load menu
        getMenuAjaxCall();

        // dragend
        map2D.on('dragend', function () {
        });

        // zoomend
        map2D.on('zoomend', function () {
            // add layers with correct zoom
            for (var i = 0; i < layersCreated.length; i++) {
                addLayerToMapByZoom(layersCreated[i].menu, layersCreated[i].layer, layersCreated[i].subLayerIndex, i);
            }
        });

        //                let map3D = load3DMap(map2D);
        //
        //                return map3D;
    }

    function load3DMap(map2D) {

        //// WRLD
        var map = L.Wrld.map("3DMap", "9c04ad00edd787920af1a451bdd6553a", {
            center: map2D.getCenter(),
            zoom: 18
        });


        //// MAPBOX
        //                mapboxgl.accessToken = 'pk.eyJ1IjoiYW5kcmVhY29ydGk5MCIsImEiOiJjanhjN2dndTIwMGhnNDBvNDFkZzN3eHVoIn0.w07jn7vRfAcstoSz2EO5Ew';
        //                var map = new mapboxgl.Map({
        //                    style: 'mapbox://styles/mapbox/light-v10',
        //                    center: map2D.getCenter(),
        //                    zoom: 15.5,
        //                    pitch: 45,
        //                    bearing: -17.6,
        //                    container: '3DMap'
        //                });
        //
        //                map.on('load', function () {
        //                    // Insert the layer beneath any symbol layer.
        //                    var layers = map.getStyle().layers;
        //
        //                    var labelLayerId;
        //                    for (var i = 0; i < layers.length; i++) {
        //                        if (layers[i].type === 'symbol' && layers[i].layout['text-field']) {
        //                            labelLayerId = layers[i].id;
        //                            break;
        //                        }
        //                    }
        //
        //                    map.addLayer({
        //                        'id': '3d-buildings',
        //                        'source': 'composite',
        //                        'source-layer': 'building',
        //                        'filter': ['==', 'extrude', 'true'],
        //                        'type': 'fill-extrusion',
        //                        'minzoom': 15,
        //                        'paint': {
        //                            'fill-extrusion-color': '#aaa',
        //
        //                            // use an 'interpolate' expression to add a smooth transition effect to the
        //                            // buildings as the user zooms in
        //                            'fill-extrusion-height': [
        //                                "interpolate", ["linear"], ["zoom"],
        //                                15, 0,
        //                                15.05, ["get", "height"]
        //                            ],
        //                            'fill-extrusion-base': [
        //                                "interpolate", ["linear"], ["zoom"],
        //                                15, 0,
        //                                15.05, ["get", "min_height"]
        //                            ],
        //                            'fill-extrusion-opacity': .6
        //                        }
        //                    }, labelLayerId);
        //                });

        return map;
    }

    // CORTI
    function getMenuAjaxCall() {
        $.ajax({
            url: "../controllers/getWidgetParams.php?widgetName=<?php echo $_REQUEST['name_w']; ?>",
            type: "GET",
            data: {},
            async: true,
            dataType: 'json',
            success: function (data) {
                let parameters = JSON.parse(data.params.parameters);
                if (parameters.dropdownMenu) {
                    parameters.dropdownMenu.reverse().forEach(function (menu) {
                        let dropdownMenuField = $('#dropdownMenuTemplate').html();
                        $('#' + menu.header + 'Header').after(dropdownMenuField);
                        //    let mapOptionsDivName = widgetName + "_mapOptions";
                        let $item = $('#' + mapOptionsDivName).find('.appendable').first();
                        //    let $item = $('#mapOptions').find('.appendable').first();
                        $item.find('a').append(menu.label);

                        // icon
                        if (menu.external) {
                            $item.find('.appendable-icon').addClass('fa-map-pin');
                        } else {
                            $item.find('.appendable-icon').addClass('fa-check');
                        }
                        $item.find('.appendable-icon').attr('id', menu.id);

                        // listener
                        $item.find('a').click(function (evt) {
                            // check if layer is removable
                            let removeLayer = false;
                            if (menu.header !== "checkables") {
                                //    removeAllLayers(map.defaultMapRef);
                                var layers = [];
                                map.defaultMapRef.eachLayer(function (layer) {
                                    if (layer instanceof L.TileLayer) {
                                        layers.push(layer);
                                        if (layer.options.attribution != null && layer.options.attribution != undefined) {
                                            if (layer.options.attribution.includes("&copy;")) {
                                                map.defaultMapRef.removeLayer(layer);
                                                /* } else if (layer.options.layers.includes("orthomaps:")) {
                                                     map.defaultMapRef.removeLayer(layer);
                                                     for(var n = 0; n < layersCreated.length; n++) {
                                                         if (layersCreated[n].layer.options.layers == layer.options.layers) {
                                                             layersCreated.splice(n, 1);
                                                         }
                                                     }*/
                                            }
                                        } else if (layer.options.pane != null && layer.options.pane != undefined) {
                                            if (layer.options.layers != null && layer.options.layers != undefined) {
                                                if (layer.options.layers.includes("Snap4CIty:")) {
                                                    map.defaultMapRef.removeLayer(layer);
                                                }
                                            }
                                        }
                                    }
                                });
                                // removeAllIcons();
                                removeTileIcons();
                            } else {
                                if (!$(evt.target).find('.appendable-icon').hasClass('hidden')) {
                                    removeLayer = true;
                                }
                            }

                            // action
                            if (!removeLayer) {
                                switch (menu.service) {
                                    case "tileLayer":
                                        addTileLayer(evt, menu);
                                        break;
                                    case "WMS":
                                        addLayerWMS(evt, menu);
                                        break;
                                    case "KML":
                                        addLayerKML(evt, menu);
                                        break;
                                    case "GeoJSON":
                                        addLayerGeoJSON(evt, menu);
                                        break;
                                    case "SVG":
                                        addLayerSVG(evt, menu);
                                        break;
                                    default:
                                        console.log("No service selected.");
                                }

                                // icon
                                $(evt.target).find('.appendable-icon').removeClass('hidden');
                            } else {
                                removeLayerById(menu.id, evt);
                            }

                            // avoid dropdown close on click
                            evt.stopPropagation();
                        });
                    });
                }

                // select default map as active
                //    $('#mapOptions').find('.appendable-icon').first().removeClass('hidden')
                $('#' + mapOptionsDivName).find('.appendable-icon').first().removeClass('hidden')
            },
            error: function () {
                console.log("An error occurred.");
            },
            complete: function () {
            }
        });
    }

    function addLayerWMS(evt, menu) {
        let imageType = 'png';
        if (menu.imageType) {
            imageType = menu.imageType;
        }
        for (var subLayerIndex = 0; subLayerIndex < menu.layers.length; subLayerIndex++) {

            // zIndex
            map.defaultMapRef.createPane(menu.id + menu.layers[subLayerIndex].name);
            if (menu.zIndex) {
                map.defaultMapRef.getPane(menu.id + menu.layers[subLayerIndex].name).style.zIndex = menu.zIndex;
            }

            let layer = L.tileLayer.wms(menu.linkUrl, {
                layers: menu.layers[subLayerIndex].name,
                format: 'image/' + imageType,
                transparent: true,
                version: '1.1.0',
                attribution: "",
                pane: menu.id + menu.layers[subLayerIndex].name
            });
            if (!arrayContains(layersCreated, layer)) {
                layersCreated.push({ "menu": menu, "layer": layer, "subLayerIndex": subLayerIndex });
            }

            // check zoom and add to map
            addLayerToMapByZoom(menu, layer, subLayerIndex, layersCreated.length - 1);

        }
    }

    function addLayerToMapByZoom(menu, layer, subLayerIndex, i) {
        let zoom = map.defaultMapRef.getZoom();
        if ((zoom <= menu.layers[subLayerIndex].maxZoom && zoom >= menu.layers[subLayerIndex].minZoom) || !menu.layers[subLayerIndex].minZoom) {
            //  if (zoom <= menu.layers[subLayerIndex].maxZoom && zoom >= menu.layers[subLayerIndex].minZoom) {
            // check if layer is already on the map
            if (!map.defaultMapRef.hasLayer(layer)) {
                layer.on('loading', function () {
                    $('#loadingMenu').removeClass('hidden');
                }).on('load', function () {
                    $('#loadingMenu').addClass('hidden');
                }).addTo(map.defaultMapRef);
                if (!arrayContains(layersAddedToMap, layer)) {
                    layersAddedToMap.push({ "id": menu.id, "layer": layer });
                }
            }
        } else {
            map.defaultMapRef.removeLayer(layer);
            // remove from array layersAddedToMap
            for (var j = 0; j < layersAddedToMap.length; j++) {
                if (layersAddedToMap[j].layer.options.layers === layer.options.layers) {
                    layersAddedToMap.splice(j, 1);
                    j--;
                }
            }
        }
    }

    function removeLayerById(layerId, evt) {
        // remove from array layersAddedToMap
        for (var i = 0; i < layersAddedToMap.length; i++) {
            if (layersAddedToMap[i].id === layerId) {
                map.defaultMapRef.removeLayer(layersAddedToMap[i].layer);
                // remove from array
                layersAddedToMap.splice(i, 1);
                i--;
            }
        }
        // remove from array layersCreated
        for (var j = 0; j < layersCreated.length; j++) {
            if (layersCreated[j].menu.id === layerId) {
                map.defaultMapRef.removeLayer(layersCreated[j].layer);
                // remove from array
                layersCreated.splice(j, 1);
                j--;
            }
        }
        if (evt) {
            $(evt.target).find('.appendable-icon').addClass('hidden');
        }
        $('#loadingMenu').addClass('hidden');
    }

    function removeAllLayers(map) {
        map.eachLayer(function (layer) {
            map.removeLayer(layer);
        });
        layersAddedToMap = [];
        layersCreated = [];

        // remove icons
        removeAllIcons();
    }

    // change tileLayer of the map: light, dark, etc
    function addTileLayer(evt, menu) {
        let layer;
        if (menu.minZoom != undefined && menu.maxZoom != undefined) {       // MOD PANTALEO-CORTI
            layer = L.tileLayer(menu.linkUrl, {
                attribution: menu.layerAttribution,
                apikey: menu.apiKey,
                minZoom: menu.minZoom,
                maxZoom: menu.maxZoom,
                maxNativeZoom: leafletNativeMaxZoom
            }).addTo(map.defaultMapRef);
        } else {
            layer = L.tileLayer(menu.linkUrl, {
                attribution: menu.layerAttribution,
                apikey: menu.apiKey,
                maxZoom: leafletMaxZoom,
                maxNativeZoom: leafletNativeMaxZoom
            }).addTo(map.defaultMapRef);
        }
        layersAddedToMap.push({ "id": menu.id, "layer": layer });

        // example of TMS for GeoServer
        //                let layer = L.tileLayer('http://localhost:8080/geoserver/gwc/service/tms/1.0.0/ambiti_amministrativi_toscana:firenze_sat_here_z17@EPSG%3A900913@jpeg/{z}/{x}/{y}.png', {
        //                  maxZoom: leafletMaxZoom
        //                  tms: true,
        //                  crs: L.CRS.EPSG4326,
        //                  attribution: false
        //                });
    }

    function addLayerKML(evt, menu) {
        var kmlLayer = new L.KML(menu.linkUrl, {
            async: true
        });
        map.defaultMapRef.addLayer(kmlLayer);
        layersAddedToMap.push({ "id": menu.id, "layer": kmlLayer });

        map.defaultMapRef.kmlLayer.zIndex = 420;
    }

    function addLayerGeoJSON(evt, menu) {

        // zIndex
        map.defaultMapRef.createPane(menu.id);
        if (menu.zIndex) {
            map.defaultMapRef.getPane(menu.id).style.zIndex = menu.zIndex;
        }

        jQuery.getJSON(menu.linkUrl, function (data) {
            let layer = L.geoJSON(data, {
                pane: menu.id
            }).addTo(map.defaultMapRef);
            layersAddedToMap.push({ "id": menu.id, "layer": layer });
        });
    }

    function addLayerSVG(evt, menu) {
        let imageBounds = [[9.716489, 42.2392816], [12.3529926, 44.47160041252872]];
        L.imageOverlay(menu.linkUrl, imageBounds).addTo(map.defaultMapRef);
    }

    function removeAllIcons() {
        $('.appendable-icon').addClass('hidden');
    }

    function removeTileIcons() {
        //  $('.appendable-icon').addClass('hidden');
        for (n = 0; n < $('.appendable-icon').length; n++) {
            if ($('.appendable-icon')[n].className.includes("fa-map") && !$('.appendable-icon')[n].className.includes("hidden")) {
                $('.appendable-icon')[n].className = $('.appendable-icon')[n].className + " hidden";
            }
        }
    }

    function arrayContains(array, layer) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].layer.options.layers === layer.options.layers) {
                return true;
            }
        }
        return false;
    }


                    ////////

        });//Fine document ready

     

</script>

<style>
    <!-- CORTI 
    -->
    #3DMapContainer {
    width:
    100%;
    display:
    none;
    }
    #3DMap {
    width:
    100%;
    }
    .mapOptions {
    position:
    absolute;
    top:
    36px;
    left:
    70px;
    z-index:
    400;
    }
    .dropdown-menu
    .dropdown-header {
    padding-left:
    10px;
    color:
    #c3c3c3;
    }
    .dropdown-menu
    .dropdown-item {
    padding-left:
    10px;
    }
</style> <!-- FINE CORTI STYLE -->

<!-- OD POPUP STYLE -->
<style>
    .leaflet-popup-content {
        margin: 0;
        line-height: 1.5;
        width: auto !important;
        max-width: 400px;
    }

    .leaflet-popup-tip-container {
        display: none;
    }

    .leaflet-popup-content-wrapper {
        width: auto;
    }

    .draggable {
        -webkit-user-drag: element;
        /* Per Chrome e Safari */
        user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
        user-drag: element;
    }
</style>
<!-- FINE OD POPUP STYLE -->

<div class="widget" id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_div">
    <div class='ui-widget-content'>
        <!-- Inclusione del modulo comune che costruisce la testata del widget, JS incluso -->
        <?php include '../widgets/widgetHeader.php'; ?>

        <!-- Inclusione del modulo comune che costruisce il menu constestaule di gestione del widget -->
        <?php include '../widgets/widgetCtxMenu.php'; ?>

        <!-- Schermata di loading -->
        <div id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_loading" class="loadingDiv">
            <div class="loadingTextDiv">
                <p>Loading data, please wait</p>
            </div>
            <div class="loadingIconDiv">
                <i class='fa fa-spinner fa-spin'></i>
            </div>
        </div>

        <!-- Contenitore esterno del contenuto del widget -->
        <div id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_content"
            class="content mapContainer">

            <!-- Modulo comune per la gestione dei dimensionatori del widget in edit dashboard -->
            <?php include '../widgets/commonModules/widgetDimControls.php'; ?>

            <!-- Pannello che viene mostrato quando non ci sono dati disponibili per il widget in esame -->
            <div id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_noDataAlert"
                class="noDataAlert">
                <div id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_noDataAlertText"
                    class="noDataAlertText">
                    No data available
                </div>
                <div id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_noDataAlertIcon"
                    class="noDataAlertIcon">
                    <i class="fa fa-times"></i>
                </div>
            </div>

            <!-- Dentro questo DIV ci va il contenuto vero e proprio (e specifico) del widget (si chiama _chartContainer solo per legacy, non contiene necessariamente un grafico) -->
            <!--    <div id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_chartContainer" class="chartContainer">   -->
            <div id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_chartContainer"
                class="map2dContainer">
                <!-- Originale 1-->
                <!--<div id="map" style="height: 180px"></div>-->

                <!-- Correzione 1 -->
                <div id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_map"
                    style="height: 100%; width: 100%;"></div>

                <!-- Layers & 3D CORTI -->
                <div class="dropdown mapOptions"
                    id="<?= str_replace('.', '_', str_replace('-', '_', $_REQUEST['name_w'])) ?>_mapOptions">
                    <button class="btn btn-primary dropdown-toggle" type="button" id="dropdownMenu1"
                        data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">
                        <i class="fa fa-spinner fa-spin hidden" id="loadingMenu"></i> Maps
                        <span class="caret"></span>
                    </button>
                    <ul class="dropdown-menu map-menu" id="dropdown-menu-id" aria-labelledby="dropdownMenu1">
                        <li class="dropdown-header hidden">2D / 3D</li>
                        <li><a class="dropdown-item hidden" href="#" id="2DButton">2D Map</a></li>
                        <li><a class="dropdown-item hidden" href="#" id="3DButton">3D Map</a></li>
                        <li role="separator" class="divider hidden"></li>
                        <!--   <li class="dropdown-header" id="layersHeader">World OrthMaps</li>   -->
                        <li class="dropdown-header" id="layersHeader">External Providers Open Orthomaps</li>
                        <li role="separator" class="divider"></li>
                        <!--   <li class="dropdown-header" id="checkablesHeader">Checkable Layers/Maps</li>    -->
                        <li class="dropdown-header" id="checkablesHeader">WMS & GeoJSON Orthomaps</li>
                    </ul>
                    <template id="dropdownMenuTemplate">
                        <li class="appendable">
                            <a class="dropdown-item" href="#">
                                <i class="fa appendable-icon hidden"></i>
                            </a>
                        </li>
                    </template>
                </div>


                <!--    <div id="3DMapContainer" style="height: 500px">
                    <div id="3DMap" style="height: 500px"></div>
                </div>	--> <!-- FINE Layers & 3D CORTI -->

            </div>
        </div>
    </div>
    <div id="<?= $_REQUEST['name_w'] ?>_code"></div>
</div>